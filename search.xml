<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>并发</title>
    <url>/2022/04/07/Concurrency/</url>
    <content><![CDATA[<p>锁、条件变量的实现与使用<br><span id="more"></span></p>
<p>多线程/多进程的目的：</p>
<p>对于单 CPU 来说，只是提供一种程序同时执行的错觉。</p>
<p>对于单 CPU 来说，如果没有 IO 阻塞操作（即读取磁盘操作），单线程执行多个任务，总时间更短，因为多线程单CPU无法并发执行，会导致线程切换，带来额外开销；如果有 IO 阻塞操作，多线程可以利用阻塞时间，因此多线程可能更快，应该综合考虑阻塞时间的利用和线程切换的消耗，看哪个大</p>
<p>多线程/多进程可以利用多 CPU</p>
<p>协程</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="自旋锁的实现"><a href="#自旋锁的实现" class="headerlink" title="自旋锁的实现"></a>自旋锁的实现</h2><p>自旋锁基于硬件原语实现，这是因为硬件原语可以原子地获取表示锁状态的计数器。包括测试并设置指令（test-and-set）、比较并交换指令（compare-and-swap）和获取并增加指令（fetch-and-add）。</p>
<h3 id="失败的尝试"><a href="#失败的尝试" class="headerlink" title="失败的尝试"></a>失败的尝试</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> </span><br><span class="line">	<span class="type">int</span> flag; <span class="comment">// 0 -&gt; lock is available, 1 -&gt; held </span></span><br><span class="line">&#125;<span class="type">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">	mutex-&gt;flag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (mutex-&gt;flag == <span class="number">1</span>) </span><br><span class="line">    	; <span class="comment">// spin-wait (do nothing)，自旋，即不断扫描锁的状态</span></span><br><span class="line">	mutex-&gt;flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123; </span><br><span class="line">	mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下的执行过程将导致两个线程都进入到临界区，不会有一个处于自旋等待状态。<strong>失败的原因是：获取并更新锁状态的操作不是原子的</strong></p>
<p><img src="/2022/04/07/Concurrency/1643699387182-83e08ca1-3a9f-40df-8bf7-d66a1145ab15.png" alt></p>
<h3 id="可用的自旋锁"><a href="#可用的自旋锁" class="headerlink" title="可用的自旋锁"></a>可用的自旋锁</h3><h4 id="测试并设置指令（test-and-set）"><a href="#测试并设置指令（test-and-set）" class="headerlink" title="测试并设置指令（test-and-set）"></a>测试并设置指令（test-and-set）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> *old_ptr, <span class="type">int</span> new)</span> &#123; </span><br><span class="line">    <span class="type">int</span> old = *old_ptr; <span class="comment">// fetch old value at old_ptr </span></span><br><span class="line">    *old_ptr = new;    <span class="comment">// store &#x27;new&#x27; into old_ptr </span></span><br><span class="line">    <span class="keyword">return</span> old;        <span class="comment">// return the old value </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>TestAndSet() 返回 old_ptr 指向的旧值，同时更新 old_ptr 为 new。由于这些代码是原子地执行，所以我们把这条指令叫作“测试<strong>并</strong>设置”。</p>
<p>用测试并设置指令实现自旋锁的方式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> </span><br><span class="line">	<span class="type">int</span> flag; </span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">    	;spin-wait (<span class="keyword">do</span> nothing)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>由于 TestAndSet(&amp;lock-&gt;flag, 1) 是原子操作，因此获取锁的过程是互斥的</strong>。</p>
<h4 id="比较并交换指令（compare-and-swap）"><a href="#比较并交换指令（compare-and-swap）" class="headerlink" title="比较并交换指令（compare-and-swap）"></a>比较并交换指令（compare-and-swap）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expected, <span class="type">int</span> new)</span> &#123; </span><br><span class="line">    <span class="type">int</span> actual = *ptr; </span><br><span class="line">    <span class="keyword">if</span> (actual == expected) </span><br><span class="line">    	*ptr = new; </span><br><span class="line">    <span class="keyword">return</span> actual; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CompareAndSwap() 检测 ptr 指向的内存单元的值是否和 expected 相等；如果是，更新 ptr 所指的值为新值。否则，什么也不做。并返回操作之后 ptr 指向的内存单元的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">    	;spin-wait (<span class="keyword">do</span> nothing)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取并增加指令（fetch-and-add）"><a href="#获取并增加指令（fetch-and-add）" class="headerlink" title="获取并增加指令（fetch-and-add）"></a>获取并增加指令（fetch-and-add）</h4><p>获取并增加指令（fetch-and-add）能原子地返回特定地址的旧值，并且让该值自增一</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FetchAndAdd</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123; </span><br><span class="line">    <span class="type">int</span> old = *ptr; </span><br><span class="line">    *ptr = old + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> old; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> </span><br><span class="line">    <span class="type">int</span> ticket; </span><br><span class="line">    <span class="type">int</span> turn; </span><br><span class="line">&#125; <span class="type">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>; </span><br><span class="line">    lock-&gt;turn   = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">    <span class="type">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket); </span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn) </span><br><span class="line">    	; <span class="comment">// spin </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">	FetchAndAdd(&amp;lock-&gt;turn); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>ticket 锁用了 ticket 和 turn 变量来构建锁。基本操作也很简单：如果线程希望获取锁，首先对一个 ticket 值执行一次原子的 FetchAndAdd 指令。这个值作为该线程的顺位，即 myturn。根据全局共享的 lock-&gt;turn 变量，当某一个线程的（myturn == turn）时，则轮到这个线程进入临界区。unlock 则是增加 lock-&gt;turn，从而下一个等待线程可以进入临界区。 </p>
<p>不同于之前的方法：本方法能够保证所有线程都能抢到锁。只要一个线程获得了 ticket 值，它最终会被调度。之前的方法则不会保证（存在饥饿问题）。比如基于测试并设置的方法，一个线程有可能一直自旋，即使其他线程在获取和释放锁。</p>
<blockquote>
<p>存在的问题：如果一个线程调用了多次 unlock()？这是可以的</p>
</blockquote>
<h2 id="自旋锁的性能"><a href="#自旋锁的性能" class="headerlink" title="自旋锁的性能"></a>自旋锁的性能</h2><p>以两个线程运行在单处理器上为例，当一个线程（线程0）持有锁时，被中断。第二个线程（线程1）去获取锁，发现锁已经被持有。因此，它就开始自旋，直到，时钟中断产生，操作系统切换线程，线程 0 重新运行，它释放锁。下一次轮到线程1 时，线程 1 不需要继续自旋了，它获取了锁。</p>
<p>也就是说，一个线程会一直自旋检查一个不会改变的值，浪费掉整个时间片。如果有 N个线程去竞争一个锁，情<br>况会更糟糕。同样的场景下，会浪费 N−1 个时间片。</p>
<p>如果有多个处理器：</p>
<ul>
<li>持有锁的线程被中断后没有迅速被重新调度运行，也会有这个问题。</li>
<li>持有锁的线程并没有因为 CPU 时钟中断切换线程而暂停，由于临界区代码通常较短，它可能被迅速执行完，然后释放锁。其他 CPU 上等待的线程在一个时间片内获得了锁。</li>
</ul>
<p>自旋等待其他线程释放锁的时候会浪费时间。尤其是在单处理器上，一个等待线程等待的目标线程甚至无法运行（至少在上下文切换之前）（处于自旋等待的线程占用 CPU，导致目标线程根本无法运行，也不可能释放锁，一个线程会一直自旋检查一个不会改变的值，浪费掉整个时间片）</p>
<h2 id="自旋锁的优化"><a href="#自旋锁的优化" class="headerlink" title="自旋锁的优化"></a>自旋锁的优化</h2><h3 id="在要自旋的时候，放弃CPU"><a href="#在要自旋的时候，放弃CPU" class="headerlink" title="在要自旋的时候，放弃CPU"></a>在要自旋的时候，放弃CPU</h3><p>如下是测试并设置指令结合让出 CPU 实现的锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123; </span><br><span class="line">	flag = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;flag, <span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">    	yield(); <span class="comment">// give up the CPU </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123; </span><br><span class="line">	flag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法中，我们假定操作系统提供<strong>原语</strong> yield()，线程可以调用它主动放弃 CPU，让其他线程运行。线程可以处于 3 种状态之一（运行、就绪和阻塞）。yield() 系统调用能够让运行（running）态变为就绪（ready）态，从而允许其他线程运行。因此，让出线程本质上取消调度（deschedules）了它自己。</p>
<p>考虑在单 CPU 上运行两个线程。在这个例子中，基于 yield 的方法十分有效。一个线程调用 lock()，发现锁被占用时，让出 CPU，另外一个线程运行，完成临界区。在这个简单的例子中，让出方法工作得非常好。 </p>
<p>现在来考虑在单 CPU 上运行多个线程（例如 100 个）反复竞争一把锁的情况。在这种情况下，一个线程持有锁，在释放锁之前被抢占，其他 99 个线程分别调用 lock()，发现锁被抢占，然后让出 CPU。</p>
<ul>
<li>假定操作系统采用队列来轮转调度，这 99 个线程会一直处于运行—让出这种模式，直到持有锁的线程再次运行。虽然比原来的浪费 99 个时间片的自旋方案要好，但这种方法仍然成本很高，因为上下文切换的次数相比原来没有变化，仍旧进行了 99 次的切换。</li>
<li>可能出现线程饿死的问题。一个线程可能一直处于让出的循环，而其他线程反复进出临界区。例如线程 A 每次得到时间片的时候，获得锁的线程都还没有释放锁，则线程 A 一直处于让出的循环。甚至可能是因为调度的问题，每次线程让出 CPU 后，又被调度了。</li>
</ul>
<h3 id="使用队列：休眠替代自旋"><a href="#使用队列：休眠替代自旋" class="headerlink" title="使用队列：休眠替代自旋"></a>使用队列：休眠替代自旋</h3><p>前面一些方法的<strong>真正问题是存在太多的偶然性</strong>。线程的调度顺序由操作系统控制。如果调度不合理，线程或者一直自旋，或者立刻让出 CPU。无论哪种方法，都可能造成资源的浪费和线程饿死问题。</p>
<p>也就是说，<strong>竞争锁的线程一直在被调度运行，实际上这不是必要的。只有当锁能够获取时才需要被调度</strong>。</p>
<ul>
<li><p>我们必须显式地施加某种控制，决定锁释放时，谁能抢到锁。为了做到这一点，我们需要操作系统的更多支持，并需要一个队列来保存等待锁的线程。 </p>
</li>
<li><p>简单起见，我们利用 Solaris 提供的支持，它提供了两个调用：</p>
<ul>
<li><p>park() 能够让调用线程休眠，休眠被唤醒后，会从 park() 下一条语句继续执行</p>
</li>
<li><p>unpark(threadID) 则会唤醒 threadID 标识的线程。</p>
</li>
</ul>
</li>
</ul>
<p>可以用 park() 和 unpark(threadID) 这两个调用来实现锁，让调用者在获取不到锁时睡眠，在锁可用时被唤醒。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> </span><br><span class="line">    <span class="type">int</span> flag; </span><br><span class="line">    <span class="type">int</span> guard; </span><br><span class="line">    <span class="type">queue_t</span> *q; </span><br><span class="line">&#125;<span class="type">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123; </span><br><span class="line">    m-&gt;flag  = <span class="number">0</span>; </span><br><span class="line">    m-&gt;guard = <span class="number">0</span>; </span><br><span class="line">   queue_init(m-&gt;q); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123; </span><br><span class="line">   <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">       ; </span><br><span class="line">   <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123; </span><br><span class="line">       m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acquired </span></span><br><span class="line">       m-&gt;guard = <span class="number">0</span>; </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">       queue_add(m-&gt;q, gettid()); </span><br><span class="line">       m-&gt;guard = <span class="number">0</span>; </span><br><span class="line">       park(); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123; </span><br><span class="line">   <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">       ; </span><br><span class="line">   <span class="keyword">if</span> (queue_empty(m-&gt;q)) </span><br><span class="line">       m-&gt;flag = <span class="number">0</span>; <span class="comment">// 释放锁 </span></span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">       unpark(queue_remove(m-&gt;q)); </span><br><span class="line">   m-&gt;guard = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将测试并设置指令和等待队列结合，实现了一个更高性能的锁。通过队列来控制谁会获得锁，避免饿死。</p>
<p>需要注意到：</p>
<p>unpark(threadID) 只会唤醒一个线程，不会唤醒全部等待的线程（这会导致不确定性，竞争锁）。这里的实现方法是公平锁，即唤醒队头线程。</p>
<h4 id="锁的互斥性分析"><a href="#锁的互斥性分析" class="headerlink" title="锁的互斥性分析"></a>锁的互斥性分析</h4><p>证明不同线程获得锁是互斥的。<strong>实际上证明的是不同线程互斥地离开 lock() 函数并执行临界区代码，而非 lock() 和 unlock() 不同线程需要串行执行</strong>。</p>
<p><strong>第一种情况</strong>：</p>
<p>假设某时刻没有线程获得锁，m-&gt;guard 为 0，若此时刻线程 A 被调度运行，调用 lock()，当执行 while (TestAndSet(&amp;m-&gt;guard, 1) == 1) ; 时，TestAndSet(&amp;m-&gt;guard, 1) == 1 方法：</p>
<ul>
<li><p>原子地将 m-&gt;guard 置 1 并返回 0，通过将 m-&gt;guard 置 1 保证 lock() 和 unlock() 的互斥性，尚未标识锁已经被持有</p>
</li>
<li><p>线程能够跳出 while 循环继续执行。当线程执行到 if 语句，由于 m-&gt;flag 为 0，线程会执行</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">m-&gt;flag = <span class="number">1</span>; <span class="comment">// 本线程获得了锁</span></span><br><span class="line">m-&gt;guard = <span class="number">0</span>; <span class="comment">// 打开互斥区</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后线程会执行临界区代码，当线程离开临界区，此时 m-&gt;guard 为 0，它能够跳出循环（m-&gt;guard 已经被置 1）。并根据队列情况决定释放锁还是唤醒线程，然后再将 m-&gt;guard 置 0，打开互斥区。</p>
<p><strong>第二种情况</strong>：</p>
<p>假设某个线程已经持有锁，即 m-&gt;flag 为 1，本线程调用 lock()，如果持有锁的线程还没有执行到 m-&gt;guard = 0; 的语句，那么本线程会在 while 处自旋等待，如果持有锁的线程执行了 if-else 块的 if 部分，则本线程能够跳出 while，并且这会导致：</p>
<ul>
<li>持有锁的线程在 unlock() 的 while 处自旋</li>
<li>其他尝试获取锁的线程在 lock() 的 while 处自旋</li>
</ul>
<p>本线程会继续执行 if-else 块的 else 部分，将自己加入队列（虽然进入了休眠队列，但实际上还没有休眠）、将 m-&gt;guard 置 0 打开互斥区，然后休眠。</p>
<p>当持有锁的线程执行了 unlock() 的 else 部分，会唤醒队头线程，在持有锁的线程执行 unlock() 的 m-&gt;guard = 0; 语句之前，如果此时队头线程被调度了，它能够执行临界区的代码，但是会在 unlock() 的 while 处自旋。</p>
<blockquote>
<ol>
<li><p>如果m-&gt;guard = 0; 和 park(); 互换，park后被休眠，无法执行m-&gt;guard = 0;  其他线程一直被锁住</p>
</li>
<li><p>当持有锁的线程要释放锁，如果队列不为空，它会唤醒队头的线程，同时 .m-&gt;flag 保持为 1。不需要置 flag=0，也不能置其为 0，因为被唤醒的线程会在 park 后的位置继续执行，它不会倒回去执行 flag=1</p>
</li>
</ol>
</blockquote>
<h4 id="唤醒-等待竞争（wakeup-waiting-race）"><a href="#唤醒-等待竞争（wakeup-waiting-race）" class="headerlink" title="唤醒/等待竞争（wakeup/waiting race）"></a>唤醒/等待竞争（wakeup/waiting race）</h4><p>这种现象产生的原因是：”本线程会继续执行 if-else 块的 else 部分，将自己加入队列（虽然进入了休眠队列，但实际上还没有休眠）、将 m-&gt;guard 置 0 打开互斥区，然后休眠”</p>
<p>考虑两个线程的情况。假设一个线程 A 将要 park，在这之前，它已被加入等待队列（队列只有它）。这时切换到持有锁的线程 B。持有锁的线程 B 会执行 unpark。这导致线程 A 从队列中被移除，然后被唤醒。然而，线程B继续执行，会执行 park，陷入休眠。由于线程 A 已经不在队列中，它永远无法被唤醒（可能，如果操作系统不处理这种不在调度队列且一直休眠的线程）。</p>
<p>Solaris 通过增加了第三个系统调用 separk() 来解决这一问题。通过 setpark()，一个线程表明自己马上要 park。如果刚好另一个线程被调度，并且调用了 unpark，那么后续的 park调用就会直接返回，而不是一直睡眠。lock()调用可以做一点小修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">queue_add(m-&gt;q, gettid()); </span><br><span class="line">setpark(); </span><br><span class="line">m-&gt;guard = <span class="number">0</span>; </span><br></pre></td></tr></table></figure>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p><img src="/2022/04/07/Concurrency/1647569931834-e7d0bf33-43a6-4c34-8a33-8be6345076d0.jpeg" alt="思维导图"></p>
<h3 id="1-乐观锁-VS-悲观锁"><a href="#1-乐观锁-VS-悲观锁" class="headerlink" title="1 乐观锁 VS 悲观锁"></a>1 乐观锁 VS 悲观锁</h3><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</p>
<p>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p>
<h3 id="2-自旋锁-VS-适应性自旋锁"><a href="#2-自旋锁-VS-适应性自旋锁" class="headerlink" title="2 自旋锁 VS 适应性自旋锁"></a>2 自旋锁 VS 适应性自旋锁</h3><p>在许多场景中，同步资源的锁定时间很短（同步代码块执行需要的时间很短），为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。</p>
<p>如果有<strong>多个处理器</strong>，能够让两个或以上的线程同时执行，我们就可以让后面那个请求锁的线程不放弃 CPU 的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h3 id="3-公平锁-VS-非公平锁"><a href="#3-公平锁-VS-非公平锁" class="headerlink" title="3 公平锁 VS 非公平锁"></a>3 公平锁 VS 非公平锁</h3><p>公平锁：多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，每次唤醒队头线程，让它获得锁。</p>
<ul>
<li>优点是等待锁的线程不会饿死。</li>
<li>缺点是与比非公平锁相比，唤起线程的开销大，因为新的线程都是先被阻塞再被唤醒。</li>
</ul>
<p>非公平锁：新的线程直接尝试获取锁，如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，获取不到才会到等待队列的队尾等待。</p>
<ul>
<li>优点是可以减少唤起线程的开销，因为线程有几率不阻塞直接获得锁。</li>
<li>缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</li>
</ul>
<h3 id="4-可重入锁-VS-非可重入锁"><a href="#4-可重入锁-VS-非可重入锁" class="headerlink" title="4 可重入锁 VS 非可重入锁"></a>4 可重入锁 VS 非可重入锁</h3><h3 id="5-独享锁-VS-共享锁"><a href="#5-独享锁-VS-共享锁" class="headerlink" title="5 独享锁 VS 共享锁"></a>5 独享锁 VS 共享锁</h3><p>独享锁，是指该锁一次只能被一个线程所持有。如果线程对数据加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。例如 synchronized 和 ReentrantLock</p>
<p>共享锁是指该锁可被多个线程所持有。如果线程对数据 A 加上共享锁后，则其他线程只能对 A 再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p>独享锁也叫排他锁、互斥锁、写锁，共享锁也叫做读锁。</p>
<h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>在很多情况下，线程需要检查某一条件（condition）满足之后，才会继续运行。例如，父线程需要检查子线程是否执行完毕 （这常被称为 join()）。这种等待如何实现呢？</p>
<p><strong>法 1：用一个主线程和子线程的共享变量，记录该条件的状态，主线程自旋等待</strong>。这会导致浪费CPU 时间。我们希望有某种方式让父线程休眠，直到等待的条件满足（对于 join() 即子线程完成执行）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> done = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>); </span><br><span class="line">    done = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>); </span><br><span class="line">    <span class="type">pthread_t</span> c; </span><br><span class="line">    Pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>); <span class="comment">// create child </span></span><br><span class="line">    <span class="keyword">while</span> (done == <span class="number">0</span>) </span><br><span class="line">        ; <span class="comment">// spin </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>法 2：使用条件变量</strong></p>
<ul>
<li><p>条件变量是一个显式队列，当某些条件（condition）不满足时，线程可以把自己加入等待队列，等待该条件满足。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让它们继续执行。</p>
</li>
<li><p>在 POSIX 中，可以用 pthread_cond_t  c  = PTHREAD_COND_INITIALIZER; 声明并初始化一个条件变量。</p>
</li>
<li><p>条件变量有两种相关操作：wait() 和 signal()。线程调用 wait() 会休眠，进入等待队列。当线程想唤醒等待在某个条件变量上的线程时，调用 signal()。POSIX 用以下函数执行 wait() 和 signal() ：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cond_wait(<span class="type">pthread_cond_t</span> *c, <span class="type">pthread_mutex_t</span> *m);  </span><br><span class="line">pthread_cond_signal(<span class="type">pthread_cond_t</span>  *c); </span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>wait()会释放锁，并让调用线程wait的休眠。注意休眠的同时会释放锁（原子操作），本线程休眠后是走不到下面那个unlock()语句的。当线程被唤醒时（在另外某个线程发信号给它后），它必须重新获取锁，再返回调用者。（被唤醒后进入就绪状态，继续执行unlock前，必须先获得锁）</p>
<ul>
<li>signal() 唤醒 等待在某个条件变量上的 睡眠线程，被唤醒后处于就绪状态，等待调度</li>
</ul>
<h2 id="实现-join-和-exit"><a href="#实现-join-和-exit" class="headerlink" title="实现 join() 和 exit()"></a>实现 join() 和 exit()</h2><p>互斥量目的：保证 join 和exit是互斥执行的，在java多线程编程中，例如 synchronized，互斥量：this~monitor、条件变量或者说队列，其实也是monitor。而这里的自由度是很高的，可以任意设定互斥量和条件变量，reentrantlock 有类似的思想。</p>
<p>条件变量目的：一个线程可能要等待多种条件，每个条件对应一个等待队列，用条件变量表示条件。</p>
<p>每个条件变量需要配合一个状态变量 done。个人理解，条件变量其实只是一个等待队列的含义，它并不能表示条件是否为 true 这个东西，需要状态变量来做。也可以多个条件变量对应一个状态变量（实际上是每个条件变量对应状态变量的一个值），例子有生产者消费者问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> done = <span class="number">0</span>; <span class="comment">// 共享变量，状态变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER; <span class="comment">// 锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> c  = PTHREAD_COND_INITIALIZER; <span class="comment">// 条件变量，实际上也是共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thr_join</span><span class="params">()</span> &#123; </span><br><span class="line">   Pthread_mutex_lock(&amp;m); </span><br><span class="line">   <span class="keyword">while</span> (done == <span class="number">0</span>) </span><br><span class="line">       Pthread_cond_wait(&amp;c, &amp;m); </span><br><span class="line">   Pthread_mutex_unlock(&amp;m); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thr_exit</span><span class="params">()</span> &#123; </span><br><span class="line">    Pthread_mutex_lock(&amp;m); </span><br><span class="line">    done = <span class="number">1</span>; </span><br><span class="line">    Pthread_cond_signal(&amp;c); </span><br><span class="line">    Pthread_mutex_unlock(&amp;m); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程执行的函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>); </span><br><span class="line">    thr_exit(); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>); </span><br><span class="line">   <span class="type">pthread_t</span> p; </span><br><span class="line">   Pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>); </span><br><span class="line">   thr_join(); </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过两种情况分析 join 和 exit 设计上的正确性</p>
<p>第一种情况是父线程创建出子线程，但自己继续运行（假设只有一个处理器），然后马上调用thr_join()等待子线程。在这种情况下，它会先获取锁，检查子进程是否完成（还没有完成），然后调用wait()，让自己休眠。子线程最终得以运行，打印出“child”，并调用thr_exit()函数唤醒父进程，这段代码会在获得锁后设置状态变量done，然后向父线程发信号唤醒它。最后，父线程会运行（从wait()调用返回并持有锁），释放锁，打印出“parent:end”</p>
<p>第二种情况是，子线程在创建后，立刻运行，设置变量done为1，调用signal函数唤醒其他线程（这里没有其他线程），然后结束。父线程运行后，调用thr_join()时，发现done已经是1了，就直接返回</p>
<p>如果没有互斥量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thr_join</span><span class="params">()</span> &#123; </span><br><span class="line">   <span class="keyword">while</span> (done == <span class="number">0</span>) </span><br><span class="line">       Pthread_cond_wait(&amp;c, &amp;m); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thr_exit</span><span class="params">()</span> &#123; </span><br><span class="line">    done = <span class="number">1</span>; </span><br><span class="line">    Pthread_cond_signal(&amp;c); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>如果父进程调用 thr_join()，然后检查完 done 的值为0，然后试图睡眠。但在调用wait 进入睡眠之前，父进程被中断。子线程修改变量done 为1，发出信号，同样没有等待线程。父线程再次运行时，就会长眠不醒。</p>
<p>如果没有状态变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thr_join</span><span class="params">()</span> &#123; </span><br><span class="line">   Pthread_mutex_lock(&amp;m); </span><br><span class="line">   Pthread_cond_wait(&amp;c, &amp;m); </span><br><span class="line">   Pthread_mutex_unlock(&amp;m); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thr_exit</span><span class="params">()</span> &#123; </span><br><span class="line">    Pthread_mutex_lock(&amp;m); </span><br><span class="line">    Pthread_cond_signal(&amp;c); </span><br><span class="line">    Pthread_mutex_unlock(&amp;m); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>则对于第二种情况，即子线程立刻运行，并且调用 thr_exit()。在这种情况下，子线程发送信号，但此时却没有在条件变量上睡眠等待的线程。父线程运行时，就会调用wait并始终休眠。</p>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h2 id="实现方案-1"><a href="#实现方案-1" class="headerlink" title="实现方案 1"></a>实现方案 1</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">cond_t</span> cond; </span><br><span class="line"><span class="type">mutex_t</span> mutex; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">        Pthread_mutex_lock(&amp;mutex);           <span class="comment">// p1 </span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>)                       <span class="comment">// p2 </span></span><br><span class="line">            Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// p3 </span></span><br><span class="line">        put(i);                               <span class="comment">// p4 </span></span><br><span class="line">        Pthread_cond_signal(&amp;cond);           <span class="comment">// p5 </span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex);         <span class="comment">// p6 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">   <span class="type">int</span> i; </span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">       Pthread_mutex_lock(&amp;mutex);           <span class="comment">// c1 </span></span><br><span class="line">       <span class="keyword">if</span> (count == <span class="number">0</span>)                       <span class="comment">// c2 </span></span><br><span class="line">           Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// c3 </span></span><br><span class="line">       <span class="type">int</span> tmp = get();                      <span class="comment">// c4 </span></span><br><span class="line">       Pthread_cond_signal(&amp;cond);           <span class="comment">// c5 </span></span><br><span class="line">       Pthread_mutex_unlock(&amp;mutex);         <span class="comment">// c6 </span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当只有一个生产者和一个消费者时，方案 1 的代码能够正常运行。但如果有超过一个线程（例如两个消费者），这个方案会有两个严重的问题。</p>
<h3 id="问题与解决方法"><a href="#问题与解决方法" class="headerlink" title="问题与解决方法"></a>问题与解决方法</h3><p>Mesa 语义（Mesa semantic）：共享变量状态与预期不符</p>
<p><strong>第一个问题与线程等待之前的 if 语句有关</strong>。假设有两个消费者（Tc1和Tc2），一个生产者（Tp）。首先，一个消费者（Tc1）先开始执行，它获得锁（c1），检查缓冲区是否可以消费（c2），然后等待（c3）（这会释放锁）。接着生产者（Tp）运行。它获取锁（p1），检查缓冲区是否满（p2），发现没满就给缓冲区加入一个数字（p4）。然后生产者发出信号，说缓冲区已满（p5），并且唤醒第一个消费者（Tc1）不再睡在条件变量上，Tc1 进入就绪队列。Tc1 现在<strong>可以运行（但还未运行）</strong>。生产者继续执行，直到发现缓冲区满后睡眠（p6,p1-p3）。这时问题发生了：<strong>另一个消费者（Tc2）抢先执行，消费了缓冲区中的值</strong>（c1,c2,c4,c5,c6，跳过了c3的等待，因为缓冲区是满的）。现在假设 Tc1 运行，在从 wait 返回之前，它获取了锁，然后返回。然后它调用了get() (p4)，但缓冲区已无法消费。（已经被 Tc2 消费）<strong>显然，我们应该设法阻止Tc1去消费，因为Tc2插进来，消费了缓冲区中之前生产的一个值。</strong></p>
<p>解决方法：把if语句改为while。当消费者Tc1被唤醒后，立刻再次检查共享变量（c2）。如果缓冲区此时为空，消费者就会回去继续睡眠（c3）。生产者中相应的if也改为while（p2）。由于Mesa语义，我们要记住一条关于条件变量的简单规则：总是使用while循环（always use while loop）。</p>
<p>问题2</p>
<p>唤醒的线程是不确定的</p>
<p>假设有两个消费者（Tc1和Tc2），一个生产者（Tp）。假设两个消费者（Tc1和Tc2）先运行，都睡眠了（c3）。生产者开始运行，在缓冲区放入一个值，唤醒了一个消费者（假定是Tc1），并开始睡眠。现在是一个消费者马上要运行（Tc1），而两个线程（消费者Tc2和生产者Tp）都等待在同一个条件变量上。</p>
<p>消费者Tc1醒过来并从wait()调用返回（c3），重新检查条件（c2），发现缓冲区是满的，消费了这个值（c4）。这个消费者然后在该条件上发信号（c5），唤醒一个在睡眠的线程。但是，<strong>应该唤醒哪个线程</strong>呢？因为消费者已经清空了缓冲区，很显然，应该唤醒生产者。但是，如果它唤醒了Tc2（这绝对是可能的，取决于等待队列是如何管理的），问题就出现了。具体来说，消费者Tc2会醒过来，发现队列为空（c2），又继续回去睡眠（c3）。生产者Tp刚才在缓冲区中放了一个值，现在在睡眠。另一个消费者线程Tc1也回去睡眠了。3个线程都会陷入持续的睡眠</p>
<p>解决方法：使用两个条件变量，在系统状态改变时，哪类线程应该唤醒</p>
<p>在这离，两个条件变量共享一个状态变量，因为与状态变量的某个值唯一对应</p>
<h2 id="实现方案-2"><a href="#实现方案-2" class="headerlink" title="实现方案 2"></a>实现方案 2</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">cond_t</span>  empty, fill; </span><br><span class="line"><span class="type">mutex_t</span> mutex; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); </span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">1</span>) </span><br><span class="line">            Pthread_cond_wait(&amp;empty,  &amp;mutex); </span><br><span class="line">        put(i); </span><br><span class="line">        Pthread_cond_signal(&amp;fill); </span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">   <span class="type">int</span> i; </span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">       Pthread_mutex_lock(&amp;mutex); </span><br><span class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>) </span><br><span class="line">           Pthread_cond_wait(&amp;fill, &amp;mutex); </span><br><span class="line">       <span class="type">int</span> tmp = get(); </span><br><span class="line">       Pthread_cond_signal(&amp;empty); </span><br><span class="line">       Pthread_mutex_unlock(&amp;mutex); </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，生产者线程等待条件变量empty，发信号给变量fill。相应地，消费者<br>线程等待fill，发信号给empty。这样做，从设计上避免了上述第二个问题：<strong>消费者再也不<br>**</strong>会唤醒消费者，生产者也不会唤醒生产者。**</p>
<p>与同步无关的问题3</p>
<p>共享变量是缓存时，空间过小导致频繁切换进程，</p>
<h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>我们最后的修改是提高并发和效率。具体来说，增加更多缓冲区槽位，这样在睡眠之前，可以生产多个值。同样，睡眠之前可以消费多个值。单个生产者和消费者时，这种方案因为上下文切换少，提高了效率。多个生产者和消费者时，它支持并发生产和消费。</p>
<p>第一处修改是缓冲区结构本身，以及对应的put()和get()方法（见图30.9）。我们还稍稍修改了生产者和消费者的检查条件，以便决定是否要睡眠。图30.10 展示了最终的等待和信号逻辑。生产者只有在缓冲区满了的时候才会睡眠（p2），消费者也只有在队列为空的时候睡眠（c2）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> buffer[MAX]; </span><br><span class="line"><span class="type">int</span> fill  = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> use   = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span> &#123; </span><br><span class="line">    buffer[fill] = value; </span><br><span class="line">    fill = (fill + <span class="number">1</span>) % MAX; </span><br><span class="line">    count++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="type">int</span> tmp = buffer[use]; </span><br><span class="line">    use = (use + <span class="number">1</span>) % MAX; </span><br><span class="line">    count--; </span><br><span class="line">    <span class="keyword">return</span> tmp; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">cond_t</span> empty, fill; </span><br><span class="line"><span class="type">mutex_t</span> mutex; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">        Pthread_mutex_lock(&amp;mutex);              <span class="comment">// p1 </span></span><br><span class="line">        <span class="keyword">while</span> (count == MAX)                     <span class="comment">// p2 </span></span><br><span class="line">            Pthread_cond_wait(&amp;empty, &amp;mutex);   <span class="comment">// p3 </span></span><br><span class="line">        put(i);                                  <span class="comment">// p4 </span></span><br><span class="line">        Pthread_cond_signal(&amp;fill);              <span class="comment">// p5 </span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex);            <span class="comment">// p6 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">        Pthread_mutex_lock(&amp;mutex);            <span class="comment">// c1 </span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)                      <span class="comment">// c2 </span></span><br><span class="line">            Pthread_cond_wait(&amp;fill, &amp;mutex);   <span class="comment">// c3 </span></span><br><span class="line">        <span class="type">int</span> tmp = get();                        <span class="comment">// c4 </span></span><br><span class="line">        Pthread_cond_signal(&amp;empty);           <span class="comment">// c5 </span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex);          <span class="comment">// c6 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>创建数据结构类</title>
    <url>/2022/04/14/Create-Data-Structure-class/</url>
    <content><![CDATA[<p>LRU、LFU、前缀树等数据结构类的创建</p>
<span id="more"></span>
<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>这里讨论作为 LRU 的内部类时，双向链表的写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123; <span class="comment">// 双向链表的节点类</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    DLinkedNode prev;</span><br><span class="line">    DLinkedNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _value)</span> &#123; value = _value;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkedList</span>&#123; <span class="comment">// 非循环的双向链表类</span></span><br><span class="line">	<span class="comment">// 双向链表的两个哑结点，便于双向链表节点的添加和删除</span></span><br><span class="line">    <span class="comment">// 非循环的双向链表是具有头节点和尾节点的</span></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> DLinkedList&#123;</span><br><span class="line">        <span class="comment">// 初始化伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail; <span class="comment">// head 的 prev 和 tail 的 next 不相连（不循环）</span></span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 以下操作默认 node 不为 null</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 将 node 添加（添加而非移动）到双向链表表头（哑结点 head 后面）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 从两个方向改变链表的连接</span></span><br><span class="line">    	node.next = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line"></span><br><span class="line">        node.next.prev = node;</span><br><span class="line">        node.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 将 node 移除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 从两个方向改变链表的连接</span></span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到表头等价于删除节点，再把节点插入到表头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 移除实际的尾节点 tail.prev，这里返回值是节点，因为 LRU 的哈希表需要这个节点的信息</span></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><p>LRU 基于链表实现，需要保证链表尾部是最近最少使用的元素：</p>
<ul>
<li>插入元素时，插入到表头</li>
<li>查找元素时，移动到表头</li>
</ul>
<p>从而，删除元素时，直接删除链表尾部节点即可。</p>
<ul>
<li>为了便于插入/移动元素到表头，使用双向链表</li>
<li>为了加快查找操作的速度，额外用 O(N) 空间，使用哈希表存储数据。</li>
</ul>
<h2 id="自定义双向链表结点类"><a href="#自定义双向链表结点类" class="headerlink" title="自定义双向链表结点类"></a>自定义双向链表结点类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123; <span class="comment">// 双向链表的节点类</span></span><br><span class="line">        <span class="type">int</span> key; <span class="comment">// 新增了 key 属性，表示该节点的索引，作为hashmap 的键</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> DLinkedNode head, tail;  <span class="comment">// LRU 私有变量，用来维护内部的双向链表</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// LRU 私有变量，用来维护内部的哈希表，作为缓存</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">	<span class="comment">// 缓存大小有限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity; <span class="comment">// 容量，即size上限</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化双向链表哑结点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  key 存在，需要移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    	<span class="comment">// 先检查键值对是否存在</span></span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加进哈希表和双向链表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 添加之后（而非之前，因为删除的是尾部），需要检查空间大小</span></span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点和该节点在哈希表中的对应项</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line"></span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，需要修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> </span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="基于-LinkedList"><a href="#基于-LinkedList" class="headerlink" title="基于 LinkedList"></a>基于 LinkedList</h2><p>需要定义链表的结点类，结点类只需要定义 key 和 value，不需要定义 prev 和 next</p>
<p>逻辑是一致的，但是使用 Java 的 LinkedList 会带来很多额外开销，因为 LinkedList 内部有比简单双向链表内容更多更复杂的实现，需要维护的代价也更大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123; </span><br><span class="line">        <span class="type">int</span> key; </span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Node&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LRU 私有变量，用来维护内部的哈希表，作为缓存</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">    <span class="comment">// 缓存大小有限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity; <span class="comment">// 容量，即size上限</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  key 存在，需要移到头部</span></span><br><span class="line">        list.remove(node);</span><br><span class="line">        list.offerFirst(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 先检查键值对是否存在</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加进哈希表和双向链表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            list.offerFirst(newNode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加之后（而非之前，因为删除的是尾部），需要检查空间大小</span></span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点和该节点在哈希表中的对应项</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> list.pollLast();</span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line"></span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，需要修改 value，并移到头部</span></span><br><span class="line">            <span class="comment">// 不需要新建一个结点</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            list.remove(node);</span><br><span class="line">            list.offerFirst(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h1><p>实现 LFUCache 类：</p>
<ul>
<li>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象</li>
<li>int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。</li>
<li>void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。（一般的 LFU 算法任意选择一个删除）</li>
</ul>
<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个使用计数器 。使用计数最小的键是最久未使用的键。</p>
<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p>
<p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<h2 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="数据结构分析"></a>数据结构分析</h2><p>每个不同的频数都对应着一组数据，由于要求在频数相同的时候，能够去除 最近最久未使用 的键，因此，每个不同的频数应该对应一个双向链表。</p>
<p>与 LRU 不同的地方在于，当频数上升，remove后不是到原链表头部，而是晋升到频数+1的链表头部，在此过程中，需要维护 minfreq，维护的方法与证明方式见注释。</p>
<p>对于一个 (key, value)，它会被分配到某个频数对应的 LRU 缓存中。使用哈希表记录<strong>所有节点</strong>，从而可以一次性找到键值对。</p>
<h2 id="基于-LinkedList-1"><a href="#基于-LinkedList-1" class="headerlink" title="基于 LinkedList"></a>基于 LinkedList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> minfreq, capacity;</span><br><span class="line">    Map&lt;Integer, Node&gt; key_table; <span class="comment">// 哈希表记录所有节点</span></span><br><span class="line">    Map&lt;Integer, LinkedList&lt;Node&gt;&gt; freq_table; <span class="comment">// 哈希表记录所有（频数，节点集合）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.minfreq = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        key_table = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Node&gt;();;</span><br><span class="line">        freq_table = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, LinkedList&lt;Node&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span> || !key_table.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> key_table.get(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> node.val, freq = node.freq;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 node 从当前频数的双向链表中删除，它将被插入到 freq+1 频数的双向链表中</span></span><br><span class="line">        freq_table.get(freq).remove(node);</span><br><span class="line">        <span class="comment">// 如果当前链表为空，在 freq_table 中删除对应的键值对，且更新 minFreq</span></span><br><span class="line">        <span class="comment">// minfreq 更新方法的正确性可以用归纳法证明</span></span><br><span class="line">        <span class="keyword">if</span> (freq_table.get(freq).size() == <span class="number">0</span>) &#123;</span><br><span class="line">            freq_table.remove(freq); <span class="comment">// 需要删除</span></span><br><span class="line">            <span class="keyword">if</span> (minfreq == freq) &#123;</span><br><span class="line">                minfreq += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入到 freq + 1 的双向链表中</span></span><br><span class="line">        LinkedList&lt;Node&gt; list = freq_table.getOrDefault(freq + <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;());</span><br><span class="line">        node.freq = node.freq+<span class="number">1</span>; <span class="comment">// 注意结点移动后，结点的频数属性要变更</span></span><br><span class="line">        list.offerFirst(node);</span><br><span class="line">        <span class="comment">// 更新 freq_table，而 key_table 不需要改变，因为我们只是改变了结点的属性，而不是重新创建节点</span></span><br><span class="line">        freq_table.put(freq + <span class="number">1</span>, list);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是新节点</span></span><br><span class="line">        <span class="keyword">if</span> (!key_table.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 添加前发现缓存 key_table 已满，需要进行删除操作</span></span><br><span class="line">            <span class="comment">// 也可以像 LRU 一样，先添加，在判断是不是超过 capacity</span></span><br><span class="line">            <span class="keyword">if</span> (key_table.size() == capacity) &#123;</span><br><span class="line">                <span class="comment">// LRU 结构的删除操作，从缓存（HashMap）和链表中都删除</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> freq_table.get(minfreq).pollLast();</span><br><span class="line">                key_table.remove(node.key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (freq_table.get(minfreq).size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    freq_table.remove(minfreq); <span class="comment">// 直接删除，不必在此更新 minfreq</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;	</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 新节点对应频数为 1，更新 minfreq</span></span><br><span class="line">            LinkedList&lt;Node&gt; list = freq_table.getOrDefault(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;());</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value, <span class="number">1</span>);</span><br><span class="line">            list.offerFirst(newNode);</span><br><span class="line">            freq_table.put(<span class="number">1</span>, list);</span><br><span class="line">            key_table.put(key, newNode);</span><br><span class="line">            </span><br><span class="line">            minfreq = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> key_table.get(key);</span><br><span class="line">            <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> node.freq;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 与 get 操作基本一致，但是注意需要更新缓存的值</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将 node 从当前频数的双向链表中删除，它将被插入到 freq+1 频数的双向链表中</span></span><br><span class="line">            freq_table.get(freq).remove(node);</span><br><span class="line">            <span class="keyword">if</span> (freq_table.get(freq).size() == <span class="number">0</span>) &#123;</span><br><span class="line">                freq_table.remove(freq);</span><br><span class="line">                <span class="keyword">if</span> (minfreq == freq) &#123;</span><br><span class="line">                    minfreq += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LinkedList&lt;Node&gt; list = freq_table.getOrDefault(freq + <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;());</span><br><span class="line">            node.val = value;</span><br><span class="line">            node.freq = node.freq+<span class="number">1</span>;</span><br><span class="line">            list.offerFirst(node);</span><br><span class="line">            freq_table.put(freq + <span class="number">1</span>, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> key, val, freq;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> key, <span class="type">int</span> val, <span class="type">int</span> freq) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.freq = freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>类似 LRU，LFU 基于 LInkedList 的实现方法需要定义链表的结点类，结点类需要定义 key、value 和 freq，不需要定义 prev 和 next</p>
<p>同样地，使用 Java 的 LinkedList 会带来很多额外开销，不如自定义简单的双向链表类。</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="顶端迭代器"><a href="#顶端迭代器" class="headerlink" title="顶端迭代器"></a>顶端迭代器</h2><p>实现 PeekingIterator 类：</p>
<ul>
<li>PeekingIterator(Iterator<int> nums) 使用指定整数迭代器 nums 初始化迭代器。</int></li>
<li>int next() 返回数组中的下一个元素，并将指针移动到下个元素处。</li>
<li>bool hasNext() 如果数组中存在下一个元素，返回 true ；否则，返回 false 。</li>
<li>int peek() 返回数组中的下一个元素，但 <strong>不</strong> 移动指针。</li>
</ul>
<p><strong>基本操作</strong></p>
<p>每种语言可能有不同的构造函数和迭代器 Iterator，但均支持 int next() 和 boolean hasNext() 函数。</p>
<p>Java 的 Iterator 接口支持 next 和 hasNext 操作，但是不支持 peek 操作。</p>
<ul>
<li>hasNext()：如果存在下一元素，返回 True，否则返回 False。</li>
<li>next()：返回下一元素（当不存在下一元素时，返回 null）。注意，在第一次调用 next() 时，它返回序列的第一个元素</li>
</ul>
<p><strong>实现方法</strong></p>
<p>维护 nextElement，表示当前 PeekingIterator 所指向位置的下一个元素的值。</p>
<p>注意在构造函数中，调用了 nextElement = iterator.next(); 这样一来，开始的时候，PeekingIterator 指向位置 -1，而其内部的 iterator，指向位置 0，并且 nextElement 为位置 0 的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PeekingIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Integer&gt; iterator;</span><br><span class="line">    <span class="keyword">private</span> Integer nextElement;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PeekingIterator</span><span class="params">(Iterator&lt;Integer&gt; iterator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.iterator = iterator;</span><br><span class="line">        nextElement = iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextElement;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ret</span> <span class="operator">=</span> nextElement;</span><br><span class="line">        nextElement = iterator.hasNext() ? iterator.next() : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextElement != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让 PeekingIterator 支持任意类型：只需要将 Integer 修改成代指泛型的标识即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PeekingIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    Iterator&lt;E&gt; iter;</span><br><span class="line">    E next;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">PeekingIterator</span><span class="params">(Iterator&lt;E&gt; iterator)</span> &#123;</span><br><span class="line">        iter = iterator;</span><br><span class="line">        <span class="keyword">if</span> (iter.hasNext()) next = iter.next();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">ans</span> <span class="operator">=</span> next;</span><br><span class="line">        next = iter.hasNext() ? iter.next() : <span class="literal">null</span>;</span><br><span class="line">	    <span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="前缀树（Trie）"><a href="#前缀树（Trie）" class="headerlink" title="前缀树（Trie）"></a>前缀树（Trie）</h1><p>前缀树（Trie），因其常用于字符串处理，因此也叫做字典树。</p>
<p>作用：利用公共前缀减少查询时间。</p>
<p>设某一类数据能用一个定长连续序列描述，例如字符串、整数等，以下设计的是存储字符串的前缀树，稍加改造即可适应其他数据类型。</p>
<h2 id="前缀树节点"><a href="#前缀树节点" class="headerlink" title="前缀树节点"></a>前缀树节点</h2><p>设字符取值集合为 valSet，定义前缀树的节点 Trie 包含两个属性：</p>
<ol>
<li><p><strong>指向子节点的指针数组 children</strong>，数组长度为字符串所有可能的取值构成的集合的长度。</p>
<p> children[i] 不为 null 表示存在连接到值为 valSet[0] 的边，children[i] = null 表示不存在这样的边</p>
<p> 例如 children[0] 可对应小写字母 a，并且它存储着一个指向子节点的指针。</p>
</li>
<li><p><strong>布尔字段 isEnd</strong>，表示该节点是否为字符串的结尾。</p>
<p> 也可以用 String 类型存储，当属性值为 null，表示不是字符串结尾。当属性值不为 null，即该节点为字符串结尾，并且我们能直接获取这个字符串，而不需要在 查找前缀 过程中记录节点。</p>
<p> 内部节点和叶子节点都可能是字符串的结尾。</p>
</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>设字符取值集合为 valSet = [‘a’, …, ‘z’]，基于层序遍历的方法来操作前缀树。</p>
<p><strong>查找前缀</strong></p>
<p>从字典树的根开始，查找前缀。设当前字符 c 的位置对应于字典树的节点 n，若：</p>
<ul>
<li>children[c - ‘a’] = null，说明字典树中不包含该前缀，返回空指针。</li>
<li>children[c - ‘a’] 非空，根据它的指向移动到子节点，继续处理下一个字符</li>
</ul>
<p>若最终到的节点非空，说明前缀存在。<strong>若查找的是字符串而非前缀，判断该节点是否为字符串的结尾即可</strong></p>
<p><strong>插入字符串</strong></p>
<p>从字典树的根开始，插入字符串。设当前字符  c 的位置对应于字典树的节点 n，若：</p>
<ul>
<li>children[c - ‘a’]=null，表示节点 n 未能取值为字符c，因此需要初始化 children[c - ‘a’] 令其非空并指向新创建的一个树节点。</li>
<li>children[c - ‘a’]非空，根据它的指向移动到子节点，继续处理下一个字符</li>
</ul>
<p>例如，对于 word = ”abc”，生成的是这样一个分支：</p>
<p><img src="/2022/04/14/Create-Data-Structure-class/image-20220414154341091.png" alt="image-20220414154341091"></p>
<p>其中，b.children[‘c’ - ‘a’] = new Trie();</p>
<h2 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>; <span class="comment">// root节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>; <span class="comment">// 最后一个字符对应的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd; <span class="comment">// 必须到叶子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="211-添加与搜索单词"><a href="#211-添加与搜索单词" class="headerlink" title="211. 添加与搜索单词"></a>211. 添加与搜索单词</h3><p>实现词典类 WordDictionary ：</p>
<ul>
<li>WordDictionary() 初始化词典对象</li>
<li>void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配</li>
<li>bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 ‘.’ ，每个 . 都可以表示任何一个字母。</li>
</ul>
<p>由于 . 可替代任意字母，原始的前缀树代码的 search() 方法不能直接用。</p>
<p>应该在 WordDictionary 类写一个新的查找函数，而非直接修改前缀树类的 search()：</p>
<ul>
<li>需要访问 Trie 类的私有成员 children 和 isEnd，故在 Trie 类添加 getchildren()</li>
<li>当遇到字符 . 时，需要遍历所有的分支并判断结果，应该把基于 bfs 的 search() 方法改为基于 dfs 的 search() 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordDictionary</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        root.insert(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>, word);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(Trie node, <span class="type">int</span> i, String word)</span> &#123; <span class="comment">// 搜索图上每个节点由两个属性确定</span></span><br><span class="line">        <span class="keyword">if</span>(i == word.length()) </span><br><span class="line">            <span class="keyword">return</span> node.isEnd();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">        Trie[] chi = node.get_children();</span><br><span class="line">        <span class="keyword">if</span>(Character.isLetter(ch))&#123;</span><br><span class="line">            <span class="type">Trie</span> <span class="variable">child</span> <span class="operator">=</span> chi[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(child != <span class="literal">null</span> &amp;&amp; dfs(child, i+<span class="number">1</span>, word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;++j)&#123;</span><br><span class="line">                <span class="type">Trie</span> <span class="variable">child</span> <span class="operator">=</span> chi[j];</span><br><span class="line">                <span class="keyword">if</span>(child != <span class="literal">null</span> &amp;&amp; dfs(child, i+<span class="number">1</span>, word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Trie[] get_children()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj.addWord(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="421-数组中两个数的最大异或值"><a href="#421-数组中两个数的最大异或值" class="headerlink" title="421. 数组中两个数的最大异或值"></a>421. 数组中两个数的最大异或值</h3><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>
<p><img src="/2022/04/14/Create-Data-Structure-class/image-20220414162454153.png" alt="image-20220414162454153" style="zoom:130%;"></p>
<h4 id="用前缀树存储自然数的集合"><a href="#用前缀树存储自然数的集合" class="headerlink" title="用前缀树存储自然数的集合"></a>用前缀树存储自然数的集合</h4><p>设自然数集合 nums，满足 0 &lt;= nums[i] &lt;= 2^31-1，用前缀树存储 nums</p>
<p>实际上是二叉树，前缀树的 children 大小为 2. </p>
<p>32 位有符号整数，实际有效的数位不含符号位，只有 31 位。任意一个数都有 31 位，因此层数为固定的 31 层，不需要 isEnd 属性。</p>
<p>类似地，按照层序遍历的方法插入和查找元素。值得注意的是，为了求最大异或值，这里是把高二进制位低层（即离 root 近的层）。</p>
<p><strong>查找操作的时间复杂度是 O(31)，常数时间</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="comment">// 最高位的非符号位二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HIGH_BIT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点，右子树指向表示 1 的子节点</span></span><br><span class="line">    <span class="keyword">private</span> Trie left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        left = <span class="literal">null</span>;</span><br><span class="line">        right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur.left = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur.right = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找数组中两个数的最大异或值"><a href="#查找数组中两个数的最大异或值" class="headerlink" title="查找数组中两个数的最大异或值"></a>查找数组中两个数的最大异或值</h4><p>对于 nums[i]，只需要查看它前面的所有数字与它构成的二元组，就可以遍历所有的二元组。</p>
<p>而在查找 nums[i] 与它前面的所有数字构成二元组的最大异或值时，通过前缀树，可以不需要遍历一次得到结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> Trie root;</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HIGH_BIT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">	</span><br><span class="line">    Solution() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        root.insert(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximumXOR</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = Math.max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> num)</span> &#123; <span class="comment">// 查找 num 与之前的元素构成的所有二元组中，能得到的最大异或值</span></span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.get_right() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.get_right();</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左节点必定非空</span></span><br><span class="line">                    cur = cur.get_left();</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.get_left() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.get_left();</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.get_right();</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="comment">// 最高位的非符号位二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HIGH_BIT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点，右子树指向表示 1 的子节点</span></span><br><span class="line">    <span class="keyword">private</span> Trie left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        left = <span class="literal">null</span>;</span><br><span class="line">        right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> Trie <span class="title function_">get_left</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Trie <span class="title function_">get_right</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur.left = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur.right = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>并查集 DSU</title>
    <url>/2022/04/25/DSU/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>一个<strong>不相交集合数据结构</strong>（disjoint-set data structure）或者说<strong>并查集</strong>（disjoint-set union，DSU）维护了一个不相交动态集的集合 ${S<em>{1},…,S</em>{k}}$。</p>
<p>不相交指的是集合中的每个元素 $S_{i}$ 是互不相交的集合，动态指的是部分集合可以根据某些规则合并为一个新的集合，新的集合在这个规则下与其他原有的集合依旧满足不相交的原则。</p>
<span id="more"></span>
<p>我们用一个<strong>代表</strong>（representative）来标识每个集合 $S_{i}$，它是这个集合的某个成员。</p>
<p>设 x 作为一个代表，我们希望支持以下三个操作：</p>
<ul>
<li>MAKE-SET(x)：建立一个新的集合，它的唯一成员是 x，x 不会出现在别的某个集合中。</li>
<li>UNION(x, y)：将包含 x 和 y 的两个动态集合合并成为一个新的集合，满足什么样的条件能够合并需要根据具体情况具体分析。经常把其中一个集合的元素并入另一个集合中，避免 x 或者 y 仍然在原来的并查集当中，来代替删除操作。</li>
<li>FIND-SET(x)：返回一个指针，这个指针指向包含 x 的集合。</li>
</ul>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>每个集合 </strong>$S_{i}$ 用一个链表来表示，链表包含 head 和 tail，链表的 head 为该集合的代表。链表中的每个对象包含 head 属性、next 属性和 val 属性。如下图所示：</p>
<p><img src="/2022/04/25/DSU/image-20220425195432759.png" alt></p>
<p>用这种链表表示，MAKE-SET 操作复杂度为 O(1)。对于 FIND-SET(x) 操作，可以根据 x 的 head 属性直接找到链表的 head，因此复杂度也是 O(1)。对于 UNION(x, y) 操作，可以将 x 代表的链表连接到 y 后面（即令 y 代表的链表尾节点的 next 为 x），并且更改 x 所有节点的 head 属性。需要遍历链表 y 找到其尾节点，复杂度与 y 的链表大小呈线性关系。</p>
<p>在最坏情况下，执行上述 UNION 操作的复杂度近似 O(n)，即并查集只包含 x 和 y 两个链表，而 x 只含一个对象时，把 y 合并到 x 上的时间复杂度。因此，如果<strong>为每个链表加入长度属性</strong>，在合并时，就可以<strong>把短的链表并入长的链表</strong>，从而减小复杂度。</p>
<h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p>可以使用有根树来表示集合，树中的每个结点表示一个成员，每棵树表示一个集合，每颗树的<strong>根为这个集合的代表</strong>。这样的多颗有根树构成了<strong>不相交集合森林</strong>（disjoint-set forest），如下图所示：</p>
<p><img src="/2022/04/25/DSU/image-20220425195847046.png" alt></p>
<p>对于图示的树，FIND-SET(x) 操作将通过沿着指向父结点的指针找到根，在寻找根的过程所访问到的结点构成了<strong>查找路径</strong>(find path)。UNION 操作可以直接让一棵树的根指向另一颗树的根。可见，用森林存储并查集，<strong>主要的损耗来自于 FIND-SET 操作</strong>。</p>
<p>值得注意的一个问题是，如果我们手上只有上图所示的树，那么如何获取 FIND-SET 的输入 x？毕竟我们只有根结点是直接可访问的。一种解决方法是：<strong>用数组存储树上的所有结点</strong>，并且通常而言，我们的数据一开始就是用数组存放的。用这样一来，我们可以<strong>用 O(1) 的时间访问树上的任意结点</strong>。</p>
<p>为了改进 FIND-SET 操作的复杂度，可以使用以下两种启发式策略：</p>
<p>一、路径压缩（path compression）：让树的所有结点都指向根（与链表类似），父结点只有根（与链表的每个结点还可指向下一个元素不同）。</p>
<p>二、按秩合并（union by rank）：类似于链表的按照长度合并，UNION操作将使具有较少结点的树的根指向具有较多结点的树的根。之所以这样做能优化 FIND-SET 操作（在不使用路径压缩的时候也能优化），是因为合并后的树在执行 FIND-SET 操作时，有较多结点的那颗树中，每个结点到新根的路径长度不会加一。在具体实施时，并不显式地记录树的大小（结点数量），而是维护树的属性：<strong>秩，它表示树的最大高度</strong>。使用按秩合并的 UNION 操作中，我们可以让具有小秩的树根指向具有大秩的树根。</p>
<p>使用上述两种启发式策略实现不相交集合森林的伪代码如下，每个结点具有父结点属性，而根节点还额外具有秩属性。</p>
<p>当 MAKE-SET 创建一个单元素集合时，这个树上的单结点的父结点是它本身，秩为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAKE-SET(x)&#123;</span><br><span class="line">	x.p = x;</span><br><span class="line">	x.rank = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带有路径压缩的 FIND-SET 操作可以通过递归来完成：如果当前结点 x不是根结点，便递归调用其父结点的 FIND-SET，这一轮递归将沿着查找路径找到根结点。递归在找到根节点时中止，然后进行递归回溯，这个过程将沿着查找路径回退更新路径上的所有结点，使其父结点被更新为根结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FIND-SET(x)&#123;</span><br><span class="line">	if(x != x.p) // x 不是根节点</span><br><span class="line">		x.p = FIND-SET(x.p);</span><br><span class="line">	return x.p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于某个未经过路径压缩的树，如下图：</p>
<p><img src="/2022/04/25/DSU/image-20220425200400656.png" alt></p>
<p>当对某个结点第一次调用 FIND-SET 时，将产生递归操作，返回值为根节点。之后如果继续对这个结点，或者是这个结点查找路径上的结点调用 FIND-SET，则可以直接找到根节点（实际上会额外调用一次 FIND-SET(根节点)）。</p>
<p>使用按秩合并的 UNION 操作有两种情况，如果两颗树的秩不同，就让大秩的树根成为小秩的树根的父节点，大秩的树根作为新树的根节点，其秩不变。如果两颗树的秩相同，任选一个树根作为新树的根，其秩加1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNION(x, y)&#123;</span><br><span class="line">	LINK(FIND-SET(x), FIND-SET(y))</span><br><span class="line">	LINK(x, y)</span><br><span class="line">	</span><br><span class="line">	if(x.rank &gt; y.rank)</span><br><span class="line">		y.p = x;</span><br><span class="line">    else </span><br><span class="line">    	x.p = y;</span><br><span class="line">	</span><br><span class="line">	if(x.rank == y.rank)</span><br><span class="line">		++y.rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/04/05/DesignMode/</url>
    <content><![CDATA[<p>设计模式<br><span id="more"></span></p>
<h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><p>目的：确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<p><strong>应用场景</strong>举例：</p>
<ol>
<li><p>一个班级只有一个班主任。</p>
</li>
<li><p>在操作一个文件的时候，出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</p>
</li>
</ol>
<h2 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p>
<p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p>
<p><img src="/2022/04/05/DesignMode/1647569125447-5b964ad9-e0d0-4a0e-a6d7-56992f4ae678.png" alt="单例模式类图" style="zoom:80%;"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>懒汉式，需要的时候才会触发初始化实例对象。而饿汉式正好相反，Singleton 类加载的时候，就会创建初始化单例对象。</p>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p>
<p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (uniqueInstance == null) ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 uniqueInstance = new Singleton(); 语句，这将导致多次实例化uniqueInstance。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单锁检查-线程安全"><a href="#单锁检查-线程安全" class="headerlink" title="单锁检查-线程安全"></a>单锁检查-线程安全</h4><p><strong>对 getUniqueInstance() 方法加锁</strong>，那么在一个时间点只能有一个线程能够进入该方法，从而避免了多次 实例化uniqueInstance。</p>
<p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双重校验锁（Double-Check-Lock-DCL）-线程安全"><a href="#双重校验锁（Double-Check-Lock-DCL）-线程安全" class="headerlink" title="双重校验锁（Double Check Lock, DCL）-线程安全"></a>双重校验锁（Double Check Lock, DCL）-线程安全</h4><p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。</p>
<p>双重校验锁先判断 uniqueInstance 是否已经被实例化，<strong>如果没有被实例化，那么才对实例化语句进行加锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 uniqueInstance = new Singleton(); 这条语句，只是先后的问题，那么就会进行两次实例化。</p>
<p>因此必须使用<strong>双重校验锁，也就是需要使用两个 if 语句进行较验</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>uniqueInstance 采用 volatile 关键字修饰</strong>也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><h4 id="直接实例化-线程安全"><a href="#直接实例化-线程安全" class="headerlink" title="直接实例化-线程安全"></a>直接实例化-线程安全</h4><p>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。</p>
<p>private static Singleton uniqueInstance = new Singleton(); </p>
<p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p>
<h4 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h4><p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例。</p>
<p>假设有多个线程调用 <code>getUniqueInstance()</code>，由 JVM 保证加载  SingletonHolder 类的线程安全性。SingletonHolder 类 只会被加载一次，生成唯一一份静态变量。</p>
<blockquote>
<p>INSTANCE 是静态变量，从类加载阶段中的初始化阶段来看，虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</clinit></clinit></clinit></p>
<p>需要注意的是，其他线程虽然会被阻塞，但如果执行 <clinit>() 方法后，其他线程唤醒之后不会再次进入<clinit>() 方法。同一个加载器下，一个类型只会初始化一次。（这与一般的 Synchronized 方法有显著区别）</clinit></clinit></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与饿汉式直接实例化相比较，实现了延迟初始化，同样是线程安全的。</p>
<h4 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String objName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getObjName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> objName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObjName</span><span class="params">(String objName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.objName = objName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单例测试</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">firstSingleton</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        firstSingleton.setObjName(<span class="string">&quot;firstName&quot;</span>);</span><br><span class="line">        System.out.println(firstSingleton.getObjName());</span><br><span class="line">        </span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">secondSingleton</span> <span class="operator">=</span> Singleton.INSTANCE; <span class="comment">// 获得同一个实例</span></span><br><span class="line">        secondSingleton.setObjName(<span class="string">&quot;secondName&quot;</span>); <span class="comment">// 改变实例</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(firstSingleton.getObjName());</span><br><span class="line">        System.out.println(secondSingleton.getObjName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取实例测试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Singleton[] enumConstants = Singleton.class.getEnumConstants();</span><br><span class="line">            <span class="keyword">for</span> (Singleton enumConstant : enumConstants) &#123;</span><br><span class="line">                System.out.println(enumConstant.getObjName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">firstName</span><br><span class="line">secondName</span><br><span class="line">secondName</span><br><span class="line">secondName</span><br></pre></td></tr></table></figure>
<p><strong>枚举实现可以防止反射攻击</strong>。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p>
<p>也因为枚举实现可以防止反射攻击，所有该实现在多次序列化和序列化之后，不会得到多个实例。</p>
<h2 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h2><p>有哪些方式可以破坏单例模式呢？主要但是不限于以下几种：</p>
<ul>
<li>没有将构造器私有化，可以直接调用。</li>
<li>反射调用构造器</li>
<li>序列化与反序列化</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>除了枚举实现之外，单例模式的其他实现方法，都可以通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取Singleton字节码对象</span></span><br><span class="line">        Class&lt;Singleton&gt; singletonClass = Singleton.class;</span><br><span class="line">        <span class="comment">//获取无参构造方法</span></span><br><span class="line">        Constructor&lt;Singleton&gt; declaredConstructor = singletonClass.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//将私有构造函数的访问级别设置为 public</span></span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> (Singleton) declaredConstructor.newInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> (Singleton) declaredConstructor.newInstance();</span><br><span class="line">        <span class="comment">//通过hashCode查看是否是同一个对象</span></span><br><span class="line">        System.out.println(singleton.hashCode());</span><br><span class="line">        System.out.println(singleton1.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="comment">//只会初始化一次</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton= <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给外界提供一个方法用于访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="避免反射破坏单例模式"><a href="#避免反射破坏单例模式" class="headerlink" title="避免反射破坏单例模式"></a>避免反射破坏单例模式</h4><p>防止多次实例化，也就是调用一次之后，再调用就报错，抛出异常。（通过反射调用私有构造器肯定是在之后？懒汉式不一定吧？）</p>
<p>我们的单例模式可以写成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Don&#x27;t use this method&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下,反射调用的时候抛出异常了，说明能够有效阻止反射调用破坏单例的模式：</p>
<p>Exception in thread “main” java.lang.reflect.InvocationTargetException</p>
<p>如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法，也是为了防止多次实例化。</p>
<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>很多对象都是必须实现序列化接口的，但是实现了序列化接口之后，可能无法保证单例。这是因为<strong>序列化之后，再反序列化回来</strong>，对象的内容是一样的，但是对象却不是同一个对象了。</p>
<p>普通的 Java 类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。如果不希望它进行反射怎么办？根据反序列化的源码，如果有实现<code>readResolve()</code>，那就直接调用该方法返回结果，而不是返回反射调用之后的结果。</p>
<p>因此，可以重写 readResolve()，综合得到改造后的单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>,Cloneable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Don&#x27;t use this method&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 阻止反序列反射生成对象</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>I/O 模型</title>
    <url>/2022/04/07/I-O-model/</url>
    <content><![CDATA[<p>五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。</p>
<p>主要分析的是服务器端应该使用的 IO 模型，因为服务器端需要处理大量的 IO 请求。</p>
<p>以下以读操作为例，对于写操作，是否可以写数据到缓冲区取决于缓冲区剩余空间是否足够。</p>
<span id="more"></span>
<h1 id="阻塞-IO-模型"><a href="#阻塞-IO-模型" class="headerlink" title="阻塞 IO 模型"></a>阻塞 IO 模型</h1><p>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。</p>
<p><img src="/2022/04/07/I-O-model/1068826-20170514141900066-500353710.png" alt="阻塞IO模型"></p>
<p>当用户线程发起一个 read 操作后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。<strong>当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才能解除阻塞状态。</strong> </p>
<p>典型的阻塞IO模型的例子为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data = socket.read(); </span><br></pre></td></tr></table></figure>
<h1 id="非阻塞-IO-模型"><a href="#非阻塞-IO-模型" class="headerlink" title="非阻塞 IO 模型"></a>非阻塞 IO 模型</h1><p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p>
<p><img src="/2022/04/07/I-O-model/1068826-20170514142359222-677058307.png" alt="非阻塞IO模型"></p>
<p> 所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪（自旋），也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p>
<p>典型的非阻塞IO模型一般如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123; </span><br><span class="line">    data = socket.read(); </span><br><span class="line">    <span class="keyword">if</span>(data!= error)&#123; </span><br><span class="line">        处理数据 </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="IO-复用模型"><a href="#IO-复用模型" class="headerlink" title="IO 复用模型"></a>IO 复用模型</h1><p>场景：对于一个应用线程 T，当多个用户向线程 T 发送请求（发送请求体的数据），为了能够同时响应多个用户，通常会选择用多个线程，每个线程来处理用户的请求，各个处理线程首先要调用 recvfrom 读取用户发过来的请求体数据，然后再进行处理，并且，通常来说，对每个用户的处理代码应该是相同的。</p>
<p>存在的问题：</p>
<ul>
<li>用户量庞大的时候，会创建大量的线程。</li>
<li>每个线程首先基于阻塞 IO 模型或者非阻塞 IO 模型读取数据时一旦读取不到数据，它或者阻塞或者自旋，会持续占据线程资源。这种问题在大量线程读取缓冲区数据时会变得更加严重。并且，无论是否阻塞/自旋，由于创建了大量的线程，线程切换的成本十分巨大。</li>
</ul>
<p>在 IO 复用模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。</p>
<p>因为在多路复用IO模型中，只需要<strong>使用一个线程就可以管理多个socket</strong>，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。</p>
<p><img src="/2022/04/07/I-O-model/1068826-20170514143622722-640397005.png" alt="多路复用IO模型" style="zoom:150%;"></p>
<p>多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的（会造成 CPU 模式切换），而在多路复用IO中，轮询每个socket状态是内核在进行的。</p>
<p>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<p><img src="/2022/04/07/I-O-model/v2-9b720fa8bbe7108003edc2abb6df7c71_720w.jpg" alt="文件描述符的量级和CPU耗时"></p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select 轮询所有 socket，找出能读出数据或者写入数据的 socket，并顺序对这些 socket 进行操作。</p>
<p><strong>select 函数接口</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构 (bitmap)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> max_fd, </span></span><br><span class="line"><span class="params">    fd_set *readset, </span></span><br><span class="line"><span class="params">    fd_set *writeset, </span></span><br><span class="line"><span class="params">    fd_set *exceptset, </span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> timeval *timeout</span></span><br><span class="line"><span class="params">)</span>                              <span class="comment">// 返回值就绪描述符的数目</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">FD_ZERO</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>   <span class="comment">// 清空集合</span></span><br><span class="line"><span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符加入集合</span></span><br><span class="line"><span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>  <span class="comment">// 判断指定描述符是否在集合中 </span></span><br><span class="line"><span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符从文件中删除  </span></span><br></pre></td></tr></table></figure>
<p>对 select 接口的理解</p>
<ul>
<li>每个 fd_set 是一个长度为 1024 的 bitmap，若 fd_set[fd] = 1，表示 fd 对应的文件资源有效。</li>
<li>FD_SET(int fd, fd_set* fds)：将 fds 的第 fd 位置 1</li>
<li><p>FD_ISSET(int fd, fd_set* fds)：判断 fds 的第 fd 位是否为 1</p>
</li>
<li><p>select 函数</p>
<ul>
<li>max_fd 参数告诉内核，只需要检查 fd 为 [0, max_fd-1] 区间的对应的文件资源即可。（<strong>在这个范围内，只检查 readset、writeset 和 exceptset 中为 1 的索引值 fd</strong>）</li>
<li>*read_set 参数是 fd_set 类型，当 read_set[fd] 为 1，表示 fd 对应的文件资源可以被读</li>
<li>select 函数会把在用户空间创建的 readset、writeset 和 exceptset 拷贝到内核空间，由内核更新这三个 fd_set 类型的数据，这会导致 <strong>CPU 模式的切换</strong>。</li>
<li>select 的返回值是就绪文件描述符的数目。当没有就绪的文件时，select 会导致用户线程的阻塞。当有就绪的文件时，<strong>select 返回，read_set、writeset 和 exceptset 会被更新</strong></li>
</ul>
</li>
</ul>
<p>具体来说，使用 select 函数的过程一般是：先调用宏 FD_ZERO 将指定的 fd_set 清零（fd_set 可以作为 read_set、writeset 或 exceptset 传入函数），然后调用宏 FD_SET <strong>将需要测试的 fd 加入 fd_set</strong> ，接着调用函数 select <strong>测试 fd_set 中的所有 fd</strong>，最后用宏 FD_ISSET 检查某个 fd 在函数 select 调用后是否为 1。</p>
<blockquote>
<p>fd_set 中原来为 1 的位对应的 fd 会变内核监听，如果可读写，则保持为 1，否则，置为 0</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 假设外面已经定义了 fd_set 类型的变量 rset </span></span><br><span class="line">    FD_ZERO(&amp;rset);</span><br><span class="line">    <span class="comment">// 设只需要监听 5 个 fd，例如，设 fds = [1,7,9,11,40]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        FD_SET(fds[i], &amp;rset); <span class="comment">// 将感兴趣的文件描述符加入 rset</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// max 在这个例子中是 40</span></span><br><span class="line">    <span class="comment">// 每次执行 select 都会拷贝 rset 到内核空间</span></span><br><span class="line">    select(max+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], &amp;rset))&#123;</span><br><span class="line">            <span class="comment">// 读取数据，不阻塞</span></span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, MAXBUF);</span><br><span class="line">            read(fds[i], buffer, MAXBUF);</span><br><span class="line">            <span class="comment">// .. 处理数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>select 的缺陷：</p>
<ul>
<li>单个进程所打开的 fd 是有限制的，通过 FD_SETSIZE 设置，默认1024。假如有 100 万个连接，每次只能处理 1024 个。</li>
<li>fd_set 不可重用。每个 while(1) 中都要先置 0、再注册感兴趣的文件描述符</li>
<li>会导致 CPU 模式切换</li>
<li>当 select 返回后，有可用的文件，不确定具体是哪几个，需要遍历 fd_set 找到该文件对应的 fd，并进行 IO 操作（<strong>IO 操作不会阻塞</strong>）</li>
</ul>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll 与 select 相同点：都是将用户传入的文件描述符集合拷贝到内核空间，然后轮询每个 fd 对应的文件状态</p>
<p>poll 与 select 的区别：将 fd_set 进一步封装为 struct pollfd fds[]，由 bitmap 变为结构体数组。对于文件描述符集合的操作自然也不再是用宏，例如 FD_SET。这使得，poll 比 select 具有优点：</p>
<ul>
<li><p>没有最大连接数的限制</p>
</li>
<li><p>fd 对应的 fds[fd] 是可重用的（如果需要监听的事件 events 不变的话，否则需要重新注册）。</p>
<blockquote>
<p>可重用：不需要像 select 那样先置 0 再重新将感兴趣的 fd 置 1。并不代表内核空间的文件描述符集合可重用，每次仍旧要从用户空间拷贝到内核空间</p>
</blockquote>
</li>
<li><p>一个 fds 可监听多种事件（设置 events 即可），不需要区分为 readset、writeset 和 exceptset</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;                         <span class="comment">// 需要监视的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;                   <span class="comment">// 需要内核监视的事件</span></span><br><span class="line">    <span class="type">short</span> revents;                  <span class="comment">// 实际发生的事件，r指real</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="comment">// 只监听 fds 的前 nfds 个元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fds[], <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 的步骤</p>
<ol>
<li><p>调用 epoll_create 建立一个 epoll 对象。</p>
</li>
<li><p>调用 epoll_ctl 向 epoll 对象中添加文件描述符句柄。（在需要的时候可以删除原有的 fd）</p>
</li>
<li><p>调用 epoll_wait 收集发生事件的连接。</p>
</li>
</ol>
<p>在调用 epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个 file 结点，在内核 cache 里建了个红黑树用于存储以后 epoll_ctl 传来的 socket 外，还会再建立一个 rdllist 双向链表，用于存储准备就绪的事件。</p>
<p>所有添加到 epoll 中的 fd 句柄都会关联一个回调方法，这个回调方法在内核中叫做 ep_poll_callback，fd 句柄中感兴趣的事件发生时，fd 会被放到 rdllist 中。于是，内核不需要不断地遍历扫描来判断注册的 fd 是否有事件发生。</p>
<p>当 epoll_wait 调用时，仅仅观察 rdllist 是否为空即可。如果 rdllist 不为空，则将 rdllist 复制到用户空间中，同时将事件数量返回给用户。rdlist 为空就 sleep（表现为用户线程阻塞），等到 timeout 时间到后即使链表没数据也返回。</p>
<p><img src="/2022/04/07/I-O-model/v2-f4af10c10479a9e0ec0ec9f327d78d70_720w-16506095928067.jpg" alt="epoll示意图"></p>
<h3 id="epoll-的两种触发模式"><a href="#epoll-的两种触发模式" class="headerlink" title="epoll 的两种触发模式"></a>epoll 的两种触发模式</h3><ul>
<li>LT 模式（水平触发，默认）只要有数据都会触发，缓冲区剩余未读尽的数据会导致 epoll_wait 返回。</li>
<li>ET 模式（边缘触发）只有数据到来才触发，不管缓存区中是否还有数据，缓冲区剩余未读尽的数据不会导致 epoll_wait 返回；</li>
</ul>
<p><img src="/2022/04/07/I-O-model/v2-e6c497d098c782ed52830da08b3e5cbe_720w.jpg" alt="img"></p>
<h3 id="select、poll-和-epoll-对比"><a href="#select、poll-和-epoll-对比" class="headerlink" title="select、poll 和 epoll 对比"></a>select、poll 和 epoll 对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody>
<tr>
<td>fd 数量</td>
<td>1024</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td>fd 状态判断</td>
<td>轮询 O(N)</td>
<td>轮询 O(N)</td>
<td>触发式 O(1)</td>
</tr>
<tr>
<td>fd 集合的重用性</td>
<td>不可重用</td>
<td>可重用</td>
<td>可重用</td>
</tr>
<tr>
<td>模式</td>
<td>LT</td>
<td>LT</td>
<td>LT 和 ET</td>
</tr>
</tbody>
</table>
</div>
<p>与select和poll相比，epoll为什么使用红黑树而非数组？</p>
<p>select和poll每次调用时都会存在一个将 fd_set 从用户态向内核态中拷贝的过程，，而epoll内核中维护了一个内核事件表，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发回调，当你要添加新的文件描述符的时候也是调用epoll_ctl函数使用EPOLL_CTL_ADD宏来插入，epoll_wait也不是每次调用时都会重新拷贝一遍所有的文件描述符到内核态。当我现在要在内核中长久的维护一个数据结构来存放文件描述符，并且时常会有插入，查找和删除的操作发生，红黑树三个操作更高效。</p>
<p>epoll为什么使用红黑树而不使用哈希表？</p>
<p>红黑树占用的内存更小（仅需要为其存在的节点分配内存），而HashMap事先就应该分配足够的内存存储散列表（即使有些槽可能遭弃用），也就是说，HashMap占用的空间只有部分存储了有效的节点</p>
<h1 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h1><p>在信号驱动IO模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程可以继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作（例如调用 socket.read()）来进行实际的 IO 请求操作。</p>
<p>调用 socket.read() 仍旧会阻塞用户线程，只不过相比阻塞IO模型，阻塞时间少去了等待数据的时间</p>
<h1 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h1><p>异步 IO 模型是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。</p>
<p>而另一方面，从内核的角度，当它收到一个 asynchronous read 之后，它会立刻返回（不让用户线程阻塞），说明 read 请求已经成功发起了，因此不会对用户线程产生任何阻塞。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。</p>
<p>也就说用户线程完全不需要知道实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。</p>
<p>相比信号驱动 IO 模型。在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。</p>
<p>异步 IO 需要操作系统的底层支持。</p>
<blockquote>
<p>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</p>
</blockquote>
<h1 id="Reactor-模式和-Proactor-模式"><a href="#Reactor-模式和-Proactor-模式" class="headerlink" title="Reactor 模式和 Proactor 模式"></a>Reactor 模式和 Proactor 模式</h1><p>在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便 <strong>顺序处理</strong> 每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：</p>
<p>注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。</p>
<p>在Proactor模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是Proactor模式。</p>
<h1 id="文件描述符（File-descriptor，fd）"><a href="#文件描述符（File-descriptor，fd）" class="headerlink" title="文件描述符（File descriptor，fd）"></a>文件描述符（File descriptor，fd）</h1><p>内核为<strong>每个进程</strong>维护了一个 file descriptor table，file descriptor<strong>（fd） 是</strong> file descriptor table 的<strong>索引</strong>，file descriptor table 的表项又是<strong>系统级</strong>（所有进程共享）的 file table 的索引。</p>
<p>file table 每个表项标识一个文件资源，记录了该资源的相关信息，例如所处模式（读、写等），并且还提供了到inode table 对应表项的索引，inode table 真正的描述了底层的文件。</p>
<p><img src="/2022/04/07/I-O-model/70.png" alt="File_table_and_inode_table"></p>
<p>在 Unix/Linux 系统中，一个 socket 句柄，可以看做是一个文件，在 socket 上收发数据，相当于对一个文件进行读写，所以一个 socket 句柄，通常也用表示文件句柄的 fd 来表示。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2022/04/04/JVM/</url>
    <content><![CDATA[<p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p>
<span id="more"></span>
<h1 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h1><p><img src="/2022/04/04/JVM/1647436365919-9cd662d0-1aa3-4501-902e-59dcd6095c3d.png" alt></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ul>
<blockquote>
<p>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
</blockquote>
<h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>描述的是 Java 方法执行的内存模型</p>
<p>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</p>
<p>Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。</p>
<ul>
<li>StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。可以用参数 -Xss 来调整栈的大小。</li>
<li>OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。</li>
</ul>
<blockquote>
<p>OOM：</p>
<p>栈 OOM，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生 OOM（2G 用完了）</p>
<p>堆 OOM，GC 之后无法在堆中申请足够内存创建对象；</p>
<p>方法区 OOM，经常会遇到的是动态生成大量的类等；</p>
<p>排查 OOM 的方法：</p>
<ul>
<li><p>增加两个参数</p>
<ul>
<li>-XX:+HeapDumpOnOutOfMemoryError</li>
<li>-XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；</li>
</ul>
</li>
<li><p>jstat 查看 JVM 的内存和 GC 情况；</p>
</li>
</ul>
<p>使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 </p>
</blockquote>
<h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>一个栈帧需要分配多少内存，不会受到程序运行时变量数据影响，仅仅取决于虚拟机的实现</p>
<p>如下图所示。虚拟机栈包含了两个 Java 方法的栈帧，而每个栈帧包括：局部变量表、操作数栈、动态链接、方法出口信息</p>
<p><img src="/2022/04/04/JVM/webp.webp" alt></p>
<h4 id="局部变量表（Local-Variable-Table）"><a href="#局部变量表（Local-Variable-Table）" class="headerlink" title="局部变量表（Local Variable Table）"></a>局部变量表（Local Variable Table）</h4><p>在编译代码的时候就可以确定栈帧需要多大的局部表量表，具体的大小可以在编译后的 Class 文件中看到。</p>
<p>局部变量表容量以变量槽（Variable Slot）为最小单位，每个变量槽长度 4 个字节</p>
<p>用于存放方法内的局部变量。虚拟机使用局部变量表完成参数值到参数变量表的传递过程，如果执行的是实例方法，那局部表量表的第 0 个槽位默认是用于传递方法所属对象的引用（this关键字）。</p>
<h4 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h4><p>在编译代码的时候就可以确定栈帧需要多大的操作数栈，具体的大小可以在编译后的 Class 文件中看到。</p>
<p>在函数调用时，第一个进栈的是被调用函数的下一条可执行语句的地址， 然后是函数的各个参数，然后是函数中的局部变量。注意静态变量是不入栈的。</p>
<p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p>
<h4 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h4><p>动态链接：一个指向运行时常量池中该栈帧所属方法的引用。运行时常量池中该栈帧所属方法的存在方式是一个符号引用，或者直接引用（如果之前被解析过）</p>
<h4 id="完成出口（Return-Address，也叫做返回地址-）"><a href="#完成出口（Return-Address，也叫做返回地址-）" class="headerlink" title="完成出口（Return Address，也叫做返回地址 ）"></a>完成出口（Return Address，也叫做返回地址 ）</h4><p>两种退出方式：return 返回指令，异常退出</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 </p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象<strong>实例</strong>，几乎所有的对象实例以及数组都在这里分配内存。</p>
<p>new 一个对象，对象实例存放在堆中，对象的引用存放在栈中。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>它用于存储已被虚拟机加载的类信息（Class 文件）、常量、静态变量、即时编译器（JIT compiler）编译后的代码等数据。</p>
<p>方法表、字段表被放在方法区。根据运行时常量池的符号引用解析找到方法区中的方法和字段。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<p>Class 文件中有一项信息是常量池（Constant Pool），用于存放编译期生成的符号引用，这部分内容将在类加载阶段存放到方法区中，它的存放区域也叫做运行时常量池。在类的解析阶段会将这些符号引用翻译为直接引用，用翻译出来的直接引用替换原本的符号引用。</p>
<h3 id="方法区结构的变化"><a href="#方法区结构的变化" class="headerlink" title="方法区结构的变化"></a>方法区结构的变化</h3><p><img src="/2022/04/04/JVM/method-area-1.6.291acb6f.png" alt="方法区-jdk1.6"></p>
<p><img src="/2022/04/04/JVM/method-area-jdk1.7.d852e1fb.png" alt="方法区-jdk1.7"></p>
<p><img src="/2022/04/04/JVM/method-area-jdk1.8.f83a79be.png" alt="方法区-jdk1.8"></p>
<ol>
<li><p>JDK1.7 之前，运行时常量池包含字符串常量池，运行时常量池和静态变量存放在方法区，此时 HotSpot 虚拟机对方法区的实现为永久代。</p>
<blockquote>
<p>在堆中创建字符串常量对应的 String 实例，它的引用存储在方法区的字符串常量池</p>
<p>如果静态变量是基本类型数据，如 static int i = 1; 1 这个值存储在方法区，如果静态变量是一个对象，在堆中创建静态变量的实例，它的引用存储在方法区</p>
</blockquote>
</li>
<li><p>JDK1.7 运行时常量池中的字符串常量池被拿到了堆中、静态变量被拿到了堆中，此时 HotSpot 虚拟机对方法区的实现为永久代 。</p>
<blockquote>
<p><strong>字符串常量池物理上存放在堆中，但逻辑上还是属于方法区</strong></p>
<p>为什么要将字符串常量池移动到堆中？</p>
<p>主要是因为永久代的 GC 回收效率太低，只有在 Full GC 的时候才会进行回收。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
</blockquote>
</li>
<li><p>JDK1.8 HotSpot 移除了永久代用元空间（Metaspace）取而代之，这时候字符串常量池和静态变量还在堆, 运行时常量池还在方法区，只不过方法区的实现从永久代变成了元空间（Metaspace）</p>
<blockquote>
<p>元空间的出现是为了解决突出的类和类加载器元数据过多导致的OOM问题。元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
</blockquote>
</li>
</ol>
<h3 id="基本类型包装类对象常量池"><a href="#基本类型包装类对象常量池" class="headerlink" title="基本类型包装类对象常量池"></a>基本类型包装类对象常量池</h3><p>java 中基本类型的包装类的大部分都实现了常量池技术，这些类是：</p>
<p>Byte、Short、Integer、Long、Character、Boolean。</p>
<p>另外上面这 5 种整型的包装类也只是在对应值小于等于 127 时才可使用对象常量池。</p>
<h1 id="JVM-调优"><a href="#JVM-调优" class="headerlink" title="JVM 调优"></a>JVM 调优</h1><h2 id="JVM-调优命令"><a href="#JVM-调优命令" class="headerlink" title="JVM 调优命令"></a>JVM 调优命令</h2><ul>
<li>jps：JVM Process Status Tool，显示指定系统内所有的 HotSpot 虚拟机进程。</li>
<li>jstat：JVM statistics Monitoring，是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。</li>
<li><p>jmap：JVM Memory Map，用于生成 heap dump 文件，如果不使用这个命令，还可以使<br>  用 -XX:+HeapDumpOnOutOfMemoryError 参数来让虚拟机出现 OOM 的时候·自动生成dump文件。<br>  jmap不仅能生成 dump 文件，还可以查询 finalize 执行队列、Java 堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p>
</li>
<li><p>jhat：JVM Heap Analysis Tool，与 jmap 搭配使用，用来分析 jmap 生成的 dump 文件，jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为 jhat 是一个耗时并且耗费硬件资源的过程，一般把服务器生成的 dump 文件复制到本地或其他机器上进行分析。</p>
</li>
<li>jstack：jstack 用于生成 java 虚拟机当前时刻的线程快照。jstack 查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果 java 程序崩溃生成 core 文件，jstack 工具可以用来获得 core 文件的 java stack 和 native stack 的信息，从而可以轻松地知道java 程序是如何崩溃和在程序何处发生问题。</li>
</ul>
<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>考虑这样一个 Java 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    bar();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Class 文件，后缀名是 .class，也可以叫做 .class 文件，这两个称呼区别于 Class 对象。用 javac 编译器编译出来的 Class 文件的文本形式（存储时为二进制形式）如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classfile /private/tmp/X.class</span><br><span class="line">  Last modified Jun 13, 2015; size 372 bytes</span><br><span class="line">  MD5 checksum 8abb9cbb66266e8bc3f5eeb35c3cc4dd</span><br><span class="line">  Compiled from &quot;X.java&quot;</span><br><span class="line">public class X</span><br><span class="line">  SourceFile: &quot;X.java&quot;</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 51</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#16         //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Methodref          #3.#17         //  X.bar:()V</span><br><span class="line">   #3 = Class              #18            //  X</span><br><span class="line">   #4 = Class              #19            //  java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Utf8               Code</span><br><span class="line">   #8 = Utf8               LineNumberTable</span><br><span class="line">   #9 = Utf8               LocalVariableTable</span><br><span class="line">  #10 = Utf8               this</span><br><span class="line">  #11 = Utf8               LX;</span><br><span class="line">  #12 = Utf8               foo</span><br><span class="line">  #13 = Utf8               bar</span><br><span class="line">  #14 = Utf8               SourceFile</span><br><span class="line">  #15 = Utf8               X.java</span><br><span class="line">  #16 = NameAndType        #5:#6          //  &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #17 = NameAndType        #13:#6         //  bar:()V</span><br><span class="line">  #18 = Utf8               X</span><br><span class="line">  #19 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public X();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0       </span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return        </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">               0       5     0  this   LX;</span><br><span class="line"></span><br><span class="line">  public void foo();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0       </span><br><span class="line">         1: invokevirtual #2                  // Method bar:()V</span><br><span class="line">         4: return        </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">               0       5     0  this   LX;</span><br><span class="line"></span><br><span class="line">  public void bar();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=0, locals=1, args_size=1</span><br><span class="line">         0: return        </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">               0       1     0  this   LX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 Class 文件里有一段叫做 Constant pool，也就是常量池</p>
<p>来观察 foo() 方法是如何调用 bar() 的，具体地，来考察 foo() 方法里的一条字节码指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: invokevirtual #2  // Method bar:()V</span><br></pre></td></tr></table></figure>
<p>该字节码指令的二进制存储格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[B6] [00 02]</span><br></pre></td></tr></table></figure>
<p>其中 0xB6 是 invokevirtual 指令的操作码（opcode），后面的 0x0002 是该指令的操作数（operand），用于指定要调用的目标方法。因此，我们来看它的操作数。</p>
<p>这个参数是 Class 文件里的常量池的下标。那么去找下标为 2 的常量池项，是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#2 = Methodref          #3.#17         //  X.bar:()V</span><br></pre></td></tr></table></figure>
<p>该语句的二进制存储格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0A] [00 03] [00 11]</span><br></pre></td></tr></table></figure>
<p>其中 0x0A 是 CONSTANT_Methodref_info 的 tag，后面的 0x03 和 0x11 是常量池下标，分别表示 class_index 和 name_and_type_index。</p>
<p>顺着这条线索把能传递引用到的常量池项都找出来，会看到（按深度优先顺序排列）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #2 = Methodref          #3.#17         //  X.bar:()V</span><br><span class="line"> </span><br><span class="line"> #3 = Class              #18            //  X</span><br><span class="line">#18 = Utf8               X</span><br><span class="line"></span><br><span class="line">#17 = NameAndType        #13:#6         //  bar:()V</span><br><span class="line">#13 = Utf8               bar</span><br><span class="line"> #6 = Utf8               ()V</span><br></pre></td></tr></table></figure>
<p>把引用关系画成一棵树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     #2 Methodref X.bar:()V</span><br><span class="line">     /                     \</span><br><span class="line">#3 Class X       #17 NameAndType bar:()V</span><br><span class="line">    |                /             \</span><br><span class="line">#18 Utf8 X    #13 Utf8 bar     #6 Utf8 ()V</span><br></pre></td></tr></table></figure>
<p>总而言之，Class 文件里的符号引用实际上是：带有类型（tag） / 结构（符号间引用层次）的字符串。</p>
<p>将方法的符号引用解析为直接引用：</p>
<p>JVM在类加载的时候会把 Class 文件转化为<strong>方法区</strong>的运行时数据结构。例如说类的元数据记录在 ClassClass 结构体里，每个方法的元数据记录在各自的 methodblock 结构体里。</p>
<p>在刚加载好一个类的时候，Class文件里的常量池和每个方法的字节码（Code属性）会被基本原样的拷贝到内存里先放着，也就是说仍然处于使用“符号引用”的状态；直到真的要被使用到的时候才会被解析（resolve）为直接引用。</p>
<p>假定我们要第一次执行到 foo() 方法里调用 bar() 方法的那条 invokevirtual 指令了。</p>
<p>此时JVM会发现该指令尚未被解析，所以会先去解析。</p>
<p>通过其操作数所记录的常量池下标 0x0002，找到常量池项 #2，发现该常量池项也尚未被解析，于是进一步去解析该项。解析过程为：</p>
<p>通过 Methodref 所记录的 class_index 找到类名，进一步找到被调用方法的类的 ClassClass 结构体（类的符号引用是否在加载后就变成了直接引用？）；然后通过 name_and_type_index 找到方法名和方法描述符，到ClassClass 结构体上记录的方法列表里找到匹配的那个 methodblock；最终把找到的 methodblock 的指针写回到常量池项 #2 里。</p>
<p>也就是说，原本常量池项 #2 在类加载后的运行时常量池里的内容跟 Class 文件里的一致，是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[00 03] [00 11]</span><br></pre></td></tr></table></figure>
<p>小细节，tag 被放到了别的地方。而在解析后，假设找到的 methodblock 地址是 0x45762300，那么常量池项 #2的内容会变为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[00 23 76 45]</span><br></pre></td></tr></table></figure>
<p>这样，以后再查询到常量池项 #2 时，里面就不再是一个符号引用，而是一个能直接找到 Java 方法元数据的直接引用了。</p>
<p>解析好常量池项 #2 之后回到 invokevirtual 指令的解析。回顾一下，在解析前那条指令的内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[B6] [00 02]</span><br></pre></td></tr></table></figure>
<p>而在解析后，这块代码被改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[D6] [06] [01]</span><br></pre></td></tr></table></figure>
<p>其中 opcode 部分从 invokevirtual 改写为 invokevirtual_quick，表示该指令已经解析完毕。原本存储操作数的 2字节空间现在分别存了 2 个 1 字节信息，第一个是虚方法表的下标（vtable index），第二个是方法的参数个数。这两项信息都由前面解析常量池项 #2 得到的 methodblock 读取而来。</p>
<p>可以看到，方法表各个方法按序排列，并且每个方法具有该方法的详细信息，包括 code，即字节码指令，后面被加载到方法区</p>
<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><ul>
<li><p>主要三步：加载 -&gt; 连接 -&gt; 初始化。连接过程又可分为三步：验证 -&gt; 准备 -&gt; 解析。</p>
</li>
<li><p>何时会执行各个加载步骤？</p>
<p>  动态加载，并不是一次性把所有程序中定义的 class 全部加载到内存，而是第一次用到 class 时才加载</p>
<p>  加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p>
<p>  解析时机：<strong>用于操作符号引用的字节码指令</strong>之前，先对它们所使用的符号引用进行解析</p>
</li>
</ul>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段，虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取此类的二进制字节流。例如，用 javac 编译得到的 .class 文件（也称做 Class 文件）</li>
<li>将这个字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构（类元数据，包括常量池、属性表、方法表和异常表等）。这个过程包含了 .class 文件中的常量池存放到运行时常量池的过程。</li>
<li>在<strong>堆</strong>中生成一个 java.lang.Class 对象，用来封装在方法区内的类型数据，并作为方法区类型数据的外部接口。（通过堆中的 Class 对象，访问方法区中的类的数据结构）</li>
</ol>
<p><img src="/2022/04/04/JVM/331425-20160621125941772-1913742708.png" alt></p>
<blockquote>
<p>Class 作为方法区类型数据的外部接口，Class 实例本身没有类型数据，但 Class 实例具有指向类元数据的指针，通过这个指针访问类元数据。</p>
<p>普通对象实例也具有指向类元数据的指针，但是要获取类的信息，需要通过 getClass()，得到的是 Class 对象的引用，不能直接得到对象头中指向类元数据的指针。</p>
<p>类元数据包含 Class 对象的引用。</p>
<ul>
<li>具体来说，当使用 String.class，String 即 String 类元数据的指针，.class 即获取类元数据中 Class 对象的引用</li>
<li>当使用 对象.getClass() 和 class.forName()，前者看似是得到对象头中指向类元数据的指针，后者看似是直接得到指向类元数据的指针，实际上在函数内部处理后，返回的还是 Class 对象的引用。</li>
</ul>
</blockquote>
<p>一个非数组类的加载阶段（具体地，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。</p>
<p>数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配（方法区中存放着类的数据结构）。对于该阶段有以下几点需要注意：</p>
<ol>
<li>这时候进行内存分配的仅包括类变量（ 即类的静态变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>
<li>从概念上讲，类变量所使用的内存都应当在 方法区 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。当class文件被加载到内存中时，类文件常量池中的其他常量会加载到运行时常量池，但是字符串常量不会。它会首先在堆区中创建一个字符串对象，然后再把这个对象的引用保存到全局字符串常量池中</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值，比如我们定义了 public static int value=111，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：给 value 变量加上了 final 关键字，public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。</li>
</ol>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。（常量池原本存储的是符号引用，被替换成了直接引用）</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p>以解析方法的符号引用为例，在执行方法时，系统需要明确知道这个方法所在的地址。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<blockquote>
<p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行 ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield 和 putstatic 这17个<strong>用于操作符号引用的字节码指令</strong>之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
</blockquote>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>\<clinit>() 方法是编译之后自动生成的。初始化阶段是执行初始化方法 \<clinit>() 的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码（字节码）。</clinit></clinit></p>
<p>虚拟机会保证一个类的 \<clinit>() 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 \<clinit>() 方法，其他线程都需要阻塞等待，直到活动线程执行 \<clinit>() 方法完毕。</clinit></clinit></clinit></p>
<p>需要注意的是，其他线程虽然会被阻塞，但当活动线程执行 \<clinit>() 方法后，其他线程被唤醒之后不会再次执行\<clinit>() 方法。同一个加载器下，一个类型只会初始化一次。（这与一般的 Synchronized 方法有显著区别）</clinit></clinit></p>
<blockquote>
<p>\<init\> 是实例构造器，对非静态变量初始化，而  \<clinit> 是类构造器，对静态变量，静态代码块进行初始化。</clinit></init\></p>
</blockquote>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：</p>
<ol>
<li>BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%/lib目录下的 jar 包和类或者被 -Xbootclasspath参数指定的路径中的所有类。</li>
<li>ExtensionClassLoader(扩展类加载器) ：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。</li>
<li>AppClassLoader(应用程序类加载器) ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>
</ol>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><img src="/2022/04/04/JVM/1647438628208-03b39124-9351-4ff0-ab47-61df7698891e.png" alt="类加载器"></p>
<p>全限定类名：就是类名全称，带包路径的用点隔开，例如: java.lang.String<br>非限定类名：String</p>
<p>为了防止内存中出现多个相同的字节码；因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性。</p>
<p>自己写过String类能加载吗，之前的String是什么时候加载进去的？<br>不能加载，因为双亲委派机制，JVM 出于安全性的考虑，全限定类名相同的 String 是不能被加载的。<br>java.lang.String 会被顶级类加载器 BootstrapClassloader 加载。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1 类加载检查"></a>1 类加载检查</h3><p>虚拟机遇到一条 new 指令时，首先将去检查是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2 分配内存"></a>2 分配内存</h3><p>对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有整理功能决定。</p>
<p>内存分配的两种方式</p>
<p><img src="/2022/04/04/JVM/1647436415158-62c57e47-e0c6-43d3-ae19-f7bb65c339dc.png" alt></p>
<p><strong>内存分配并发问题</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全。通常来讲，虚拟机采用两种方式来保证创建对象过程的线程安全：</p>
<ul>
<li>CAS</li>
<li>TLAB： 为每一个线程预先在 Eden 区分配一块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用 CAS 进行内存分配</li>
</ul>
<h3 id="3-初始化零值"><a href="#3-初始化零值" class="headerlink" title="3 初始化零值"></a>3 初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了<strong>对象的实例字段在 Java 代码中可以不赋初始值就直接使用</strong>。</p>
<h3 id="4-设置对象头"><a href="#4-设置对象头" class="headerlink" title="4 设置对象头"></a>4 设置对象头</h3><p>Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<blockquote>
<p>类元数据：加载阶段生成的“<strong>方法区</strong>的运行时数据结构”</p>
<p>类型指针：不是 Class 对象的引用</p>
</blockquote>
<h3 id="5-执行-init-方法"><a href="#5-执行-init-方法" class="headerlink" title="5 执行 init 方法"></a>5 执行 init 方法</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，\<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 \<init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</init></init></p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。</p>
<p>Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p>
<p>对齐填充部分仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java 通过引用来访问对象，引用的具体实现方式有两种</p>
<ol>
<li><p>句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，句柄池用于存放多个对象的句柄。句柄中包含了对象实例数据与类型数据各自的地址，而 reference 中存储的就是对象的句柄地址；</p>
<p> <img src="/2022/04/04/JVM/1647439292918-98859438-8a5f-47bc-93c6-eddb1d4717dc.png" alt="句柄"></p>
</li>
<li><p>直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息（到对象类型数据的指针），而 reference 中存储的直接就是对象的地址。</p>
<p> <img src="/2022/04/04/JVM/1647439292769-26b729bb-dc2c-4607-9dc9-bbf390dd0bc2.png" alt="直接指针"></p>
</li>
</ol>
<p>使用句柄来访问的好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式的好处是速度快，它节省了一次指针定位的时间开销。</p>
<p><strong>在 Hotspot 虚拟机中，使用直接指针的方法来实现引用，对象类型数据的指针被存放在对象头中。</strong></p>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
<ol>
<li>效率问题（遍历整个内存空间进行回收）</li>
<li>空间问题（标记清除后会产生大量不连续的碎片）</li>
</ol>
<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p><img src="/2022/04/04/JVM/1647431576601-544027ae-f696-4da9-abf5-29f0138a8663.png" alt="标记-复制算法" style="zoom: 67%;"></p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="/2022/04/04/JVM/1647431631421-c33e7513-6f19-41bc-8bfc-4ffd941070cd.png" alt="标记-整理算法"></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>一般将 java 堆分为新生代和老年代，这样我们就可以<strong>根据各个年代的特点选择合适的垃圾收集算法</strong>。</p>
<ul>
<li>在新生代中，每次收集都会有大量对象死去，所以可以选择“标记-复制”算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集（只有少量存活对象需要复制）</li>
<li>老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</li>
</ul>
<h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h1><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。</p>
<p><img src="/2022/04/04/JVM/1647430687276-153ea241-823f-4b57-a212-9f137ba30be8.png" alt="GC 堆划分"></p>
<h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><p>垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>
<p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 两个对象互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。<br>哪些对象可以作为 GC Roots 呢？</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>本地方法栈（Native 方法）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<blockquote>
<p>对象已经死亡，就代表马上（不是最终）会被回收吗？</p>
<p>先进入回收队列，JVM 会开一个线程进行回收，除非在被回收之前，这个对象与引用链上的任何一个对象建立关联才不会被回收。</p>
</blockquote>
<h3 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h3><p>强引用，就是普通的对象引用关系</p>
<p>软引用，在内存不足时，系统会强制回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，会抛出内存溢出异常。</p>
<p>弱引用，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。</p>
<p>虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来跟踪对象被垃圾回收的活动。</p>
<h2 id="判断一个类是无用的类"><a href="#判断一个类是无用的类" class="headerlink" title="判断一个类是无用的类"></a>判断一个类是无用的类</h2><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p>
<p>类需要同时满足下面 3 个条件才能算是 “无用的类” ：</p>
<ul>
<li>该类所有的实例都已经被回收。</li>
<li>该类的类加载器实例已经被回收。（所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。）</li>
<li>该类的 Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="JVM-垃圾回收过程"><a href="#JVM-垃圾回收过程" class="headerlink" title="JVM 垃圾回收过程"></a>JVM 垃圾回收过程</h2><p>新生代 ( Young )、老年代 ( Old )，新生代默认占总空间的1/3，老年代默认占 2/3。</p>
<p>新生代有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。</p>
<p>新生代的垃圾回收（Minor GC）选用复制算法。老年代的垃圾回收（Major GC）通常使用“标记-清理”或“标记-整理”算法。</p>
<p>Survivor 分区：空的 Survivor 分区被称为 Survivor To 分区，存在对象的分区称为 Survivor From 分区</p>
<p>Minor GC触发条件：当 Eden 区没有足够空间进行分配时，触发Minor GC。</p>
<p>垃圾回收过程：</p>
<ul>
<li>对象优先在 Eden 分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区；</li>
<li>Eden 区没有足够空间进行分配，再次 Minor GC，这时会采用复制算法，将 Eden 和 From 区一起清理，存活的对象会被复制到 To 区；</li>
<li>每移动一次，对象年龄加 1，对象年龄大于一定阀值会直接移动到老年代。<ul>
<li>固定阈值。通过参数 -XX:MaxTenuringThreshold 设置，默认为 15</li>
<li>动态阈值：Survivor 区相同年龄所有对象大小的总和 &gt; (Survivor 区内存大小 * TargetSurvivorRatio)时，大于或等于该年龄的对象直接进入老年代。<ul>
<li>-XX:TargetSurvivorRatio 指定，默认为 50%；</li>
<li>新的阈值为 min(该年龄，固定阈值）</li>
<li>计算方法：用数组记录各个年龄中所有对象的大小之和</li>
</ul>
</li>
</ul>
</li>
<li>Survivor 区内存不足会发生担保分配，超过指定大小的对象直接进入老年代。</li>
<li>老年代空间不足，进行 Full GC。</li>
</ul>
<h3 id="空间担保分配"><a href="#空间担保分配" class="headerlink" title="空间担保分配"></a>空间担保分配</h3><p>是因为新生代采用复制收集算法，假如大量对象在 Minor GC 后仍然存活，而 Survivor To 空间是比较小的，不足以实现复制，这时就需要老年代进行分配担保，把 Survivor 无法容纳的对象放到老年代。</p>
<p>JVM 使用空间分配担保机制来用来让对象进入老年代。</p>
<p>JDK 6 Update 24 之前，在<strong>发生 Minor GC 之前</strong>，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。</p>
<p>如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数，该参数表示是否允许担保失败。如果允许，继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许担保失败，那这时就要改为进行一次 Full GC。</p>
<p>在允许担保失败并尝试进行 Minor GC 后，可能会出现三种情况：</p>
<ul>
<li>Minor GC 后，存活对象小于 survivor to 大小，此时存活对象进入 survivor to 区中</li>
<li>Minor GC 后，存活对象大于 survivor to 大小，但是小于老年代可用空间大小，此时直接进入老年代。</li>
<li>Minor GC 后，存活对象大于 survivor to 大小，也大于老年代可用空间大小，发生“Handle Promotion Failure”，担保分配失败，会触发 Full GC。如果 Full GC 后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。</li>
</ul>
<p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p>
<h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><p>Minor GC：新生代的 GC。触发条件：当 Eden 区满时，触发 Minor GC。</p>
<p>Full GC：整个堆的 GC，包括新生代、老年代<strong>和永久代</strong>（注意 Full GC 会清理方法区。在 JDK 1.8及以后，永久代被移除，换为 metaspace 元空间）。触发条件：</p>
<p>在<strong>发生 Minor GC 之前</strong>，虚拟机检查发现老年代最大可用的连续空间 &lt; 新生代所有对象总空间：</p>
<ul>
<li>允许担保分配失败并且老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小：在 Minor GC 后，存活对象大于 survivor to 大小，也大于老年代可用空间大小，触发 Full GC</li>
<li>不允许担保分配失败，触发 Full GC</li>
</ul>
<p>老年代空间不够分配新的内存（或永久代空间不足，但只是JDK1.7有的，这也是用元空间来取代永久代的原因，可以减少Full GC的频率，减少GC负担，提升其效率）</p>
<p>Full GC 清理堆和方法区，需要 stop the world 的时间更长</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>Serial、ParNew：新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
<p>CMS：标记-清除算法</p>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p>
<p><img src="/2022/04/04/JVM/1647431959692-a9b1b24b-b425-4746-b5c9-566932bb41bf.png" alt></p>
<p>优点：单线程收集效率高，</p>
<p>缺点：单线程收集，stop the world 造成停顿，实时性差</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本。仍然要暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p>
<p><img src="/2022/04/04/JVM/1647432020975-d07110a4-443c-44a4-b3b1-be12ac618e08.png" alt></p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS（Concurrent Mark Sweep）收集器设计目的是为了实现低停顿。</p>
<p>它的运作过程分为四个步骤：</p>
<ul>
<li><strong>初始标记</strong>： 暂停所有的其他线程，进行可达性分析 ；</li>
<li>并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记</strong>：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除</strong>： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p><img src="/2022/04/04/JVM/1647432336054-17d3daab-8419-4f7e-9a18-0968c1ad7cb8.png" alt></p>
<p>优点：并发收集、低停顿。（初始标记和重新标记阶段仍然需要 stop the world，暂停其他所有工作线程，造成停顿。</p>
<p>缺点：</p>
<ul>
<li>对 CPU 资源敏感；(并发，需要多 cpu，让用户线程和 GC 线程运行在不同 cpu 上）</li>
<li>无法处理浮动垃圾；</li>
<li>“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 并发</title>
    <url>/2022/04/07/Java-Concurrency/</url>
    <content><![CDATA[<p>Java 并发机制</p>
<span id="more"></span>
<p>线程同步的方式<br>1、临界区：拥有临界区的线程可以访问被保护起来的资源或代码段，<br>2、事件：事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。<br>3、互斥量：互斥对象和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的<br>各个线程之间使用，但是更节省资源，更有效率。<br>4、信号量：当需要一个计数器来限制可以使用某共享资源的线程数目时（多个资源整体作为一个共享资源），可以使用“信号量”对象。<br>互斥量，信号量，事件都可以实现不同进程的线程同步操作</p>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>创建线程实例一般有两种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承 Thread 类并重写 run()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> newMyThread();</span><br><span class="line">myThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Runnable 接口并重写 run()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 Thread  类的构造函数中传入 MyRunnable  的实例对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> newThread(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<h2 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h2><ul>
<li><p>继承 Thread 类</p>
<p>  优点：如果要访问当前线程，无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</p>
<p>  缺点：线程类已经继承了Thread类，所以不能再继承其他父类。</p>
</li>
<li><p>实现 Runnable 或 Callable 接口。</p>
<p>  优点：线程类可以继承其他类。</p>
<p>  缺点：如果要访问当前线程，则必须使用 Thread.currentThread() 方法。</p>
</li>
</ul>
<h2 id="Runnable-和-Callable-的区别"><a href="#Runnable-和-Callable-的区别" class="headerlink" title="Runnable 和 Callable 的区别"></a>Runnable 和 Callable 的区别</h2><p>Callable 重写的方法是 call()，Runnable 重写的方法是 run()</p>
<ul>
<li><p>Call 方法可以抛出异常，run 方法不可以。</p>
</li>
<li><p>Call 方法可异步返回一个Future对象，run 方法没有返回值。</p>
<p>  Future 对象，表示异步计算的结果。通过这个对象可以判断任务是否执行成功，并且可以通过 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，get() 也可以设置阻塞时间，在一定时间后立即返回，这时候有可能任务没有执行完。</p>
</li>
</ul>
<h1 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h1><p>New、Runnable、Running、（Blocked、Waiting、Timed_Waiting）、Dead</p>
<ul>
<li><p>调用 start 方法方可启动线程并使线程进入就绪状态</p>
</li>
<li><p>Blocked、Waiting、Timed_Waiting：在满足条件后进入 Runnable，等待调度</p>
</li>
<li>Synchronized 方法执行完后回到就绪状态</li>
<li>线程死亡分为正常结束（run()  或者 call()  方法执行完成）和异常结束（线程抛出一个未捕获的 Exception  或 Error）</li>
</ul>
<p><img src="/2022/04/07/Java-Concurrency/1647567554292-06cfc90a-5237-4910-9b51-823c1d7f20aa.png" alt="线程状态转移图"></p>
<blockquote>
<p>订正：原图中 wait 到 runnable 状态的转换中，join实际上是Thread类的方法，但这里写成了Object。</p>
</blockquote>
<p>Thread.yield 方法有什么作用？</p>
<p>可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用 CPU，执行 yield() 的线程有可能在进入到暂停状态后马上又被执行。</p>
<h2 id="sleep-方法和-wait-方法比较"><a href="#sleep-方法和-wait-方法比较" class="headerlink" title="sleep() 方法和 wait() 方法比较"></a>sleep() 方法和 wait() 方法比较</h2><p>相同点：都可以暂停线程的执行</p>
<p>区别：</p>
<ul>
<li>sleep() 方法没有释放锁，而 wait() 方法释放了锁</li>
<li>sleep() 通常被用于暂停执行，wait() 通常被用于线程间交互/通信</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。</li>
</ul>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="使用-synchronized-关键字"><a href="#使用-synchronized-关键字" class="headerlink" title="使用 synchronized 关键字"></a>使用 synchronized 关键字</h2><p><strong>修饰实例方法</strong>：作用于当前对象实例加锁。synchronized void method()</p>
<p><strong>修饰静态方法</strong>：也就是给当前类加锁。synchronized static void method()</p>
<p><strong>修饰代码块</strong>：synchronized(…){}</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在 Java 早期版本中，synchronized 属于 <strong>重量级锁</strong>，效率低下。</p>
<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p>monitor 对象存在于每个 Java 对象的对象头中，具体来说，对象头中存储着指向该对象的 monitor 的指针。</p>
<p>在 hotspot 虚拟机中，ObjectMonitor中有几个关键属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>_owner</td>
<td>指向持有ObjectMonitor对象的线程</td>
</tr>
<tr>
<td>_WaitSet</td>
<td>存放处于 wait 状态的线程队列</td>
</tr>
<tr>
<td>_EntryList</td>
<td>存放处于等待锁 block 状态的线程队列</td>
</tr>
<tr>
<td>_recursions</td>
<td>锁的重入次数</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>刚开始 Monitor 中 _owner 为 null，当线程 T1 获得 monitor，_owner 设为 T1，_recursions 加1</li>
<li>在 T1 还没有释放 monitor 的时候，如果 T2，T3 也执行 synchronized 代码，就会进入 _EntryList，状态是 blocked；如果 T1 再次获取 monitor，_recursions 加1；当 T1 执行完同步代码块的内容，_recursions 减1，当 _recursions = 0，会唤醒 _EntryList 中等待的线程以非公平的方式来竞争锁，</li>
<li>若持有 monitor 的线程 T1 调用 wait()，_owner 置为 null，_recursions 减1，T1 进入 _WaitSet 等待被唤醒</li>
</ul>
<p><img src="/2022/04/07/Java-Concurrency/format,png.png" alt="monitor 原理图"></p>
<blockquote>
<p>monitor 的性能</p>
<p>监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，这导致从用户模式转换到内核模式。</p>
<p>CPU 模式转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”</p>
</blockquote>
<h3 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h3><p>修饰代码块：通过 monitorenter 和 monitorexit 指令，指明同步代码块的开始和结束位置。当线程执行monitorenter 指令，线程尝试获取monitor，获取成功后才能调用方法，方法执行完后执行monitorexit 指令释放monitor。</p>
<p>修饰方法：用 ACC_SYNCHRONIZED 标识指明该方法是一个同步方法。当线程执行该方法时，线程需要先获取monitor，获取成功后才能调用方法，方法执行完后再释放 monitor。用一种隐式的方式来实现，而不是显式地通过字节码指令 monitorenter 和 monitorexit。</p>
<h2 id="Synchronized-的作用"><a href="#Synchronized-的作用" class="headerlink" title="Synchronized 的作用"></a>Synchronized 的作用</h2><ol>
<li>原子性：确保线程互斥的访问同步代码；</li>
<li>可见性：保证共享变量的修改能够及时可见，Synchronized 块内部的共享变量或者 Synchronized 方法内部用到的共享变量都会保证可见性；</li>
<li>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”</li>
</ol>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>Java 6 之后官方从 JVM 层面（体现在对象头）对 synchronized 进行优化。如自旋锁、适应性自旋锁、锁消除、锁粗化、锁膨胀等技术来减少锁操作的开销。</p>
<p>锁膨胀：锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>
<p>无锁：实现方式是 CAS</p>
<p>偏向锁</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p><strong>轻量级锁</strong></p>
<p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。（两个线程？）</p>
<p>重量级锁<br>重量级锁是由轻量级锁升级而来，当同一时间有<strong>多个线程</strong>竞争锁时，锁就会被升级成重量级锁，此时其<br>申请锁带来的开销也就变大。</p>
<h2 id="synchronized-和-ReentrantLock-的对比"><a href="#synchronized-和-ReentrantLock-的对比" class="headerlink" title="synchronized 和 ReentrantLock 的对比"></a>synchronized 和 ReentrantLock 的对比</h2><p>相同：两者都是可重入锁</p>
<p>区别：</p>
<ul>
<li><p>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</p>
</li>
<li><p>synchronized 是依赖于 JVM 实现的，ReentrantLock 是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成</p>
<blockquote>
<p>ReetrantLock 实现依赖于 AQS(AbstractQueuedSynchronizer)。ReetrantLock 主要依靠 AQS 维护一个阻塞队列，多个线程获取锁时，失败则会进入阻塞队列等待唤醒。</p>
<p>ReentrantLock 在获得锁的时候用到了 CAS，但是这只是为了获得锁的时候同步，并不是为了对用到ReentrantLock 的代码块同步。ReentrantLock 用 CAS 方式获得锁之后，其他线程不能获取锁，所以是悲观锁。</p>
</blockquote>
</li>
<li><p>synchronized 不需要手动获取锁和释放锁，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果没有正确释放锁会造成死锁。</p>
</li>
<li><p>ReentrantLock 比 synchronized 增加了一些高级功能。</p>
<ul>
<li>等待可中断：可以设置线程等待锁的时间，超时可以放弃等待处理其他事情</li>
<li>synchronized 是非公平锁，ReentrantLock 可以指定是公平锁还是非公平锁。所谓的公平锁就是先等待的线程先获得锁。默认情况是非公平的，可以通过类的构造方法来设置。</li>
<li><strong>可实现选择性通知</strong>: 一个锁可以绑定多个 Condition 对象，对特定的 Condition 对象调用 .signal()，可以指定唤醒等待在该  Condition 对象上的线程。而 synchronized，只能对锁对象，如 this，调用 this.notifyAll()，唤醒绑定该锁的所有线程，无法选择具体唤醒的线程。</li>
</ul>
</li>
</ul>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile 保证可见性和有序性。</p>
<p>可见性：每次更新到主存，从主存读取</p>
<p>有序性</p>
<p>涉及到 volatile 的代码才能防止重排列（代码等价于多条指令，从指令的角度防止）</p>
<p>uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS 全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent 包中的原子类就是通过 CAS 来实现了乐观锁。</p>
<p>它是一条 CPU 同步原语。是一种硬件对并发的支持（<strong>通过硬件来实现执行的原子性</strong>）</p>
<p>CAS 算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值 V。</li>
<li>进行比较的值 A。</li>
<li>要写入的新值 B。</li>
</ul>
<p>当且仅当 V 的值等于 A 时，用新值 B 来更新 V 的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作（自旋）。</p>
<h2 id="CAS-存在的问题"><a href="#CAS-存在的问题" class="headerlink" title="CAS 存在的问题"></a>CAS 存在的问题</h2><p>CAS虽然很高效，但是它也存在三大问题：</p>
<ul>
<li><p>ABA 问题。CAS 需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是 A，后来变成了 B，然后又变成了 A，那么CAS 进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA 问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p>
<blockquote>
<p>JDK 从 1.5 开始提供了 AtomicStampedReference 类来解决 ABA 问题，具体操作封装在compareAndSet() 中。compareAndSet() 首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</p>
</blockquote>
</li>
<li><p><strong>循环时间长开销大</strong>。CAS 操作如果长时间不成功，会导致其一直自旋，给 CPU 带来非常大的开销。 可以采用适应性自旋，控制自旋时间。</p>
</li>
<li><p>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p>
<blockquote>
<p> Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>
</blockquote>
</li>
</ul>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal，即线程本地变量。如果你创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题（不再是共享变量）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建一个ThreadLocal变量</span><br><span class="line">// 注意用 static 修饰，但是使用的时候却不是共享变量</span><br><span class="line">static ThreadLocal&lt;T&gt;localVariable=new ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p>每个线程都有一个 Thread.ThreadLocalMap 类的成员变量，该变量内部维护了 Entry 数组，key 是 ThreadLocal对象的引用，value是 ThreadLocal 对象的值。</p>
<p>每个线程在访问 ThreadLocal 的时候，都是访问自己的 ThreadLocalMap 里的键值对。也就是，根据 ThreadLocal 对象的引用，以此作为 key，查找自己的 Entry 数组那个键值对。</p>
<p><img src="/2022/04/07/Java-Concurrency/1647934439309-8240096e-733c-4245-a388-d25be535f9e2.png" alt="ThreadLocal 原理图"></p>
<h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用</p>
<blockquote>
<p>弱引用：只要垃圾回收机制一运行，不管 JVM 的内存空间是否充足，都会回收该对象占用的内存。</p>
</blockquote>
<p>弱引用比较容易被回收。因此，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是因为ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：</p>
<p>ThreadLocalMap的key没了，value还在，这就会「造成了内存泄漏问题」。</p>
<p>如何「解决内存泄漏问题」？使用完ThreadLocal后，及时调用remove()方法释放内存空间</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>使用线程池的好处</strong></p>
<ul>
<li><p>降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
</ul>
<h2 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h2><p><strong>corePoolSize</strong>：最小可以同时运行的线程数量。</p>
<p><strong>workQueue</strong>：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。工作队列即阻塞队列。</p>
<p><strong>maximumPoolSize</strong>：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</p>
<p><strong>defaultHandler</strong>：饱和策略。如果阻塞队列已满，且当前线程数&gt;=maximumPoolSize，执行饱和策略</p>
<ul>
<li>AbortPolicy ： 线程任务丢弃并报错。默认饱和策略。</li>
<li>DiscardPolicy ： 线程任务直接丢弃不报错。</li>
<li>DiscardOldestPolicy ： 将 workQueue 队首任务丢弃，将最新线程任务重新加入队列执行。</li>
<li>CallerRunsPolicy ：线程池之外的线程直接调用 run 方法执行。</li>
</ul>
<h2 id="线程池大小如何设置"><a href="#线程池大小如何设置" class="headerlink" title="线程池大小如何设置"></a>线程池大小如何设置</h2><p>CPU密集型任务（N+1）：这种任务消耗的主要是CPU资源，可以将线程数设置为 N（CPU核心数）+1，多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU的空闲时间。</p>
<p>I/O密集型任务（2N）：线程进行 I/O 时需要等待 IO 结果，等待的时间内无法做其他事情，这时就可以将 CPU 交出给其它线程使用。</p>
<h2 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h2><ul>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO,LIFO,优先级）执行。</li>
</ul>
<h2 id="execute-和-submit-比较"><a href="#execute-和-submit-比较" class="headerlink" title="execute() 和 submit() 比较"></a>execute() 和 submit() 比较</h2><p>execute() 用于提交不需要返回值的任务，所以无法判断任务是否被线程池成功执行；</p>
<p>submit() 用于提交需要返回值的任务。线程池会返回一个Future 对象，表示异步计算的结果。通过这个对象可以判断任务是否执行成功，并且可以通过 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，get() 也可以设置阻塞时间，在一定时间后立即返回，这时候有可能任务没有执行完。</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS 底层是由同步队列 + 条件队列联手组成，同步队列管理着获取不到锁的线程的排队和释放，<br>条件队列是在一定场景下，对同步队列的补充，比如获得锁的线程从空队列中拿数据，肯定是拿不<br>到数据的，这时候条件队列就会管理该线程，使该线程阻塞</p>
<p>个人认为，是monitor在 API 层面的映射</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 集合</title>
    <url>/2022/04/02/Java-Data-Structure/</url>
    <content><![CDATA[<p>Java 集合类主要由两个根接口 Collection 和 Map 派生出来，Collection派生出了三个子接口：List、Set、Queue，因此 Java 集合大致也可分成 List、Set、Queue、Map 四种接口体系。</p>
<span id="more"></span>
<blockquote>
<p>Collection 是一个接口，Collections 是一个工具类。</p>
</blockquote>
<p><img src="/2022/04/02/Java-Data-Structure/image-20220402130636222.png" alt></p>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList 与 LinkedList 比较</p>
<ul>
<li>是否保证线程安全：都不保证线程安全；</li>
<li>底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是双向链表；</li>
<li>插入和删除： O(N) 和 O(1)</li>
<li>是否支持快速随机访问： 快速随机访问就是通过元素的索引访问</li>
<li>内存空间占用： ArrayList 的空间浪费主要体现在结尾会预留一定的空间，而 LinkedList 的空间花费则体现在每一个元素除了值还要存放 prev、next</li>
</ul>
<p>ArrayList 与 Vector 比较</p>
<ul>
<li>Vector 是线程安全的，方法前面加了 synchronized 关键字</li>
<li>ArrayList 的扩容倍数为 1.5，Vector 是扩展 2 倍（多线程环境，扩得更大点）</li>
</ul>
<p>ArrayList 和 Array（数组）比较</p>
<ul>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型（Integer 而非 int）。</li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等</li>
</ul>
<p>ArrayList 的扩容机制</p>
<p>计算出新的扩容数组的大小后创建新数组，并将原有数组内容复制到新数组中去。默认情况下，新的容量会是原容量的1.5倍。</p>
<blockquote>
<p>1.5 倍：int newCapacity = oldCapacity+ (oldCapacity&gt;&gt;1);</p>
</blockquote>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="解决-hash-冲突的方法"><a href="#解决-hash-冲突的方法" class="headerlink" title="解决 hash 冲突的方法"></a>解决 hash 冲突的方法</h2><p>开放定址法、再哈希法、拉链法、建立公共溢出区</p>
<p>开放定址法就是一旦发生了冲突，就去寻找下一个<strong>空的</strong>散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>
<ul>
<li><p>优点：如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的</p>
</li>
<li><p>缺点： </p>
<ul>
<li>一旦发生了冲突，就去寻找下一个<strong>空的</strong>散列地址，这要求存储记录的数目不能超过桶数组的长度。</li>
<li>删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。</li>
</ul>
</li>
</ul>
<p>再哈希法（多重散列），提供多个不同的 hash 函数，当 R1=H1(key1) 发生冲突时，再计算 R2=H2(key1) ，直到没有冲突为止。 多次哈希，计算哈希值的时间成本较高</p>
<p>拉链法，将哈希值相同的元素构成一个单链表</p>
<p>建立公共溢出区，将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>
<h2 id="HashMap-数据结构"><a href="#HashMap-数据结构" class="headerlink" title="HashMap 数据结构"></a>HashMap 数据结构</h2><p>在 JDK1.7 中，由“数组+链表”组成；在 JDK1.8 中，由“数组+链表+红黑树”组成</p>
<h3 id="JDK1-8-HashEntry-数据结构"><a href="#JDK1-8-HashEntry-数据结构" class="headerlink" title="JDK1.8 HashEntry 数据结构"></a>JDK1.8 HashEntry 数据结构</h3><h4 id="链表转化为红黑树的时机"><a href="#链表转化为红黑树的时机" class="headerlink" title="链表转化为红黑树的时机"></a>链表转化为红黑树的时机</h4><p>是扩容，还是将链表转化为红黑树，实际考察点有两个：</p>
<ul>
<li>扩容操作和转化为红黑树操作的效率</li>
<li>扩容后重新哈希，可以缩小链表长度，增加搜索效率；转化为红黑树，增加搜索效率</li>
</ul>
<p>当链表长度超过 8，</p>
<ul>
<li>如果当前数组的长度小于 64，进行数组扩容，尝试通过扩容来<strong>缩小链表长度</strong>，而不是转换为红黑树，以<strong>减少搜索时间</strong>。</li>
<li>如果数组的长度超过 64，转链表为红黑树。之所以这个时候不使用扩容，是因为元素多，扩容操作效率低。</li>
</ul>
<h4 id="为什么不直接使用红黑树-为什么以-8-为阈值"><a href="#为什么不直接使用红黑树-为什么以-8-为阈值" class="headerlink" title="为什么不直接使用红黑树/为什么以 8 为阈值"></a>为什么不直接使用红黑树/为什么以 8 为阈值</h4><p>红黑树的插入操作复杂，需要使用旋转、变色等操作，比链表的插入操作更复杂、效率更低。</p>
<p>比较插入操作的效率和查找操作的效率，进行权衡</p>
<ul>
<li><p>当元素个数小于 8 时，对于查找操作，链表的 O(N) 已经能够满足查询要求，即使用红黑树，提升也不大，然而却会导致插入元素时的效率降低。</p>
</li>
<li><p>当元素个数大于 8 时，虽然红黑树导致插入效率降低的问题，但是与其对查找操作的提升相比，影响不大。</p>
</li>
</ul>
<h4 id="负载因子为什么是-0-75"><a href="#负载因子为什么是-0-75" class="headerlink" title="负载因子为什么是 0.75"></a>负载因子为什么是 0.75</h4><p>0.75 的含义表示当 HashMap 的容量达到总容量的 75% 时 HashMap 会进行扩容</p>
<blockquote>
<p>数组初始化长度 length 默认值是 16，负载因子（Load factor）默认值是 0.75，threshold 是 HashMap 所能容纳键值对的最大个数，threshold = length * Load factor</p>
</blockquote>
<p>从<strong>哈希冲突</strong>和<strong>空间利用率</strong>两个方面考虑：</p>
<ul>
<li><p>负载因子过大，例如将负载因子设置成 1，HashMap 的必须要全部装满才扩容，导致大量的哈希冲突，这时候 put 和 get 操作效率就会低下。（链表，头插的话不影响 put，get 可能导致遍历链表搜素，总会被影响）</p>
</li>
<li><p>负载因子过小，例如将负载因子设置成 0.5，HashMap 的容量达到 50% 就会进行扩容，这样虽然能减少哈希冲突的概率，但是会存在还有一半的空间没有被使用到，造成空间的利用率低下。</p>
</li>
</ul>
<h3 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h3><h4 id="数组索引值计算"><a href="#数组索引值计算" class="headerlink" title="数组索引值计算"></a>数组索引值计算</h4><p>对于 (key, value)，先得到 key 的 hashCode 值，然后根据 hashcode 计算出 hash 值（HashMap的hash 方法），最后通过 hash&amp;(length-1) 计算存储索引</p>
<p><strong>jdk 1.8 的 hash 方法</strong></p>
<p>hash = hashCode ^ (hashCode &gt;&gt;&gt; 16);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移（区别于&gt;&gt;），忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/02/Java-Data-Structure/image-20220402133450860.png" alt="jdk1.8 hash方法示意"></p>
<p><strong>索引计算方法</strong></p>
<p>hash 值的范围是 int 的范围，将 hash 和数组的长度取余运算，得到的余数才是用来要存放的位置也就是对应的数组下标。</p>
<p><strong>证明：hash % n = hash &amp; (n-1)，n 为 2 的幂次方</strong></p>
<p>如果除数是 2 的 k 次，根据除法运算求余，余数即 hash 的低 k 位，因此余数等于 hash &amp; 低 k 位全为 1 的二进制数，即余数 = hash &amp; (n-1)。</p>
<p><strong>将求余运算转化为与运算，不需要做除法，提高效率</strong></p>
<blockquote>
<p>若除数不是 2 的幂次，却仍然用 &amp; 运算代替 %，则会出现更多的哈希碰撞</p>
<p>容量是2的整数次幂，n -1 后，高位为1后的0都变为1，如 16：10000, 16-1=15：1111, 1111 再与 hash 做 &amp; 运算的时候，各个位置的取值取决于 hash；如果不是2的整数次幂，必然会有更多0的位，0与任何数&amp;肯定为0，会造成更多的哈希冲突  </p>
</blockquote>
<h4 id="HashMap-的-put-方法"><a href="#HashMap-的-put-方法" class="headerlink" title="HashMap 的 put 方法"></a>HashMap 的 put 方法</h4><p>以 jdk1.8为例，简要流程如下：</p>
<ol>
<li>首先根据计算 (key, value) 的数组索引；</li>
<li>如果数组是空的，则调用 resize 进行初始化；</li>
<li>如果没有哈希冲突，直接放在对应的数组下标里；</li>
<li>如果有哈希冲突：<ul>
<li>如果 key 已经存在，就覆盖掉 value；（哈希冲突，哈希值相同，索引位置相同，key已经存在，指的是键值 key 已经存在，调用的是 equals 方法）</li>
<li>如果 key 不存在，需要插入键值对。<ul>
<li>如果该节点是链表，插入节点到链表中，插入节点后判断是否要将链表转化为红黑树</li>
<li>如果该节点是红黑树，插入节点到红黑树中；</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="HashMap-的-resize-方法（扩容）"><a href="#HashMap-的-resize-方法（扩容）" class="headerlink" title="HashMap 的 resize 方法（扩容）"></a>HashMap 的 resize 方法（扩容）</h4><p>HashMap 在容量达到 threshold 之后，就会扩容，调用 void resize(int new Capacity)。方法是创建新数组，新数组大小为原数组的两倍，并将原来的对象放入新的数组中。</p>
<p><strong>jdk 1.7</strong></p>
<ol>
<li>新建一个大小为原来两倍的数组，resize() 入参 newCapacity=2*oldCapacity</li>
<li>resize() 内部调用 transfer() 方法将原有 Entry 数组的元素拷贝到新的 Entry 数组里：<ol>
<li>遍历旧数组，对每个数组元素（链表，还会继续遍历）重新计算索引值（哈希值不需要重新计算，扩容只会改变数组大小，进而改变索引值，而哈希值不变）</li>
<li>释放旧数组元素，对于链表，即令数组元素为 null，然后把元素插入到新的数组中，对于链表采用头插法链表：直接插入。</li>
</ol>
</li>
</ol>
<blockquote>
<p>jdk1.8 中，元素转移时、先形成链表，插入链表的时候再判断要不要转成红黑树</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">        Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];             </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                src[j] = <span class="literal">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再</span></span><br><span class="line">引用任何对象）</span><br><span class="line">				<span class="comment">// 遍历链表，并移动链表元素</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity); <span class="comment">//重新计算每个元素在数</span></span><br><span class="line">组中的位置</span><br><span class="line">                    e.next = newTable[i]; <span class="comment">// 注意，newTable[i]初值为 null</span></span><br><span class="line">                    newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                    e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>假设一开始的链表为：1 -&gt; 2 -&gt; 3 -&gt; null，则移动之后变为：3 -&gt; 2 -&gt; 1 -&gt; null</strong></p>
<hr>
<p><strong>jdk 1.8</strong></p>
<ol>
<li><p>采用<strong>尾插法</strong>而不是头插法，避免环形链表的问题</p>
</li>
<li><p>重新计算索引值的方法：索引不变，或者原来的索引 + oldCap (oldCap = 原来哈希表的长度，即oldCapacity），不通过 hash&amp;(n-1) 重新计算索引值</p>
<p> 对于一个链表，可以直接生成两个链表，一个链表是扩容后仍处于原索引的元素构成的链表，另一个链表是扩容后处于原索引 + oldCap 的元素构成的链表，然后把这两个链表放到新数组的对应位置。</p>
<p> 根据 e.hash &amp; oldCap == 0 来判断新的索引值</p>
</li>
</ol>
<p><strong>扩容后，索引值计算方法</strong></p>
<p>由于扩容后数组大小是原来的两倍，因此有如下计算特性：</p>
<p><img src="/2022/04/02/Java-Data-Structure/image-20220402142910110.png" alt="扩容前后索引值的计算"></p>
<p>图中，a 是扩容前的哈希值和索引值，b 是扩容后的哈希值和索引值。可以看到，扩容不影响哈希值，只影响索引值，且只会对最高位产生影响（高位多一个1，或者仍为0）。<br>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 在高位多 1 bit，因此图中新的索引值就发生这样的变化：</p>
<p><img src="/2022/04/02/Java-Data-Structure/image-20220402142926082.png" alt></p>
<h2 id="HashMap-线程安全问题"><a href="#HashMap-线程安全问题" class="headerlink" title="HashMap 线程安全问题"></a>HashMap 线程安全问题</h2><p>HashMap 线程不安全，会导致的问题有：</p>
<ul>
<li><p>多线程下扩容死循环。JDK1.7 中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</p>
</li>
<li><p>多线程的 put 可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。</p>
</li>
<li>put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，如果导致扩容调用了 resize()，线程2此时执行 get，有可能导致这个问题。（resize() 时，原来哈希表的引用会被释放，即指向空）</li>
</ul>
<h2 id="HashMap-键的选择"><a href="#HashMap-键的选择" class="headerlink" title="HashMap 键的选择"></a>HashMap 键的选择</h2><p>要求作为 key 的类规范地重写了 hashCode() 以及 equals() 方法。（hashCode 求hash值，equals 判断key是否相同）</p>
<p>一般用 Integer、String 这种不可变类当 HashMap 的 key<br>String 最为常用。因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。</p>
<h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><p>对于分布式存储，不同服务器上存储不同的数据，假如用 HashMap 的方法，将机器线性编号，然后计算索引：</p>
<p><code>hash(key) &amp; (n-1)</code></p>
<p>将数据映射到服务器上。那么，当我们想要添加一台服务器或者删除一台服务器，需要扫描整个哈希表，对所有数据重新计算其索引位置。（这是因为数组大小改变了，因此索引的计算式也改变了）。</p>
<p>于是，提出了一致性哈希算法来避免分布式系统在扩容或者缩容时，发生过多的数据迁移。它可以保证当机器增加或者减少时，节点之间的数据迁移只限于两个节点之间。</p>
<h2 id="哈希环"><a href="#哈希环" class="headerlink" title="哈希环"></a>哈希环</h2><p>想象一个环形数组，它的大小固定为 2^32。</p>
<p>一致性哈希算法需要进行两次哈希计算：</p>
<ul>
<li><p>一：将数据 (key, value) 和服务器都映射到哈希环上，称为数据节点和服务器节点。映射方法仍旧为：</p>
<p>  <code>hash(key) &amp; (n-1)</code></p>
<p>  只不过数组大小始终为 2^32。</p>
<blockquote>
<p>为什么一致性哈希值空间是 2^32？ 因为一致性 hash 算法是来做服务器的负载均衡，而服务器的 IP 地址是32 位（0~2^32-1），需要 2^32 大小的数值空间.</p>
<p>哈希环的原理图一个隐含的限制是：服务器节点不能映射到哈希环的同一个位置，数据节点无所谓。因此，服务器由 IP 地址区分，一共有 2^32 种可能，需要 2^32 个位置。</p>
</blockquote>
</li>
<li><p>二：将哈希环上的数据节点映射到服务器节点上，映射方法是，从数据节点所在位置往顺时针方向找到的第一个服务器节点。</p>
</li>
</ul>
<p><img src="/2022/04/02/Java-Data-Structure/image-20220414095309299.png" alt="哈希环"></p>
<p>上图中，数据节点 key-1、key-2 和 key-3 分别映射到服务器节点 A、B、C 上。</p>
<h2 id="增加或减少一个服务器节点"><a href="#增加或减少一个服务器节点" class="headerlink" title="增加或减少一个服务器节点"></a>增加或减少一个服务器节点</h2><p>一致哈希算法可以保证当机器增加或者减少时，节点之间的数据迁移只限于两个节点之间。</p>
<p>例如，假设服务器节点数量从 3 增加到了 4，新的服务器节点 D 经过哈希计算后映射到了下图中的位置：</p>
<p><img src="/2022/04/02/Java-Data-Structure/image-20220414095637614.png" alt></p>
<p>可见，只有 key-2 （原来在节点 A 到节点 B 顺时针方向上的数据节点）需要被迁移到节点 D。</p>
<p>假设节点数量从 3 减少到了 2，比如将节点 A 移除：</p>
<p><img src="/2022/04/02/Java-Data-Structure/image-20220414095941690.png" alt></p>
<p>可见，只有 key-1 （原来在节点 C 到节点 A 顺时针方向上的数据节点）需要被迁移到节点 B。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><strong>一致性哈希算法并不保证节点能够在哈希环上分布均匀</strong>，可能导致有大量的请求集中在一个节点上。</p>
<p>例如，下图中 3 个节点的映射位置都在哈希环的右半边：</p>
<p><img src="/2022/04/02/Java-Data-Structure/640.png" alt style="zoom:80%;"></p>
<p>这时候有一半以上的数据的寻址都会找节点 A，即访问请求主要集中在节点 A 上。</p>
<blockquote>
<p>如果仍旧用 HashMap 的模型，负载均衡的问题，实际上就是哈希冲突是否均匀的问题。通常来说，不会出现绝大多数节点 hash(key) &amp; (n-1) 相同的情况。</p>
</blockquote>
<h3 id="虚拟节点实现负载均衡"><a href="#虚拟节点实现负载均衡" class="headerlink" title="虚拟节点实现负载均衡"></a>虚拟节点实现负载均衡</h3><p>让虚拟的服务器节点在哈希环上均匀分布，并等比例（每个实际节点有相同个数的虚拟节点）地映射到实际的服务器节点上。</p>
<p>比如对每个节点分别设置 3 个虚拟节点：</p>
<ul>
<li>节点 A 的虚拟节点：A-01、A-02、A-03</li>
<li>节点 B 的虚拟节点：B-01、B-02、B-03</li>
<li>节点 C 的虚拟节点：C-01、C-02、C-03</li>
</ul>
<p>并且，这 9 个虚拟节点在哈希环上均匀分布：</p>
<p><img src="/2022/04/02/Java-Data-Structure/640-16499026936018.png" alt style="zoom:80%;"></p>
<p>虚拟节点在哈希环上均匀分布：注意到是按照 A、B、C 方式分布的，如果把任意两个虚拟节点放在了一起，那么实际上它们会等效为一个虚拟节点，导致不均匀分布。</p>
<p>例如，上图中，替换 B-01 和 A-02 的位置，虚拟节点等效过后，实际上只留下了 A：2个虚拟节点、B：2个虚拟节点、C：3个虚拟节点。</p>
<p>当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。</p>
<h1 id="bloom-过滤器"><a href="#bloom-过滤器" class="headerlink" title="bloom 过滤器"></a>bloom 过滤器</h1><p>特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”</p>
<p>布隆过滤器的实现原理是用多个哈希函数，将一个数据映射到位图中，通过位图来判断元素是否存在。</p>
<p>它具有运行速度快（时间效率），占用内存小的优点（空间效率）的优点，但是有一定的误识别率和删除困难的问题。它能够告诉你某个元素一定不在集合内或可能在集合内。</p>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><ol>
<li>使用多个哈希函数对元素值进行计算，得到多个哈希值</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>可能出现哈希冲突的情况：</p>
<p><img src="/2022/04/02/Java-Data-Structure/20220318143436146.png" alt="image-20220311154805364"></p>
<p>当存在哈希冲突的情况下，假设 x 的哈希值为 h1, h2, h3，且发现 bitmap[h1] = bitmap[h2] = bitmap[h3] = 1，x不一定存在于数据库中。</p>
<p>可以适当增加位数组大小或者调整我们的哈希函数来降低概率</p>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>对于有哈希冲突的情况，如果直接将待删除元素的各个 bitmap[hi] 置 0，会导致其他元素的信息丢失。</p>
<p>如果让每个位存储被置 1 的次数，可能存在其他问题，例如溢出导致计数值是错的。</p>
<h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><p>主要用来判断 非条件，即不存在的条件。假设哈希冲突比较少，判断存在也不错。</p>
<p>布隆过滤器的查找操作是 <strong>可能</strong>在集合中：</p>
<p>将要查询的元素给k个哈希函数</p>
<p>得到对应于位数组上的k个位置</p>
<p>如果k个位置有一个为0，则一定不在集合中</p>
<p>如果k个位置全部为1，则可能在集合中</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>与哈希表相比，它并不能解决哈希冲突的问题，不能保证查找操作为 true positive。</p>
<p>在数据量极大的情况下，使用 HashMap 会遇到哈希冲突过多的问题，这会导致 HashMap 的查找时间复杂度恶化，不再是常数</p>
<p>常用的数据结构，如hashmap，set，bit array都能用来测试一个元素是否存在于一个集合中，相对于这些数据结构，BloomFilter有什么方面的优势呢？</p>
<p>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p>
<p>位图：N个元素，范围 min,max 需要 max-min+1 个位，存在性是绝对的</p>
<p>32位机器上，对于一个整型数，比如<code>int a = 1</code> 在内存中占<code>32 bit</code>位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费，因为我们可以用对应的<code>32 bit</code>位对应存储十进制的<code>0 - 31</code>个数，而这就是<code>Bit-map</code>的基本思想</p>
<ul>
<li>相对于hashmap和set，BloomFilter在返回元素可能存在的情况中，有一定的误判率，这时候，调用者在误判的时候，会做一些不必要的工作，而对于hashmap和set，不会存在误判情况</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>给两个文件，分别有100亿个query，我们只有1G内存，如何找到两个文件交集？分别给出精确算法和近似算法？<br>思路：精确算法利用位图来实现。100个query，通常是线性递增一个请求索引<br>近似算法利用布隆过滤器实现，将一个文件的中100亿个query放在一个布隆过滤器中，另个一个文件中的数据到布隆过滤器中去查找，若查找到则说明是这两个文件的交集。</p>
<p>大数据场景下判断数据是否存在</p>
<ol>
<li>网页爬虫对URL的去重，避免爬取相同的URL地址</li>
<li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</li>
<li>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</li>
</ol>
<h3 id="布隆过滤器误判率表"><a href="#布隆过滤器误判率表" class="headerlink" title="布隆过滤器误判率表"></a><strong>布隆过滤器误判率表</strong></h3><p><img src="/2022/04/02/Java-Data-Structure/SouthEast.png" alt></p>
<p>需要判重的网页有 10 亿，那我们可以用一个 10 倍大小的位图来存储，也就是 100 亿个二进制位，换算成字节，那就是大约 1.2GB。之前我们用散列表判重，设每个 URL 平均长度为 64 字节，需要至少 100GB 的空间。相比来讲，布隆过滤器在存储空间的消耗上，降低了非常多。</p>
<p>假设一个 URL 的平均长度是 64 字节，那单纯存储这 10 亿个 URL，需要大约 60GB 的内存空间。因为散列表必须维持较小的装载因子，才能保证不会出现过多的散列冲突，导致操作的性能下降。而且，用链表法解决冲突的散列表，还会存储链表指针。所以，如果将这 10 亿个 URL 构建成散列表，那需要的内存空间会远大于 60GB，有可能会超过 100GB。</p>
<p>如何选择哈希函数个数和布隆过滤器长度：<br>如果一个数据要映射多个位置，如果布隆过滤器较小，则会导致数据马上全部映射满，此时无论进行什么操作，都会存在大量的误报率。也就是说，布隆过滤器的长度与误报率成反比，与空间利用率成反比<br>哈希函数的个数也值得思考，哈希函数越多，映射的位置也就越多，此时准确性也就越高，但随之带来的问题就是效率的降低。也就是说，哈希函数的个数与效率成反比，准确率成正比</p>
<p>k = hash函数个数</p>
<p>n = 数据量大小。如：现有一个100万文件的文件夹，我手中有一个文件不知道这个文件夹中是否有这个文件，如果没有就放进去，有的话我再另外处理。此时n则是100万</p>
<p>m = 位数组长度。如上上面经过hash计算的值是小于一个最大值的，这个最大值则是这个位数组的长度。</p>
<p>r=m/n</p>
<p>p = 布隆过滤器正确率</p>
<p><img src="/2022/04/02/Java-Data-Structure/image-20220424160831946.png" alt="image-20220424160831946"></p>
<p>也就是说，如果数据量为100万，那么位数组长度需要700万才能保证使用5个hash函数时误判率小于5%。700万位，约等于875kb。如果一个文件只有1k大小，总大小也将近1G了。通过布隆过滤器，只需要875k的内存大小便能快速判断某个文件是否在这个文件夹中，且准确率高达96.8%。</p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="ConcurrentHashMap-数据结构"><a href="#ConcurrentHashMap-数据结构" class="headerlink" title="ConcurrentHashMap 数据结构"></a>ConcurrentHashMap 数据结构</h2><h3 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p>由  Segment  数组组成，Segment 数组每个元素是一个  HashEntry  数组（与 jdk1.7 HashMap 结构相同，数组+链表）。</p>
<p>Segment 继承了 ReentrantLock</p>
<p>每一个 HashEntry  数组可以进行扩容。但是 Segment 的个数一旦初始化就不能改变，默认 Segment 的个数是 16 个，也就是说 ConcurrentHashMap 默认支持最多 16 个线程并发</p>
<p>get</p>
<p>定位一个元素的过程需要进行两次 Hash 操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。</p>
<p>Hash 的过程要比普通的 HashMap 要长</p>
<p>put</p>
<p>写操作的时候只对元素所在的Segment进行加锁即可，不会影响到其他的Segment</p>
<h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p>由 HashEntry 数组组成，结构上与 jdk1.8 的 HashMap 实际上是相同的。</p>
<p>在锁的实现上，抛弃了原有的 Segment 分段锁，采用 CAS + synchronized 实现更加低粒度的锁，锁对象是链表的头节点/红黑树的根节点。</p>
<h2 id="ConcurrentHashMap-源码分析"><a href="#ConcurrentHashMap-源码分析" class="headerlink" title="ConcurrentHashMap 源码分析"></a>ConcurrentHashMap 源码分析</h2><h3 id="jdk1-7-1"><a href="#jdk1-7-1" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><h4 id="参数分析"><a href="#参数分析" class="headerlink" title="参数分析"></a>参数分析</h4><p>ssize 表示 Segment 数组大小，ssize 默认值 16，ssize 保证为 2 的幂次方，因为它满足</p>
<script type="math/tex; mode=display">
ssize=2^{sshift}</script><p>cap 表示 Segment 元素，即每个 HashEntry 数组的容量。cap 保证为 2 的幂次方，且 cap 满足</p>
<script type="math/tex; mode=display">
cap\geq  \lceil \frac{initialCapacity}{ssize} \rceil</script><h4 id="数组索引值计算-1"><a href="#数组索引值计算-1" class="headerlink" title="数组索引值计算"></a>数组索引值计算</h4><p>jdk1.7 中，需要进行两次哈希映射。第一次是找到 Segment 数组的索引，第二次是找到 HashEntry 数组的索引。</p>
<p>首先，计算 hash = hash(key)</p>
<p>Segment 数组的索引为 j &lt;&lt; SSHIFT</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; <span class="comment">// j 的范围是 0 ~ ssize-1</span></span><br><span class="line"><span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (j &lt;&lt; SSHIFT) + SBASE; <span class="comment">// SBASE 位置对应 Segment[0]，这么写的是因为 UNSAFE.getObject() 传参是基于偏移量的</span></span><br></pre></td></tr></table></figure>
<p>HashEntry 数组的索引仍旧为 hash % (数组大小 - 1)</p>
<p>假设 Segment 数组的大小是 16，为什么不同样地使用 hash%15 作为 Segment 数组的索引位置呢？这是为了减少哈希冲突。使用不同的哈希函数，这样的话，当 HashEntry 数组索引相同，它所在的 Segment 数组索引不一定相同，也就是把两个本应该冲突的元素分开了。</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><p>ensureSegment() 不加锁，创建 Segment 元素的时候使用自旋+ CAS 方式创建</p>
<p>定位到 Segment 元素之后，对 HashEntry 数组添加元素的时候需要加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果成功获取锁，返回 null，获取不到就使用 scanAndLockForPut 方法继续获取。</span></span><br><span class="line">HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> : scanAndLockForPut(key, hash, value);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tryLock 不会阻塞，抢锁成功就返回 true，失败就立马返回 false，<br>lock 抢锁成功则返回，失败则会进入同步队列，阻塞等待获取锁。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 基础知识</title>
    <url>/2022/04/17/Java-basis/</url>
    <content><![CDATA[<p>Java 模运算，当被除数为负数时取模结果为负数，需要纠正，因此：</p>
<p>(preSum % k + k) % k = Math.floorMod(preSum, k)</p>
<p> <img src="/2022/04/17/Java-basis/image-20220417193828072.png" alt="image-20220417193828072"></p>
<p>关于 % 和 Math.floorMod，前者是取余运算，后者是取模运算</p>
<p>​                               </p>
<p>取模运算，在求a/b的时候是把结果向下取整。取余运算，在求a/b的时候是把结果向0取整</p>
<p>因此，当商为正数的时候，%等价于floorMod，但是当商为负数的时候，%就不能代替floorMod了</p>
<p>Java 语言使用 final 关键字来定义一个常量</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 多线程基础实践</title>
    <url>/2022/04/05/JavaPractice/</url>
    <content><![CDATA[<p>Java 多线程基础实践</p>
<span id="more"></span>
<h1 id="多线程共享变量"><a href="#多线程共享变量" class="headerlink" title="多线程共享变量"></a>多线程共享变量</h1><p>在多线程访问共享对象和数据时候大致可以分为两大类。</p>
<p>1：如果每个线程执行的代码相同，可以使用同一个runnable对象，这个runnable对象中有共享变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MulteThreadlShareData</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShareData</span> <span class="variable">shareData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(shareData).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(shareData).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ShareData</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 这里可能有多个线程同时到达</span></span><br><span class="line">            	<span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            		<span class="keyword">if</span>(count == <span class="number">0</span>) <span class="comment">// 如果多个线程进入 while，保证这里的 count 一定是正数</span></span><br><span class="line">                    	<span class="keyword">break</span>;</span><br><span class="line">            		count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;this count: &quot;</span>+count); </span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果每个线程对一个共享变量执行的操作不同，这时候需要用不同的Runnable对象。</p>
<ul>
<li>将共享数据封装成一个对象，然后将这个对象传递给各个Runnable对象</li>
<li><p>将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。</p>
<p>例：银行存取款</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acount</span> &#123;</span><br><span class="line"> </span><br><span class="line">	 <span class="keyword">private</span> <span class="type">int</span> money;</span><br><span class="line">	 <span class="keyword">public</span> <span class="title function_">Acount</span><span class="params">(<span class="type">int</span> money)</span>&#123;</span><br><span class="line">	   <span class="built_in">this</span>.money=money;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getMoney</span><span class="params">(<span class="type">int</span> money)</span>&#123;</span><br><span class="line">	  <span class="keyword">while</span>(<span class="built_in">this</span>.money&lt;money)&#123;		  </span><br><span class="line">		   System.out.println(<span class="string">&quot;取款：&quot;</span>+money+<span class="string">&quot; 余额：&quot;</span>+<span class="built_in">this</span>.money+<span class="string">&quot; 余额不足，正在等待存款......&quot;</span>);</span><br><span class="line">		   <span class="keyword">try</span>&#123; wait();&#125; <span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="built_in">this</span>.money=<span class="built_in">this</span>.money-money;</span><br><span class="line">	  System.out.println(<span class="string">&quot;取出：&quot;</span>+money+<span class="string">&quot; 还剩余：&quot;</span>+<span class="built_in">this</span>.money);</span><br><span class="line">	 </span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">int</span> money)</span>&#123;</span><br><span class="line">	 </span><br><span class="line">	  <span class="keyword">try</span>&#123; Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">	  <span class="built_in">this</span>.money=<span class="built_in">this</span>.money+money;</span><br><span class="line">	  System.out.println(<span class="string">&quot;新存入：&quot;</span>+money+<span class="string">&quot; 共计：&quot;</span>+<span class="built_in">this</span>.money);</span><br><span class="line">	  notify();</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">		  Acount Acount=<span class="keyword">new</span> <span class="title class_">Acount</span>(<span class="number">0</span>);</span><br><span class="line">		  Bank b=<span class="keyword">new</span> <span class="title class_">Bank</span>(Acount);</span><br><span class="line">		  Consumer c=<span class="keyword">new</span> <span class="title class_">Consumer</span>(Acount);</span><br><span class="line">		  <span class="keyword">new</span> <span class="title class_">Thread</span>(b).start();</span><br><span class="line">		  <span class="keyword">new</span> <span class="title class_">Thread</span>(c).start();</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存款类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">		Acount Acount;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Bank</span><span class="params">(Acount Acount)</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.Acount=Acount;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">				 <span class="type">int</span> temp=(<span class="type">int</span>)(Math.random()*<span class="number">1000</span>);</span><br><span class="line">				 Acount.setMoney(temp);	 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取款类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">		Acount Acount;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Acount Acount)</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.Acount=Acount;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;		 </span><br><span class="line">			<span class="type">int</span> temp=(<span class="type">int</span>)(Math.random()*<span class="number">1000</span>);</span><br><span class="line">			Acount.getMoney(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多线程打印abc"><a href="#多线程打印abc" class="headerlink" title="多线程打印abc"></a>多线程打印abc</h1><p>3个线程循环打印ABC，其中A打印3次，B打印2次，C打印1次，循环打印2轮</p>
<p>print 对象中的 num 作为条件变量，决定哪个线程被唤醒。</p>
<p>下面的count是否要改成volatile?</p>
<p>由于对print对象加锁，因此由Synchronized 和 ReentrantLock 保证了print对象，包括它的count属性的可见性</p>
<h2 id="1-Synchronized"><a href="#1-Synchronized" class="headerlink" title="1 Synchronized"></a>1 Synchronized</h2><h3 id="1-1-互斥"><a href="#1-1-互斥" class="headerlink" title="1.1 互斥"></a>1.1 互斥</h3><p>如果只执行线程A，并且改写代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前正在执行线程的标记。初值为1，让线程 A 先执行</span></span><br><span class="line">		<span class="type">ABCPrint</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ABCPrint</span>(num); <span class="comment">// print对象作为不同线程的共享变量，不同线程获取print对象的锁从而实现同步。主要包括：互斥地修改共享变量 print.num，互斥地打印</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableA</span>(print));</span><br><span class="line">		</span><br><span class="line">		threadA.start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ABCPrint print;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RunnableA</span><span class="params">(ABCPrint print)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.print = print;	</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;		</span><br><span class="line">		print.PrintA();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABCPrint</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//当前正在执行线程的标记</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ABCPrint</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 循环打印2轮</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; )&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            	System.out.println(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">                	</span><br><span class="line">                <span class="comment">//打印3次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; </span><br><span class="line">                    System.out.println(<span class="string">&quot;A&quot;</span>);  </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印A线程执行完，设置num=2，则</span></span><br><span class="line">                num = <span class="number">2</span>;  </span><br><span class="line">                </span><br><span class="line">                ++j; <span class="comment">// 注意把 ++j 移到这里</span></span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会无线输出”x”？</p>
<p>因为 j 没变！！</p>
<p>如果把++j移回for()里</p>
<p>久会输出</p>
<p>x<br>A<br>A<br>A<br>y<br>x</p>
<p>然后停止。</p>
<p>不能认为是，先获取锁，进入了同步块，然后如果num=1，就执行while，若num!=1，就离开while</p>
<p>实际上，synchronized 只是起修饰的作用。这个代码的意思是，while语句</p>
<p>注意把 ++j 移到同步块中，否则只执行一次AAABBC。这是因为？？？？</p>
<p>因为可能别的线程先运行了？</p>
<p>包括1.2的this.notifyAll()也是在同步块中，因为？？</p>
<p>从共享变量修改的角度，while可以改成if，因为只有同步块才可能修改num</p>
<p>采用互斥，需要认为地控制线程运行的顺序。无法像wait notify那样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前正在执行线程的标记。初值为1，让线程 A 先执行</span></span><br><span class="line">		<span class="type">ABCPrint</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ABCPrint</span>(num); <span class="comment">// print对象作为不同线程的共享变量，不同线程获取print对象的锁从而实现同步。主要包括：互斥地修改共享变量 print.num，互斥地打印</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableA</span>(print));</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableB</span>(print));</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableC</span>(print));</span><br><span class="line">		threadA.start();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>); <span class="comment">// 保证初始线程按照ABC的启动顺序</span></span><br><span class="line">		threadB.start();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		threadC.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ABCPrint print;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RunnableA</span><span class="params">(ABCPrint print)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.print = print;	</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;		</span><br><span class="line">		print.PrintA();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ABCPrint print;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RunnableB</span><span class="params">(ABCPrint print)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.print = print;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;		</span><br><span class="line">		print.PrintB();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableC</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ABCPrint print;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RunnableC</span><span class="params">(ABCPrint print)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.print = print;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;		</span><br><span class="line">		print.PrintC();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABCPrint</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//当前正在执行线程的标记</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ABCPrint</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 循环打印2轮</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; )&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">//打印3次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; </span><br><span class="line">                    System.out.println(<span class="string">&quot;A&quot;</span>);  </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印A线程执行完，设置num=2，则</span></span><br><span class="line">                num = <span class="number">2</span>;  </span><br><span class="line">                ++j; <span class="comment">// 注意把 ++j 移到这里</span></span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintB</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; )&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(num == <span class="number">2</span>)&#123;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123; </span><br><span class="line">                    System.out.println(<span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                num = <span class="number">3</span>;  </span><br><span class="line">                ++j; </span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintC</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; )&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(num == <span class="number">3</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">                num = <span class="number">1</span>;  </span><br><span class="line">                ++j; </span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h3 id="1-2-使用-wait-和-notify"><a href="#1-2-使用-wait-和-notify" class="headerlink" title="1.2 使用 wait() 和 notify()"></a>1.2 使用 wait() 和 notify()</h3><p>不使用 wait() 和 notify()，而仅仅使用锁进行互斥，是可以实现功能的。但是由于阻塞线程无法马上被唤醒，并不是一个实际推荐的写法。</p>
<p>使用 while，保证被唤醒后满足继续运行的条件，否则就继续等待</p>
<p>：例如线程 A 不能保证是被线程 B 唤醒。在下面的实现中，使用 notifyAll()，则线程 A 会唤醒 B 和 C</p>
<p>：while 和 notifyAll() 是互相配合的，如果只使用 notify()，在这种多个等待线程的情况下，可能会死锁</p>
<p>使用 wait() 和 notify() 注意：</p>
<ul>
<li><p><strong>调用 wait() 和 notify() 的对象是什么</strong></p>
</li>
<li><p><strong>线程被唤醒后会尝试重新获得锁</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">    	<span class="comment">// 当一个线程执行到getTask()方法内部的while循环时，它必定已经获取到了this锁</span></span><br><span class="line">        <span class="comment">// 释放this锁，与 synchronized 加锁的对象一致</span></span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">        <span class="comment">// 重新获取this锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到 while 语句中的条件变为：!=</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前正在执行线程的标记。初值为1，让线程 A 先执行</span></span><br><span class="line">		<span class="type">ABCPrint</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ABCPrint</span>(num); <span class="comment">// print对象作为不同线程的共享变量，不同线程获取print对象的锁从而实现同步。主要包括：互斥地修改共享变量 print.num，互斥地打印</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableA</span>(print));</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableB</span>(print));</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableC</span>(print));</span><br><span class="line">		threadA.start();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>); <span class="comment">// 保证初始线程按照ABC的启动顺序</span></span><br><span class="line">		threadB.start();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		threadC.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ABCPrint print;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RunnableA</span><span class="params">(ABCPrint print)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.print = print;	</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;		</span><br><span class="line">		print.PrintA();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ABCPrint print;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RunnableB</span><span class="params">(ABCPrint print)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.print = print;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;		</span><br><span class="line">		print.PrintB();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableC</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ABCPrint print;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RunnableC</span><span class="params">(ABCPrint print)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.print = print;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;		</span><br><span class="line">		print.PrintC();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABCPrint</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//当前正在执行线程的标记</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ABCPrint</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 循环打印2轮</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(num != <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//打印3次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; </span><br><span class="line">                    System.out.println(<span class="string">&quot;A&quot;</span>);  </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印A线程执行完，唤醒其他所有线程</span></span><br><span class="line">                num = <span class="number">2</span>;  </span><br><span class="line">                <span class="built_in">this</span>.notifyAll();  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintB</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(num != <span class="number">2</span>)&#123; <span class="comment">// 检查被唤醒后是否满足条件</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                num = <span class="number">3</span>;  </span><br><span class="line">                <span class="built_in">this</span>.notifyAll();  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintC</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)<span class="comment">//表示 循环打印2轮</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(num != <span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">                num = <span class="number">1</span>;  </span><br><span class="line">                <span class="built_in">this</span>.notifyAll();  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h2 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2 ReentrantLock"></a>2 ReentrantLock</h2><p>Condition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的，并且其行为也是一样的：</p>
<ul>
<li>await() 会释放当前锁，进入等待状态；</li>
<li>signal() 会唤醒某个等待线程；</li>
<li>signalAll() 会唤醒所有等待线程；</li>
<li><strong>线程被唤醒后会尝试重新获得锁</strong>。</li>
</ul>
<p>此外，和 tryLock() 类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来：</p>
<h3 id="2-1-互斥"><a href="#2-1-互斥" class="headerlink" title="2.1 互斥"></a>2.1 互斥</h3><p>共享变量 print 中的 Lock 对象被多线程共享。用共享的 ReentrantLock 修改 Synchronized 块的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABCPrint</span> &#123;</span><br><span class="line">	<span class="comment">// 多线程共享同一个 Lock 对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//当前正在执行线程的标记</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ABCPrint</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintA</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>;) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">			    lock.lock();</span><br><span class="line">			    <span class="keyword">while</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;<span class="comment">//打印3次</span></span><br><span class="line">					    System.out.println(<span class="string">&quot;A&quot;</span>);  </span><br><span class="line">			        &#125;</span><br><span class="line">			    	<span class="comment">//打印A线程执行完 ，通知打印B线程</span></span><br><span class="line">	                num = <span class="number">2</span>;  </span><br><span class="line">	                j++; <span class="comment">// 注意把 ++j 移到这里</span></span><br><span class="line">			    &#125;</span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			    lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintB</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>;)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">	            lock.lock();</span><br><span class="line">			    <span class="keyword">while</span>(num == <span class="number">2</span>)&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;B&quot;</span>);  </span><br><span class="line">					&#125;</span><br><span class="line">			        <span class="comment">//打印B线程执行完 ，通知打印C线程</span></span><br><span class="line">                    num = <span class="number">3</span>;  </span><br><span class="line">                    j++;	    </span><br><span class="line">		        &#125;</span><br><span class="line">	        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	        	lock.unlock();</span><br><span class="line">	        &#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintC</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>;) &#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">			    lock.lock();</span><br><span class="line">			    <span class="keyword">while</span>(num == <span class="number">3</span>)&#123;</span><br><span class="line">			       System.out.println(<span class="string">&quot;C&quot;</span>); </span><br><span class="line">			       <span class="comment">//打印C线程执行完 ，通知打印A线程</span></span><br><span class="line">	               num = <span class="number">1</span>;  </span><br><span class="line">	               j++;</span><br><span class="line">	            &#125;  </span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			    lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h3 id="2-2-使用-Condition"><a href="#2-2-使用-Condition" class="headerlink" title="2.2 使用 Condition"></a>2.2 使用 Condition</h3><p>不需要使用 while 检查被唤醒后是否满足条件，是因为 Condition 能够唤醒指定的线程。与 wait() notify() 不一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ABCPrint</span> &#123;</span><br><span class="line">	<span class="comment">// 共享变量包括：lock、condition</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//当前正在执行线程的标记</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ABCPrint</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 循环打印2轮</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)&#123;</span><br><span class="line">            </span><br><span class="line">			lock.lock();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//1.判断</span></span><br><span class="line">				<span class="keyword">if</span>(num != <span class="number">1</span>)&#123;</span><br><span class="line">					condition1.await();</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//2.打印</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//唤醒，包括两个步骤：设置num、唤醒指定的线程B</span></span><br><span class="line">				num = <span class="number">2</span>;</span><br><span class="line">				condition2.signal(); </span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintB</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(num != <span class="number">2</span>)&#123;</span><br><span class="line">					condition2.await();</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				num = <span class="number">3</span>;</span><br><span class="line">				condition3.signal();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintC</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(num != <span class="number">3</span>)&#123;</span><br><span class="line">					condition3.await();</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;---------------------------&quot;</span>);<span class="comment">// 两轮的分隔符</span></span><br><span class="line"></span><br><span class="line">				num = <span class="number">1</span>;</span><br><span class="line">				condition1.signal();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h2 id="3-AtomicInteger"><a href="#3-AtomicInteger" class="headerlink" title="3 AtomicInteger"></a>3 AtomicInteger</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ABCPrint</span>(<span class="string">&quot;A&quot;</span>,<span class="number">3</span>).start();<span class="comment">//A打印3次</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ABCPrint</span>(<span class="string">&quot;B&quot;</span>,<span class="number">2</span>).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ABCPrint</span>(<span class="string">&quot;C&quot;</span>,<span class="number">1</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABCPrint</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="comment">//打印次数，不是共享变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String str[] = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicInteger  atomCount= <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();<span class="comment">// 共享变量</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ABCPrint</span><span class="params">(String name,<span class="type">int</span> count)</span> &#123;</span><br><span class="line">		<span class="comment">// name：线程的名字</span></span><br><span class="line">		<span class="built_in">this</span>.setName(name);</span><br><span class="line">		<span class="built_in">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 循环满2轮退出打印</span></span><br><span class="line">			<span class="keyword">if</span> (atomCount.get() / <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span> (atomCount) &#123;</span><br><span class="line">				<span class="comment">// 顺序打印A、B、C</span></span><br><span class="line">				<span class="comment">// getName()实际上是this.getName()，得到当前线程的名字</span></span><br><span class="line">				<span class="keyword">if</span> (str[atomCount.get() % <span class="number">3</span>].equals(getName())) &#123; </span><br><span class="line">					atomCount.getAndIncrement();<span class="comment">//自增</span></span><br><span class="line">					</span><br><span class="line">					<span class="comment">//打印次数</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">						System.out.println(getName());</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//表示一轮打印结束 方便观察打印下分隔符</span></span><br><span class="line">					<span class="keyword">if</span> (<span class="string">&quot;C&quot;</span>.equals(getName())) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 当前线程打印打印完成后唤醒其它线程</span></span><br><span class="line">					atomCount.notifyAll();</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 非顺序线程wait()</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						atomCount.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-Semaphore"><a href="#4-Semaphore" class="headerlink" title="4 Semaphore"></a>4 Semaphore</h2><p>信号量（Semaphore）线程同步机制，当调用acquire()时，内部计数器数值增加；调用release()时，内部计数器递减；计数器值不能小于0，如果等于0，acquire()方法被阻塞，需要等待其他线程调用release()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	</span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">	        <span class="keyword">new</span> <span class="title class_">ThreadA</span>(<span class="number">3</span>).start();</span><br><span class="line">	        <span class="keyword">new</span> <span class="title class_">ThreadB</span>(<span class="number">2</span>).start();</span><br><span class="line">	        <span class="keyword">new</span> <span class="title class_">ThreadC</span>(<span class="number">1</span>).start();</span><br><span class="line">	   &#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//以A开始的信号量,初始信号量数量为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//B、C信号量,A完成后开始,初始信号数量为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">C</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    	<span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>();</span><br><span class="line">			<span class="built_in">this</span>.count = count;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    A.acquire();<span class="comment">// A获取信号执行,A信号量减1,当A为0时将无法继续获得该信号量</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">                    	   System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">                 </span><br><span class="line">                    B.release();<span class="comment">// B释放信号，B信号量加1（初始为0），此时可以获取B信号量</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    	<span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ThreadB</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>();</span><br><span class="line">			<span class="built_in">this</span>.count = count;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    B.acquire();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">                    	System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">                    C.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadC</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    	<span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ThreadC</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>();</span><br><span class="line">			<span class="built_in">this</span>.count = count;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    C.acquire();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">                    	System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">                    A.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h1><h1 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2022/04/06/MySQL/</url>
    <content><![CDATA[<p>MySQL 是一个关系型数据库，它的的默认端口号是<strong>3306</strong>。</p>
<span id="more"></span>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是关系数据库中对某一列或多个列的值进行排序的数据结构，便于对数据进行查找。</p>
<p>例如，对于students表，如果要经常根据score列进行查询，就可以对score列创建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_score (score);</span><br></pre></td></tr></table></figure>
<p>使用 <code>ADD INDEX idx_score (score)</code> 就创建了一个名称为 idx_score，使用列 score 的索引。</p>
<h2 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h2><p>优点：提高了查询效率</p>
<p>缺点：</p>
<ul>
<li><p>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增删改的时候，索引也要更新；</p>
</li>
<li><p>空间方面：索引需要占物理空间。索引文件很大，通常保存在磁盘，这导致查找时需要读写磁盘</p>
</li>
</ul>
<blockquote>
<p>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</p>
<p>对于中到大型的表，索引非常有效；</p>
<p>但是对于特大型的表，建立和维护索引的代价可能超过了索引对查询效率的提升。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</p>
</blockquote>
<h2 id="MySQL-的索引类型"><a href="#MySQL-的索引类型" class="headerlink" title="MySQL 的索引类型"></a>MySQL 的索引类型</h2><ol>
<li><p>从数据结构上来划分：B 树、B+ 树、Hash</p>
</li>
<li><p>从应用层次来分：普通索引，唯一索引，复合索引。</p>
<ul>
<li>普通索引：即一个索引只包含单个列，一个表可以有多个普通索引</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值</li>
<li>复合索引：多列值组成一个索引，<strong>专门用于组合搜索，其效率大于索引合并</strong>（即创建多个独立的索引）</li>
</ul>
</li>
<li><p>叶子节点存放数据还是主键值： 聚集索引，非聚集索引</p>
</li>
</ol>
<h2 id="索引数据结构选择-B-树的原因"><a href="#索引数据结构选择-B-树的原因" class="headerlink" title="索引数据结构选择 B+ 树的原因"></a>索引数据结构选择 B+ 树的原因</h2><p>在 MySQL 中，B+ 树的叶子节点直接存储了数据，表以主键索引构成的 B+ 树进行存储</p>
<p>B+ 树与 B 树相比：</p>
<ul>
<li><p>磁盘读写次数：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。<strong>数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点</strong>。在这个前提下，由于 B+ 树的内部节点没有关键字对应的数据信息，因此相同大小的内部节点，B+ 树能存储更多的关键字，这直接导致了在相同数据量的情况下 B+ 树的树高比 B 树小，在查找过程中经过的节点更少，也就是说 B+ 树的磁盘读写次数更少</p>
</li>
<li><p>查找用时</p>
<ul>
<li>从时间复杂度上来看，B+ 树和 B 树的查找时间复杂度都是 O(log~2~N)，<strong>但是由于 B+ 树的磁盘读写次数更少</strong>，因此省去了很多的磁盘读写时间，从而更快</li>
<li>B+ 树查找速度稳定：B+ 树叶子节点才存储数据，每次查找都会查找到叶子节点，查找次数相同（等于树高），B 树内部节点存储数据，查找可能在内部节点就停止。但是，对于平衡树，叶子节点层的节点个数一定是最多的，经常需要查找到叶子节点，从这个意义上，即便 B 树可能在内部节点停留，我们还是可以用它在叶子节点停留的情况来与 B 树进行时间上的比较</li>
</ul>
</li>
<li><p>区间查询</p>
<ul>
<li>B+ 树适合区间查询：B+ 树所有的叶子节点数据构成了一个有序链表，适合区间查询。而 B 树若要查找区间数据，需要中序遍历。</li>
<li>B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ul>
</li>
</ul>
<blockquote>
<p>MySQL 中，索引文件是存储在磁盘的，对于树结构来说，文件的数据单位是结点。因此，二分查找搜索树的过程中，每访问一个结点，都做了一次读磁盘的操作。每次从磁盘读取一个结点到内存中，与 target 进行比较，然后继续到磁盘读取下一个需要查找的结点。</p>
<p>读写磁盘会阻塞线程，因为耗时较长。而读写内存不会阻塞。</p>
<p>MySQL 使用磁盘存储数据，需要考虑磁盘读写性能，而 Redis 不需要</p>
<p>IO 读写次数：每次根据孩子指针来查找磁盘元素都是一次对磁盘的读取操作。因此，实际上，树的高度越小，IO 读写次数也越小</p>
<p>相关文章：<a href="[终极面试：InnoDB 中B+Tree索引树有多高，以及能存多少行数据？ | 码农网 (codercto.com">B+树高度</a>](<a href="https://www.codercto.com/a/106607.html">https://www.codercto.com/a/106607.html</a>))</p>
</blockquote>
<p>B+ 树与红黑树相比：</p>
<ul>
<li>B+ 树节点的出度大，高度比红黑树低。于是 B+ 树的磁盘读写代价更低</li>
<li>红黑树不适合区间查询</li>
</ul>
<p>B+ 树与 Hash 相比：</p>
<p>Hash 的优点：适合等值查询，没有哈希冲突时，等值查询的速度很快</p>
<p>Hash 的缺点：</p>
<ul>
<li><p>Hash 是无序的数据结构，不支持区间查询，也无法利用索引进行排序</p>
</li>
<li><p>不支持多列联合索引。对于联合索引，从哈希的角度来说，多个键值统一映射到一个 hash 值，并不会有层次。Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，不会针对每个索引单独计算 Hash 值。因此不支持部分索引列的匹配查找；</p>
</li>
<li>如果有大量重复键值，存在哈希碰撞问题 。</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>B Tree 指的是 Balance Tree，也就是平衡树，所有叶子节点位于同一层。</p>
<p>B+ Tree 具有 B Tree 的平衡性，并且通过顺序访问叶子节点来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>
<p><img src="/2022/04/06/MySQL/33576849-9275-47bb-ada7-8ded5f5e7c73.png" alt="img" style="zoom:80%;"></p>
<p>查找操作：在每个节点上进行二分查找，找到子节点指针的位置，然后到子节点继续；</p>
<p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p><img src="/2022/04/06/MySQL/v2-d679e616dd3312da3d002d555e3c0b7c_720w.jpg" alt="跳表内部存储结构"></p>
<p>跳表的底层存放了所有节点，它们构成双向链表。从底层逐层往上，每层的节点个数近似为前一层的一半，最顶层只有一个节点。</p>
<p>跳表的设计思路是：<strong>通过空间换时间，实现对链表的二分查找</strong>。（链表的结构本身并不适合二分查找，因为它不支持按索引找到二分节点）</p>
<p>MySQL 选择 B+ 树而非跳表：</p>
<ul>
<li><p>从时间上来说，MySQL 设计的时候跳表还没有广泛应用</p>
</li>
<li><p>从存储结构来说，跳表的高度与红黑树是一样的，都是 log~2~N，因此，跳表的磁盘 IO 性能同样不好</p>
</li>
</ul>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设 students 表的 name 不能重复，设置唯一索引：</p>
<p>ALTER TABLE students</p>
<p>ADD UNIQUE INDEX uni_name (name);</p>
<p>通过 <strong>UNIQUE INDEX</strong> 我们就添加了一个唯一索引。</p>
<blockquote>
<p>区别于唯一约束：</p>
<p>ALTER TABLE students</p>
<p>ADD CONSTRAINT uni_name UNIQUE (name);</p>
<p>这种情况下，name列没有索引，但仍然具有唯一性保证。</p>
</blockquote>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>可以使用多个字段同时建立一个索引，叫做联合索引。（等价于多维排序）</p>
<p>ALTER TABLE students</p>
<p>ADD INDEX idx_name_score (name, score);</p>
<p>这里表示两个单独的索引列name和score。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>最左前缀原则的意思是：</p>
<ul>
<li>在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用才能命中索引。</li>
<li>注意范围查询和等值查询的影响。mysql 会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如 a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立 (a,b,c,d) 顺序的索引，d = 4 是用不到索引的，如果建立 (a,b,d,c) 的索引则可以用到。</li>
</ul>
<p>具体原因为：</p>
<ul>
<li><p>假设现在建立了”name，age，school”的联合索引，那么索引的排序为：先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>
<p>  当进行查询时，此时索引仅仅按照 name 严格有序，因此必须首先使用 name 字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。</p>
</li>
<li><p>当走到 c &gt; 3，实际上取出的行仅在 c 相等的行，d有序，而 c 不相等的行，d 不保证有序。也就是说，此时的索引按照 d 列是无序的，无法使用索引。</p>
</li>
</ul>
<blockquote>
<p>总结：mysql 的查询优化器会对等值查询（查询 = ）进行分析，使用正确的顺序进行查询</p>
<p>假设对 student 表建立了 (name, cid) 的联合索引，</p>
<ul>
<li>执行查询语句为</li>
</ul>
<p>SELECT * FROM student WHERE cid=1 AND name=‘小红’;</p>
<p>虽然查询顺序并不按照 (name, cid)，但是由于对 name 字段进行的是等值查询，因此 mysql 查询优化器会判断在 name 字段进行等值查询时，对于相同的 name，表已经按照 cid 有序排列，可以命中索引。因此，该语句能正确返回结果。</p>
<p>执行查询语句为</p>
<ul>
<li>SELECT * FROM student WHERE cid=1;</li>
</ul>
<p>虽然是等值查询，但是无法返回结果。单纯的 cid 是无序的。</p>
</blockquote>
<h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p><img src="/2022/04/06/MySQL/45016e98-6879-4709-8569-262b2d6d60b9.png" alt="img" style="zoom: 67%;"></p>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<p><img src="/2022/04/06/MySQL/7c349b91-050b-4d72-a7f8-ec86320307ea.png" alt="img" style="zoom:67%;"></p>
<p>例如设非聚集索引为：username，默认聚集索引为 id。则叶结点 (username, id)</p>
<ul>
<li><p>从非聚集索引的节点里面可直接获得的数据：聚集索引列的值、主键值。<strong>覆盖索引</strong>（索引包含所有需要查询的字段的值）</p>
<p>  select id, username from t1 where username = ‘小明’</p>
<p>  select username from t1 where username = ‘小明’</p>
</li>
<li><p>从非聚集索引的节点里面不可直接获得的数据。命中了索引。但未覆盖</p>
<p>  select username, score from t1 where username = ‘小明’</p>
</li>
</ul>
<p>为了获取到 score 对应记录的其他数据，数据库会根据 id 进行聚集索引查找。这个过程叫做回表。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ul>
<li><p>非空字段：<strong>应该指定列为NOT NULL，除非你想存储NULL</strong>。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p>
</li>
<li><p>字段取值差异大的列作为索引列：列的值如果越互不相同，那么它作为索引索引效率越高。</p>
<blockquote>
<p>可以通过 COUNT(DISTINCT 字段名)/COUNT(*) 查看字段取值的个数/总字段个数。</p>
</blockquote>
</li>
<li><p>索引字段越小越好：数据库的数据存储以页为单位，一页存储的数据越多，一次 IO 操作获取的数据越大效率越高。</p>
</li>
<li><p>避免索引失效的发生。</p>
</li>
</ul>
<p><strong>对于联合索引</strong>：将查询需求频繁或者字段取值差异大的列放在前面。</p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用<strong>前缀索引</strong>，只索引开始的部分字符。</p>
<p>前缀长度的选取同样可以根据索引选择性来确定。只不过这个时候需要修改一下这个表达式 <code>COUNT(DISTINCT 字段名)/COUNT(*)</code> 的分子，例如设前缀长度为 a，分子统计的是：字段 0~a-1 部分的不同取值个数。</p>
<p>例如对于这个表格，发现 area 字段很多都是以 china 开头的，前缀长度不应该选取为 5</p>
<p><img src="/2022/04/06/MySQL/image-20220421103641620.png" alt="image-20220421103641620"></p>
<p><strong>前缀索引测试</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 创建一个测试表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `x_test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `x_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `x_time` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4145025</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 添加<span class="number">200</span>万条测试数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> x_test(x_name,x_time) <span class="keyword">SELECT</span> CONCAT(rand()<span class="operator">*</span><span class="number">3300102</span>,x_name),x_time <span class="keyword">FROM</span> x_test <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">30000</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/06/MySQL/webp.webp" alt="img"></p>
<p>在无任何索引的情况下随便查询一条存在的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> x_test <span class="keyword">WHERE</span> x_name <span class="operator">=</span> <span class="string">&#x27;1892008.205824857823401.800099203178258.8904820949682635656.62526521254&#x27;</span>;`</span><br></pre></td></tr></table></figure>
<p> 查询时间：2.253s</p>
<ul>
<li><p>添加前缀索引，以第一位字符创建前缀索引</p>
<p>   <code>alter table x_test add index(x_name(1))</code></p>
<p>  再次查询相同 sql 语句，查询时间:3.291s。</p>
<p>  当使用第一位字符创建前缀索引后，查询的时间更长了。这是因为对于第一个字符，索引字段的差异性太小，200万条数据全以数字开头的话那么平均20万条的数据都是相同的索引值</p>
</li>
<li><p>重新建立前缀索引，这次以前 4 位字符来创建</p>
<p>   <code>alter table x_test add index(x_name(4));</code></p>
<p>  再次查询相同 sql 语句</p>
<p>  查询时间：0.703s，速度大大提升。</p>
</li>
<li><p>200 万条数据都以数字开头 而 0-9 排列组合 7 位则可达到千万种组合，也就是说用前 7 位来做索引几乎不会出现重复索引值的情况了（千万 &gt;&gt; 百万）</p>
<p>   <code>alter table x_test add index(x_name(7));</code></p>
<p>   再次查询相同 sql 语句</p>
<p>   查询时间：0.014s  ( 首次执行无缓存状态下 )，提升巨大！</p>
</li>
</ul>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>索引失效，即查询语句用到了索引列，但是无法用到已经建立的索引。</p>
<ul>
<li><p>计算导致索引失效。包括使用函数、运算符。以使用运算符为例，例如对 score 列建立了索引，想要查询 score*2 &lt; 100 的记录，不能写：</p>
<p>  SELECT <em> FROM student WHERE score</em>2 &lt;  100; 会导致遍历整个表计算并且判断</p>
<p>  而应该写</p>
<p>  SELECT * FROM student WHERE score &lt;  50; 这种写法才能用到索引</p>
</li>
<li><p>类型不一致导致索引失效。</p>
<p>  SELECT * FROM student  WHERE name = ABC，ABC 不是字符串</p>
</li>
<li><p>OR 引起的索引失效 </p>
<p>  如果 OR 连接的是同一个字段，那么索引不会失效，反之索引失效。（全表扫描）</p>
<p>  SELECT * FROM user WHERE name = ‘张三’ OR height = ‘175’;</p>
</li>
</ul>
<h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><p>减少请求的数据量</p>
<ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据.</li>
</ul>
<p>切分大查询</p>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rows_affected <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125; while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>每次用 LIMIT 限制查询记录数为 10000，每次只对 10000 执行删除操作。而非一次性对所有符合条件的记录执行删除操作。</p>
<h1 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h1><h2 id="数据库的三范式"><a href="#数据库的三范式" class="headerlink" title="数据库的三范式"></a>数据库的三范式</h2><p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</p>
<p>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</p>
<p>第三范式：任何非主属性不依赖于其它非主属性。</p>
<h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><p>与 MyISAM 相比，InnoDB</p>
<ul>
<li><p>支持行级锁（默认），加锁粒度小，并发度高。但加锁的开销也最大，加锁慢</p>
<blockquote>
<p>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p>
</blockquote>
</li>
<li><p>支持事务</p>
</li>
<li><p>支持崩溃恢复，恢复的过程依赖于 redo log 。</p>
</li>
<li><p>采用聚簇索引，叶子结点存储行记录，可直接获得数据（非聚簇索引要跳转）。</p>
</li>
<li><p>InnoDB 支持外键，而 MyISAM 不支持</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 1, 2, 3, 4, 8 字节存储空间。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>FLOAT 和 DOUBLE 为浮点类型（4 字节、8 字节），DECIMAL 为高精度小数类型。</p>
<p>CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。（即字符串多长就用多大的空间）</p>
<p>但是在执行 UPDATE 时如果更新为更长的字符串，会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则进行页分裂，用两个数据页来存放原来一个页的数据。</p>
<h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p>
<p>DATETIME</p>
<p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。它与时区无关。</p>
<p>例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<p>TIMESTAMP</p>
<p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的<strong>秒数</strong>，使用 4 个字节，只能表示从 1970 年到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<h2 id="超键、候选键、主键、外键"><a href="#超键、候选键、主键、外键" class="headerlink" title="超键、候选键、主键、外键"></a>超键、候选键、主键、外键</h2><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
<p>候选键：是最小超键（最小的属性集），即没有冗余元素的超键。</p>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。</p>
<p>对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</p>
<p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p>
<p>所以，<strong>选取主键的一个基本原则</strong>是：不使用任何业务相关的字段作为主键。</p>
<p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。</p>
<p>作为主键最好是完全业务无关的字段，<strong>我们一般把这个字段命名为 id。常见的可作为 id 字段的类型有</strong>：</p>
<ol>
<li><p>自增整数类型：数据库在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</p>
</li>
<li><p>全局唯一 GUID 类型：使用一种全局唯一的字符串作为主键，类似 8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID 算法通过网卡 MAC 地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了 GUID 算法。不推荐，因为无序。</p>
</li>
</ol>
<blockquote>
<p>主键不能为 NULL</p>
</blockquote>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>在一个表中存在的另一个表的主键称此表的外键。</p>
<p>在 students 表中，通过 class_id 字段，可以把数据与另一张表关联起来，这种列称为外键。</p>
<p>外键并不是通过定义列名实现的，而是通过定义外键约束实现的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (class_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> classes (id);</span><br></pre></td></tr></table></figure>
<p>fk，即 FOREIGN KEY，表示外键。外键约束的名称为 fk_class_id，FOREIGN KEY (class_id)指定了 students 表的class_id 字段作为外键，REFERENCES classes (id) 指定了这个外键将关联到 classes 表的 id 列（即 <strong>classes 表的主键</strong>）。</p>
<blockquote>
<p> 通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果 classes 表不存在 id=99 的记录，students 表就无法插入 class_id=99 的记录。</p>
<p>由于外键约束会降低数据库的性能，通常并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。</p>
</blockquote>
<h2 id="SQL-约束"><a href="#SQL-约束" class="headerlink" title="SQL 约束"></a>SQL 约束</h2><p>NOT NULL：字段内容不能为空（NULL）。</p>
<p>UNIQUE：字段内容不能重复，一个表允许有多个 Unique 约束。</p>
<p>PRIMARY KEY/主键：字段内容不能重复，但它在一个表只允许出现一个。</p>
<p>FOREIGN KEY/外键：用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p>
<p>CHECK：用于控制字段的值范围。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>何为事务？一言蔽之，事务是逻辑上的一组操作，要么都执行，要么都不执行。<br>假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p>
<ol>
<li>将小明的余额减少 1000 元</li>
<li>将小红的余额增加 1000 元。</li>
</ol>
<p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p>
<h2 id="ACID-特性"><a href="#ACID-特性" class="headerlink" title="ACID 特性"></a>ACID 特性</h2><p>关系型数据库事务都有 ACID 特性：</p>
<ol>
<li>原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部失败回滚；</li>
<li>一致性（Consistency）： 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li>隔离性（Isolation）： 一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<p>ACID 关系</p>
<ul>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<p>AUTOCOMMIT</p>
<p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用 START TRANSACTION 语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>
<h2 id="事务的实现原理-如何保证-ACID"><a href="#事务的实现原理-如何保证-ACID" class="headerlink" title="事务的实现原理/如何保证 ACID"></a>事务的实现原理/如何保证 ACID</h2><p>以 MySQL 的 InnoDB 引擎为例。</p>
<ul>
<li><p>MySQL InnoDB 引擎使用 redo log（重做日志） 保证事务的持久性，使用 undo log（回滚日志） 来保证事务的原子性。redo log 记录的是修改了缓存池数据页的所有命令，undo log 记录的是某个事务中所更新记录的历史版本</p>
</li>
<li><p>MySQL InnoDB 引擎通过锁机制、MVCC（多版本并发控制） 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ）。</p>
</li>
<li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li>
</ul>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>redo log 能保证事务的持久性。</p>
<p>MySQL 中数据是以页为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。</p>
<p>后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。</p>
<p>更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。</p>
<p><img src="/2022/04/06/MySQL/1646831502098-89c9da04-564f-4e6e-85aa-6664203a0b20.png" alt="redo log 生成过程"></p>
<p>redo log 记录了数据的修改，因此可以根据日志内容恢复数据。通过刷盘，将缓存中的 redo log buffer 更新到硬盘中的 redo log 文件，这样即使数据库出现故障，redo log 也不会丢失，从而实现了持久化。</p>
<p>是否需要更新数据？</p>
<blockquote>
<p>在MySQL中，为了提高数据库的性能，MySQL 采用了 WAL（Write-Ahead Logging）机制，即在实际写数据前，先把修改的数据记到日志文件中。MySQL 的写数据是写硬盘数据，与 redis 不同，redis 的写数据指的是写内存。</p>
<p>这样做的原因在于，磁盘读写速度慢。</p>
</blockquote>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log 能实现回滚，保证事务的原子性，和实现 MVCC（多版本并发控制）</p>
<p>对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：</p>
<ul>
<li>ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。</li>
<li>事务 ID：记录最后一次修改该记录的事务 ID。</li>
<li>回滚指针：指向这条记录的上一个版本。</li>
</ul>
<p>假设执行如下两个事务。如图，首先 insert 语句向空表 t1 中插入了一条数据，a = 1，b = 1， 隐式生成的 ROW ID = 1 ，事务 ID = 1，回滚指针= null。当执行 update t1 set b=666 where a=1 时，大致步骤如下：</p>
<ul>
<li>数据库会先对满足 a=1 的行加排他锁（对该行的隐藏字段并不加排他锁）；</li>
<li>然后将原记录复制到 <strong>undo log</strong> 空间中；</li>
<li>修改 b 字段的值为 666；</li>
<li>修改事务 ID 为 2，并通过隐藏的回滚指针指向 undo log 中的历史记录；</li>
<li>事务提交，释放前面对满足 a=1 的行所加的排他锁。</li>
</ul>
<p><img src="/2022/04/06/MySQL/1647872433220-f2c141c9-1a75-43a5-9db1-55abe39f6b97-164929795888010.png" alt></p>
<p>总的来说，每一行数据都有一个隐藏的回滚指针，用于指向该行的上一个版本，这个版本的记录存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。</p>
<p>实现回滚：对同一行记录的不断更新，undo log 中的历史记录实际上会形成一个链表。因此，遍历链表逐步回滚即可。</p>
<p>实现 MVCC：其它事务此时（即事务未提交时）若需要查询，根据回滚指针查询 undo log 中这行数据的上一个历史版本。（由于记录的隐藏字段没有加排他锁，所以可以访问回滚指针）。MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。</p>
<h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><p>MySQL的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。</p>
<p>binlog 有三种格式：</p>
<ul>
<li>statement： 基于 SQL 语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程可能导致数据不一致甚至出错。</li>
<li>row： 基于行的模式，记录的是行的变化，很安全，但是文件大小会比其他两种模式大很多</li>
<li>mixed： 混合模式，根据语句来选用是 statement 还是 row 模式。</li>
</ul>
<h4 id="bin-log-与-redo-log-的区别"><a href="#bin-log-与-redo-log-的区别" class="headerlink" title="bin log 与 redo log 的区别"></a>bin log 与 redo log 的区别</h4><ol>
<li>binlog是MySQL数据库的上层产生的，任何存储引擎对于数据库的更改都会产生二进制日志。redo log是在InnoDB存储引擎层产生</li>
<li>两种日志记录的内容形式不同。MySQL的binlog是逻辑日志，其记录是对应的SQL语句。而innodb存储引擎层面的重做日志是物理日志。</li>
<li>两种日志与记录写入磁盘的时间点不同，二进制日志只在事务提交完成后进行一次写入。而innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的。</li>
</ol>
<p>并且对于每一个事务，仅包含对应事务的一个日志。而对于innodb存储引擎的重做日志，由于其记录是物理操作日志，因此每个事务对应多个日志条目，并且事务的重做日志写入是并发的，并非在事务提交时写入，其在文件中记录的顺序并非是事务开始的顺序。</p>
<ol>
<li>binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，redo log是循环使用。</li>
</ol>
<h2 id="并发事务带来哪些问题？"><a href="#并发事务带来哪些问题？" class="headerlink" title="并发事务带来哪些问题？"></a>并发事务带来哪些问题？</h2><p>脏读（Dirty Read）。一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据</p>
<p>不可重复读（Unrepeatable read）：在一个事务内，多次读同一数据，读取的数据不一致。</p>
<p>幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>MySQL 默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻读。</p>
<p>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更</p>
<p>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据</p>
<p>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改</p>
<p>SERIALIZABLE(可串行化)： 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
</div>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h2><p>MySQL 中提供了两种锁：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><p>读写锁</p>
<ul>
<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>意向锁（Intention Locks）</p>
<p>使用意向锁可以更容易地支持多粒度锁。</p>
<ul>
<li><p>在存在行级锁和表级锁的情况下，事务 T 想要对整个表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
</li>
<li><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是<strong>表锁</strong>，用来<strong>表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁</strong>（并不真正加表级锁）。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据<strong>行</strong>对象的 S 锁之前，必须先获得表的 IS 锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
</li>
</ul>
<p>意向锁只起逻辑判断作用，本质上可以认为是一个标记值。</p>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对<strong>表 A</strong> 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。事务 T 想要对表 A 加 S 锁，只需要先检测是否有其它事务对表 A 加了 X/IX 锁。</p>
<h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p><strong>一级封锁协议</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，<strong>直到 T 提交才释放</strong>锁。（并没有强调行级锁还是表级锁，因为都可以实现目的）。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改在事务提交之前不会被覆盖。</p>
<p><img src="/2022/04/06/MySQL/image-20191207220440451.png" alt="img" style="zoom: 50%;"></p>
<p><strong>二级封锁协议</strong></p>
<p><strong>在一级的基础上</strong>，要求读取数据 A 时必须加 S 锁，<strong>读取完马上释放</strong> S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据一级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<p><img src="/2022/04/06/MySQL/image-20191207220831843.png" alt="img" style="zoom:50%;"></p>
<p><strong>三级封锁协议</strong></p>
<p><strong>在二级的基础上</strong>，要求读取数据 A 时必须加 S 锁，<strong>直到事务提交</strong>了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<p><img src="/2022/04/06/MySQL/image-20191207221313819.png" alt="img" style="zoom:50%;"></p>
<h2 id="锁的释放时机"><a href="#锁的释放时机" class="headerlink" title="锁的释放时机"></a>锁的释放时机</h2><p>在事务执行过程中，如果有加写锁操作，写锁在<strong>事务提交时</strong>释放才会被释放</p>
<p>对于读锁，</p>
<h2 id="加锁时机"><a href="#加锁时机" class="headerlink" title="加锁时机"></a>加锁时机</h2><p>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加排他锁（X)；</p>
<p>如果有隔离级别的SELECT？</p>
<p>对于 SELECT 语句，事务可以通过以下两种 SELECT 语句显式给记录集加共享锁或排他锁：</p>
<ul>
<li><p>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他事务可以查询记录，并也可以对该记录加共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</p>
<p>  使用场景：为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，并且不允许其他人来修改数据。但是自己不一定能够修改数据，因为有可能其他的事务也对这些数据使用了 in share mode 的方式上了 S 锁。</p>
<p>  性能：select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不允许对该数据进行修改。如果不及时的commit 或者rollback 可能会造成大量的事务等待。（性能上，二者的问题都在于锁是持续到事务结束，而非语句结束）</p>
</li>
<li><p>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE。其他事务可以查询该记录，但是不能对该记录加共享锁或排他锁</p>
<p>  使用场景：为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候。</p>
<p>  性能：select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，如果事务没有及时的commit 或者 rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。</p>
</li>
<li><p>普通 SELECT 语句不加锁，因此可以随意查询加了锁的记录。</p>
</li>
</ul>
<p>如果InnoDB表没有建立索引和主键，那么会用隐式的主键列生成的索引来进行锁定</p>
<p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</p>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="为什么要分库分表？"><a href="#为什么要分库分表？" class="headerlink" title="为什么要分库分表？"></a>为什么要分库分表？</h2><p>分表</p>
<p>单表数据量太大，会极大影响 sql执行的性能。</p>
<p>分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p>
<p>分库</p>
<p>分库就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p>
<h2 id="垂直拆分和水平拆分"><a href="#垂直拆分和水平拆分" class="headerlink" title="垂直拆分和水平拆分"></a>垂直拆分和水平拆分</h2><p>水平拆分</p>
<ul>
<li>对于表来说，就是按行拆分。对于库来说，就是对库里的每个表这么做。</li>
<li>水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。</li>
</ul>
<p>垂直拆分</p>
<ul>
<li>就是按列/字段拆分，每个表都包含部分字段。通常是按照列的关系密集程度进行切分，也可以将经常被使用的列和不经常被使用的列切分到不同的表中。</li>
<li>因为数据库是有缓存的，访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/2022/04/15/Presum/</url>
    <content><![CDATA[<p>前缀和可以用来解决连续子数组问题，经常与哈希表配合，进行一遍扫描，希望在扫描到当前位置 x 时，获得以 x 为右端点的子数组结果，左端点可以通过查找哈希表找到。</p>
<p>需要注意，配合哈希表使用的时候，经常要先添加一些基本的键值对，保证解的充分性。</p>
<span id="more"></span>
<h1 id="前缀和与哈希表"><a href="#前缀和与哈希表" class="headerlink" title="前缀和与哈希表"></a>前缀和与哈希表</h1><h2 id="基本问题：连续子数组和为定值"><a href="#基本问题：连续子数组和为定值" class="headerlink" title="基本问题：连续子数组和为定值"></a>基本问题：连续子数组和为定值</h2><p>对于一个数组 nums，求出所有满足和为 target 的连续子数组，连续子数组用 (左端点索引，右端点索引) 表示。</p>
<p>用前缀和 + 哈希表进行求解。</p>
<p>前缀和：起点为 nums[0] </p>
<p>哈希表：以前缀和为键，前缀和终点的索引作为值。由于可能有多个前缀和相同，因此用 List\<Integer> 存放值。</Integer></p>
<p>求解过程：</p>
<ul>
<li>遍历 nums，并维护从 nums[0] 到 nums[curidx] 的前缀和 preSum_curidx</li>
<li>在哈希表中查找是否有 key = target - preSum_curidx 的键值对，如果有，遍历 key 对应的 List，以 List 的元素作为左端点，curidx 作为右端点，表示我们找到了一个连续子数组</li>
<li>将 (preSum_curidx, curidx) 加入哈希表中</li>
</ul>
<h2 id="525-0-和-1-个数相同的子数组"><a href="#525-0-和-1-个数相同的子数组" class="headerlink" title="525. 0 和 1 个数相同的子数组"></a>525. 0 和 1 个数相同的子数组</h2><p>给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。</p>
<p>前缀和：起点为 nums[0]，记录 preSum0 和 preSum1，表示从 nums[0] 到当前位置的 0 的个数和 1 的个数</p>
<p>分析：</p>
<p>设当前位置为 j，需要找的 i 满足：</p>
<script type="math/tex; mode=display">
preSum0_{j}-preSum0_{i}=preSum1_{j}-preSum1_{i}</script><p>将相同下标的前缀和移到一边：</p>
<script type="math/tex; mode=display">
preSum1_{j}-preSum0_{j}=preSum0_{j}-preSum1_{j}</script><p>因此，令哈希表的键为 preSum0 - preSum1，而哈希表的值不需要用 List\<Integer> 存放，这是因为虽然可能有多个位置的 preSum0 - preSum1 相等，但是题目要求的是最长连续子数组，也就是说，当有多个位置的 preSum0 - preSum1 相等，我们只需要第一次加入哈希表的那个端点，它一定是这些位置中最靠左的那个。</Integer></p>
<p>在扫描到 j 时，只需要以当前的 preSum0 - preSum1 为键查找哈希表即可。</p>
<p>注意到哈希表一开始添加了 (0, -1) 键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preSum0</span> <span class="operator">=</span> <span class="number">0</span>, preSum1 = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>); <span class="comment">// 注意判断的是(i,j]子数组，左开右闭</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) ++preSum0;</span><br><span class="line">            <span class="keyword">else</span> ++preSum1;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmpkey</span> <span class="operator">=</span> preSum0 - preSum1;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tmpkey))&#123;</span><br><span class="line">                ret = Math.max(ret, i-map.get(tmpkey));</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 后put的key-value 会覆盖之前已经put的。不put，留最前面那个即可</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> map.put(tmpkey, i); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a>974. 和可被 K 整除的子数组</h2><p>给定一个整数数组 nums 和一个整数 k（k 不为 0），返回其中元素之和可被 k 整除的（连续、非空） 子数组 的数目。</p>
<p>前缀和：起点为 nums[0]，记录 preSum，表示从 nums[0] 到当前位置的和</p>
<p>以下以 % 为模运算符进行分析。</p>
<blockquote>
<p>在 Java 中 % 是求余运算，仅当被除数和除数是同号的时候才可以替代求模运算。求模运算需要使用 Math.floorMod(被除数, 除数)</p>
</blockquote>
<p>设当前位置为 j，需要找的 i 满足：</p>
<script type="math/tex; mode=display">
(preSum_{j}-preSum_{i})\%k==0</script><p>做等价变换，将相同下标的变量移到一边。根据求模运算性质，可以设：</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
preSum_{i}=ak+b\\ preSum_{j}=ck+d

\end{matrix}\right.</script><p>则：</p>
<script type="math/tex; mode=display">
(preSum_{j}-preSum_{i})=(a-c)k+(b-d)</script><p>于是原式等价于：</p>
<script type="math/tex; mode=display">
b==d</script><p>进一步可以写作：</p>
<script type="math/tex; mode=display">
preSum_{j}\%k==preSum_{i}\%k</script><p>因此，令哈希表的键为 preSum % k，值为 preSum % k 出现的次数，不需要记录下标（以 List\<Integer>  方式）。当然了，记录下标可以帮助我们得到更完整更有意义的输出结果。</Integer></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysDivByK</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; hs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">preSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    hs.put(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 注意需要添加 (0, 1) 键值对，当 preSum % k == 0 时有解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        preSum += nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Math.floorMod(preSum, k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hs.containsKey(val))&#123;</span><br><span class="line">            ans += hs.get(val);</span><br><span class="line">            hs.put(val, hs.get(val)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hs.put(val, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a>523. 连续的子数组和</h2><p>给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>
<p>子数组大小 至少为 2 ，且</p>
<ul>
<li>子数组元素总和为 k 的倍数。</li>
<li>如果存在，返回 true ；否则，返回 false 。</li>
</ul>
<p>与 974 相同，只需要把哈希表存储的值改变为：第一次出现的下标，保证每次看的子数组是最长的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkSubarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">preSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        hs.put(<span class="number">0</span>, -<span class="number">1</span>); <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            preSum += nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Math.floorMod(preSum, k);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(hs.containsKey(val))&#123; </span><br><span class="line">                <span class="keyword">if</span>(i-hs.get(val)&gt;<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 若 key 已经存在，不能够走到这里</span></span><br><span class="line">                hs.put(val, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h1><p>差分数组的第 i 个</p>
<p>数是原数组的第 i-1 个元素和第 i 个元素的差值，对于数组 [1,2,2,4]，其差分数组为 [1,1,0,2]。</p>
<p>差分数组的性质：</p>
<ul>
<li>差分数组的前缀和数组是原数组</li>
<li>对原数组的某一个区间 [l, r] 的每个元素施加一个增量 inc，即差分数组的前缀和数组的 [l, r] 元素增加了 inc，而这可以等效为：差分数组 d，令 d[l] 增加 inc，d[r+1] 减少 inc</li>
</ul>
<p>根据性质 2，把对于区间内多个元素的修改变为对于差分数组两个元素的修改（前者是需要遍历的），当我们完成了差分数组的修改，再根据性质 1，求出差分数组的前缀和数组即可修改后的目标数组</p>
<blockquote>
<p>相关题目</p>
<p><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></p>
</blockquote>
<h1 id="推广的前缀和"><a href="#推广的前缀和" class="headerlink" title="推广的前缀和"></a>推广的前缀和</h1><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>设 preSum(i, j) 表示以 (0, 0) 为左上角，(i, j) 为右下角的元素和，则:</p>
<p>1 前缀和递推：preSum(i, j) = matrix[i][j] + preSum(i, j-1) + preSum(i-1, j) - preSum(i-1, j-1)</p>
<p>2 任意矩阵元素和。作图易知，以 (a, b) 为左上角，(c, d) 为右下角的矩阵和 = </p>
<p>preSum(c, d) – preSum(c,b) – preSum(a, d) + preSum(a, b)</p>
<h2 id="1588-所有奇数长度子数组的和"><a href="#1588-所有奇数长度子数组的和" class="headerlink" title="1588. 所有奇数长度子数组的和"></a>1588. 所有奇数长度子数组的和</h2><p>设原数组为 nums，nums 的前缀和数组为 preSum，则</p>
<ul>
<li><p>长度为 1 的子数组的和：</p>
<script type="math/tex; mode=display">
  preSum[0] + (preSum[1]\ –\ preSum[0])+ … + (preSum[N-1]\ –\ preSum[N-2])</script></li>
<li><p>长度为 3 的子数组的和：</p>
<script type="math/tex; mode=display">
  preSum[2] + (preSum[3]\ –\ preSum[0])+ ... + (preSum[N-1]\ –\ preSum [N-1-3]</script></li>
<li><p>因此，长度为 x 的子数组的和：</p>
<script type="math/tex; mode=display">
  \begin{align*}

    Sum_{x} &= preSum[x-1] + preSum[x]-preSum[0] + ... + preSum[N-1]-preSum[N-1-x] \\ 

    &= \sum_{i=x-1}^{N-1}preSum[i]-\sum_{i=0}^{N-1-x}preSum[i] \\

  \end{align*}</script></li>
</ul>
<p>为了加速对长度为 x 的子数组和的计算，可以继续求 preSum 数组的前缀和数组 preSum1，避免多次遍历 preSum 求和。</p>
<p>于是：</p>
<script type="math/tex; mode=display">
\begin{align*}

  Sum_{x} &= \sum_{i=x-1}^{N-1}preSum[i]-\sum_{i=0}^{N-1-x}preSum[i] \\ 

  &= preSum1[N-1]-preSum1[x-2]-preSum1[N-1-x] \\

\end{align*}</script><p>注意 Sum1 的第二项是不存在的。于是可以求解：</p>
<script type="math/tex; mode=display">
Sum_{1}+Sum_{3}+...+Sum_{x}</script><h2 id="树的前缀和"><a href="#树的前缀和" class="headerlink" title="树的前缀和"></a>树的前缀和</h2><h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a>437. 路径总和 III</h3><p>注意这里的路径是单向的，只能从父结点向一个子树延申，而不是任意的一个连通路径</p>
<p>不需要到叶子节点。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/04/05/Redis/</url>
    <content><![CDATA[<p>Redis 是一个 Key-Value 类型的内存数据库</p>
<ul>
<li>纯内存操作，读写性能极高。但容量也受到内存大小的限制</li>
<li>支持数据持久化</li>
<li>数据结构丰富。string、list、hash、set、zset、bitmap</li>
<li>支持多种集群方式。</li>
<li>支持事务</li>
</ul>
<span id="more"></span>
<p>为什么要用缓存</p>
<p>从高并发上来说：直接操作缓存能够承受的请求（QPS）是远远大于直接访问数据库的</p>
<p>从高性能上来说：用户第一次访问数据库中的某些数据。因为是从硬盘上读取的所以这个过程会比较慢。将该用户访问的数据存在缓存中，下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>
<p>使用缓存的问题：数据库和缓存的一致性问题。</p>
<p>写 ：先更新 DB，然后直接删除 cache 。</p>
<p>理论上可能会出现数据不一致的问题，不过概率非常小，因为缓存的写入速度比数据库的写入速度快很多。</p>
<p>先更新 DB，再删除 cache，则数据不一致的的持续时间就是删除 cache 花费的时间，很短</p>
<p>先删除缓存，再改 DB，则数据不一致的的持续时间就是改 DB 的时间，较长，可能由于并发事务带来数据不一致的问题</p>
<p>Redis 除了做缓存，还能做什么？</p>
<ul>
<li><p>业务场景 ：比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</p>
</li>
<li><p>限流 ：一般是通过 Redis + Lua 脚本的方式来实现限流。虽然 redis 官方没有直接提供限流相应的API，但却支持了 Lua 脚本的功能，可以使用它实现令牌桶或漏桶算法。</p>
<blockquote>
<p>令牌桶<br>系统会维护一个令牌（token）桶，以一个恒定的速度往桶里放入令牌（token），这时如果有请求进来想要被处理，则需要先从桶里获取一个令牌（token）<br>漏桶<br>把水比作是请求，漏桶比作是系统处理能力极限，限制流入水的速率 &lt;= 漏水的速率。</p>
<p>相比Redis事务，Lua脚本的优点：</p>
<ul>
<li>减少网络开销：使用 Lua 脚本，无需向 Redis 发送多次请求，执行一次即可，减少网络传输</li>
<li>原子操作：Redis 将整个 Lua 脚本作为一个命令执行，原子，无需担心并发，经常用来执行事务，而不使用 redis 本身的事务功能</li>
<li>复用：Lua 脚本一旦执行，会永久保存 Redis 中,，其他客户端可复用</li>
</ul>
</blockquote>
</li>
<li><p>分布式锁：通常情况下，基于 Redisson 来实现分布式锁。</p>
</li>
</ul>
<p>采用 I/O 多路复用机制处理大量客户端的 Socket 请求，这是基于非阻塞的 I/O 模型。</p>
<p>Redis 没有 IO 阻塞操作，因此设计成了单线程。（抛弃了并发的效率）。Redis 的效率主要与两个因素有关：</p>
<p>其一是机器内存大小，内存大小关系到 Redis 存储的数据量；</p>
<p>其二是网络带宽。</p>
<p>Redis 客户端执行一条命令分为四个过程：发送命令、命令排队、命令执行、返回结果。从发送命令到收到返回的结果，这段时间被称为 Round Trip Time（RTT，往返时间）</p>
<p>Redis 的客户端和服务端可能部署在不同的机器上。例如客户端在北京，Redis 服务端在上海，两地直线距离约为1300 公里，那么 1 次 RTT =1300×2/（300000×2/3）=13毫秒（光在真空中传输速度为每秒30万公里，这里假设光纤为光速的2/3），那么客户端在 1 秒内大约只能执行 80 次左右的命令，这就和 Redis 的高并发高吞吐特性背道而驰啦！所以一般情况下，都是就近部署！</p>
<p>Redis6.0 之后引入了多线程，目的是为了提高网络 IO 读写性能。随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis 的单线程模式会导致系统消耗很多 CPU 时间在网络 I/O 上从而降低吞吐量。（虽然不会阻塞，但占用大量 CPU 时间）。因此，在网络数据的读写操作上使用多线程，提高网络 IO 读写性能，但执行命令仍然是单线程顺序执行。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>可靠数据传输（rdt）协议</title>
    <url>/2022/04/09/Reliable-transmission/</url>
    <content><![CDATA[<p>可靠数据传输协议（reliable data transfer protocol）</p>
<span id="more"></span>
<h1 id="rdt-2-x-协议"><a href="#rdt-2-x-协议" class="headerlink" title="rdt 2.x 协议"></a>rdt 2.x 协议</h1><p><strong>信道特点：信道有差错、无丢包。</strong></p>
<h2 id="rdt-2-0-协议"><a href="#rdt-2-0-协议" class="headerlink" title="rdt 2.0 协议"></a>rdt 2.0 协议</h2><p><img src="/2022/04/09/Reliable-transmission/1647264249043-2355ea05-3c85-48db-831d-d71bd6f9f480-16493429072551-16493811925277.png" alt="rdt2.0 发送端" style="zoom: 80%;"></p>
<p><img src="/2022/04/09/Reliable-transmission/1647264538997-4e356760-a14c-4d0e-90ac-372dedcf20a1-16493429072612-16493812001439.png" alt="rdt2.0 接收端" style="zoom: 80%;"></p>
<p><strong>发送端</strong>：发送数据后，处于等待 ACK/NAK 的状态，若收到 NAK，<strong>重传报文并且继续等待</strong>；若收到 ACK，回到初始状态，等待发送数据。</p>
<p><strong>接收端</strong>：若接收到的数据有损（根据校验和判断），发送 NAK 给发送端；若接收到的数据无损，传送至上层并发送 ACK 给发送端。</p>
<p><strong>存在的问题</strong>：对于发送端，收到的 ACK/NAK 可能是有损的，而状态图并没有考虑到这种情况。</p>
<p><strong>情况分析</strong>：当发送端收到有损的 ACK/NAK 报文，它无法判断发送的数据是否被接收方正确接收（因为可能是 NAK 报文受损，也可能是 ACK 报文受损）。</p>
<p><strong>解决方法</strong>：当发送端收到有损的 ACK/NAK 报文，发送端同样重传报文并且继续等待。<strong>为了让接收方知道这是一次旧报文的重传还是受损报文的重传</strong>（对应于发送端收到无损 NAK），发送端需要给报文添加<strong>序号字段</strong>。对于停等协议，序号只需要 0 和 1 —— rdt 2.1 协议</p>
<h2 id="rdt-2-1-协议"><a href="#rdt-2-1-协议" class="headerlink" title="rdt 2.1 协议"></a>rdt 2.1 协议</h2><p><strong>为了让接收方知道这是一次旧报文的重传还是受损报文的重传</strong>（对应于发送端收到无损 NAK），发送端需要给报文添加<strong>序号字段</strong></p>
<p><img src="/2022/04/09/Reliable-transmission/1647265748305-e77c3ba4-856e-45a9-be13-3a1aff420614.png" alt="rdt2.1 发送端" style="zoom: 80%;"></p>
<p><img src="/2022/04/09/Reliable-transmission/1647265771972-bbae444e-4cec-4133-9431-08b7730102c3.png" alt="rdt2.1 接收端" style="zoom: 80%;"></p>
<p><strong>发送端</strong>：</p>
<p>一开始，发送序号为 0 的报文，如果收到的 ACK/NAK 报文受损，重发序号为 0 的报文并且等待；</p>
<p>如果收到无损 NAK 报文，重发序号为 0 的报文并且等待；如果收到无损 ACK 报文，则等待发送序号为 1 的报文。</p>
<p>发送序号为 1 的报文，……，</p>
<p><strong>接收端</strong>：</p>
<p>一开始，等待序号为 0 的报文，若接收到的数据有损，发送 NAK 给发送端；若接收到的数据无损，且序号为 0，说明正确接收，传送至上层并发送 ACK 给发送端；若接收到的数据无损，且序号为 1，说明接收到了之前上一个报文的重传（上一个报文的序号是 1），丢弃报文并发送 ACK 给发送端，并且等待序号为 0 的报文。</p>
<p>等待序号为 1 的报文，……，</p>
<h2 id="rdt-2-2-协议"><a href="#rdt-2-2-协议" class="headerlink" title="rdt 2.2 协议"></a>rdt 2.2 协议</h2><p><strong>基于 rdt 2.1 协议，只使用 ACK，不使用 NAK。</strong></p>
<p><strong>对于发送端来说，由于现在只会收到 ACK，因此，收到无损 ACK 可能对应 rdt2.1 协议中的两种情况：</strong>收到无损 ACK 报文和收到无损 NAK 报文。</p>
<p>为了让发送端知道现在应该重传序号为 0 的报文并且等待，还是等待发送序号为 1 的报文，接收端也需要为 ACK 报文添加序号，该序号表示 <strong>确认号</strong>，即<strong>接收端已经正确接收到的报文序号</strong>，而<strong>接收端期待接收到的报文序号</strong>应该是：(确认号+1) % N，在停等协议中，N = 2。发送端知道了接收端期待接收的报文序号，也就知道了要重传还是要发新报文。</p>
<p><img src="/2022/04/09/Reliable-transmission/1647267039580-ffcd28d7-2f6e-4612-92e2-d64d24c10057-16493429072623.png" alt="rdt2.2 接收端" style="zoom:80%;"></p>
<h1 id="rdt-3-0-协议"><a href="#rdt-3-0-协议" class="headerlink" title="rdt 3.0 协议"></a>rdt 3.0 协议</h1><p><strong>信道特点：信道有差错和丢包。</strong></p>
<p>丢包的应对就是重传，仅仅只是让状态图内容更多了。</p>
<p>丢包的解决方法：在<strong>发送方</strong>使用基于时间的<strong>重传机制</strong>，<strong>每次发送一个分组就启动一个定时器</strong>，经过一定时间后若还未接收到回传的分组，则定时器响应中断，重传分组。</p>
<p>基于 rdt 2.2 协议，并加入定时检测丢包然后重传的功能，得到如下 rdt 3.0 协议的状态图。其接收端状态图与 rdt 2.2 协议相同。</p>
<p><img src="/2022/04/09/Reliable-transmission/1647267415807-5656ac65-9ab6-495a-ad99-43d7d2e60e16.png" alt="rdt3.0 发送端" style="zoom:80%;"></p>
<p><img src="/2022/04/09/Reliable-transmission/1647267039580-ffcd28d7-2f6e-4612-92e2-d64d24c10057.png" alt="rdt3.0 接收端" style="zoom:80%;"></p>
<h2 id="rdt3-0-协议的性能分析"><a href="#rdt3-0-协议的性能分析" class="headerlink" title="rdt3.0 协议的性能分析"></a>rdt3.0 协议的性能分析</h2><p>假设有两台主机，这两台主机之间往返传播时延 RTT 大约为 30 ms。假设它们通过发送速率 R 为 1Gbps 的信道相连（发送端发送数据进入信道的速率），一个分组的长度 L 为 1000 字节（8000 bit）。发送一个分组进入信道所需时间是：</p>
<script type="math/tex; mode=display">
\frac{L}{R}=\frac{8000}{10^{9}}=8\mu s</script><p>如下图所示。假设 t = 0 时刻，首个分组的第一个比特被传输，则在 t = L/R 时刻，首个分组的最后一个比特被传输。并且，发送方下一次可以传输的时刻是 RTT + L/R，即发送方每个分组的传输时间间隔是 RTT + L/R。</p>
<p><img src="/2022/04/09/Reliable-transmission/image-20220409101710927.png" alt="停等协议发送方信道利用率"></p>
<p>定义发送方（或信道）的利用率为：发送方将分组送进信道的时间与分组发送间隔时间之比：</p>
<script type="math/tex; mode=display">
U_{user}=\frac{L/R}{RTT+L/R}=\frac{0.008}{30}=0.027\%</script><p>可以看到，停等协议有非常低的信道利用率。这就是说，发送方只有 0.027% 的时间是忙的。从吞吐量来看，发送方在 30ms 只能发送 1000 字节，有效的吞吐量为 27 kbps，即使有着 1Gbps 的链路可用。</p>
<blockquote>
<p>上述计算没有考虑发送方和接收方的时延，一旦考虑，则信道利用率更低。</p>
<p>上面，信道利用率讨论的是发送方的信道利用率，也可以讨论接收方的，如果假设接收方的信息速率 R 和发送方一致，则结果相同。</p>
</blockquote>
<h1 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h1><p>rdt 3.0 是一个功能正确的协议，可以处理差错和丢包。但是 rdt3.0 是停等协议，这会导致发送方信道利用率低下。解决的一个简单方法是，允许发送方发送多个分组而无需等待。如果发送方可以在等待确认之前发送 k 个分组，其信道利用率也基本上提高 k 倍。</p>
<p><img src="/2022/04/09/Reliable-transmission/image-20220409103907155.png" alt="流水线发送方信道利用率"></p>
<h2 id="回退-N-步（Go-Back-N，GBN）"><a href="#回退-N-步（Go-Back-N，GBN）" class="headerlink" title="回退 N 步（Go Back N，GBN）"></a>回退 N 步（Go Back N，GBN）</h2><h3 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h3><p><strong>发送方要响应三种事件</strong>：</p>
<ol>
<li><p>上层的调用。当上层调用 rdt_send() 要发送数据时，发送方首先检查发送窗口是否已满，即是否有 N 个「已发送但未确认的分组」，如果窗口未满，则产生一个分组并发送，如果窗口已满，则告知上层窗口已满。</p>
<blockquote>
<p>实际使用中，可以缓存这些分组，分组缓存的位置在发送窗口后面；也可以通过同步机制，让上层只在窗口未满时才调用 rdt_send()</p>
</blockquote>
</li>
<li><p>收到 ACK。接收方所发送 ACK 分组的序号 x 表示接收方已经正确接收序号 &lt;= x 的分组。</p>
<p> 根据 ACK 分组的序号更新 base = x + 1（窗口移动 1 单位），由于接收方采用累计确认，因此 x 和 base 是不断加 1 递增的。如果窗口移动了并且有在窗口内的未发送分组（之前缓存的分组），发送它们。</p>
<ul>
<li>当发送方收到 ACK，仍有「已发送但未确认的分组」，即 x+1 &lt; nextseqnum，重启定时器</li>
<li>当发送方收到 ACK，没有「已发送但未确认的分组」，即 x+1 等于 nextseqnum，关闭定时器</li>
</ul>
</li>
<li><p>超时事件。发送方维护一个定时器，它是最早的已发送但未被确认的分组的定时器。若超时，重启定时器，并且重传所有「已发送但未确认的分组」。</p>
<p> 定时器的维护方式：</p>
<ul>
<li>收到 ACK 时进行维护</li>
<li>发生超时事件时进行维护</li>
</ul>
</li>
</ol>
<p>发送方维护的变量：<strong>发送窗口</strong>：</p>
<ul>
<li>[base, nextseqnum-1] 已发送未被确认</li>
<li>[nextseqnum, base+N-1] 可用还未发送</li>
</ul>
<p>nextseqnum 表示发送方下一个可发的分组的序号</p>
<h3 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h3><ol>
<li>如果一个序号为 n 的分组被正确接收，且按序（即上一次交付给上层的分组序号是 n-1），则接收方交付数据到上层，并发送 ACK，ACK 序号为 n</li>
<li>其他情况，接收方丢弃分组，并为最近按序接收的分组重新发送 ACK</li>
</ol>
<p>接收方维护的变量：expectedseqnum，表示下一个按序接收的分组的序号，表明接收方已正确接收到序号 &lt; expectedseqnum 的所有分组</p>
<p>expectedseqnum 的维护方式：</p>
<p>当接收到序号为 n 的分组，只需要判断 n 是否等于 expectedseqnum 即可。</p>
<ul>
<li>按序接收，ACK 分组的序号等于 expectedseqnum，然后更新，++expectedseqnum</li>
<li>不按序接收，发送上一个 ACK 分组，其序号为 expectedseqnum-1</li>
</ul>
<p><strong>发送方的 base 与 接收方的 expectedseqnum 同步变化。</strong></p>
<h2 id="选择重传（Selective-Repeat，SR）"><a href="#选择重传（Selective-Repeat，SR）" class="headerlink" title="选择重传（Selective Repeat，SR）"></a>选择重传（Selective Repeat，SR）</h2><p>回退 N 步的方案中，接收方不需要缓存失序分组，容易实现。但是由于不缓存失序分组，会导致更多的重传。</p>
<p>选择重传通过让发送方仅重传那些它怀疑在接收方出错的分组而避免不必要的重传。这种个别的、按需的重传方式要求<strong>逐个地确认</strong>正确接收的分组。（回退 N 步是累计确认）</p>
<h3 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h3><p><strong>发送方要响应三种事件</strong>：</p>
<ol>
<li>上层的调用。当从上层收到数据后，发送方检查下一个可用序号，如果序号位于发送窗口内，将数据打包发送，否则，类似地，要么将数据缓存，要么用同步机制控制上层调用的时机。</li>
<li>收到 ACK<ul>
<li>ACK 分组的序号在发送窗口内，将这个序号的分组标记为已接收。</li>
<li>如果该序号为 send_base，则 send_base 向前移动到具有最小序号的未确认分组处。（窗口整个移动）</li>
<li>如果窗口移动了，并且有在窗口内的未发送分组（之前缓存的分组），发送它们</li>
</ul>
</li>
<li>超时事件。发送方为<strong>每个分组</strong>维护一个逻辑定时器，对应分组的定时器超时只需要重启改定时器并重传该分组。可以使用单个硬件定时器模拟多个逻辑定时器</li>
</ol>
<h3 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h3><p><strong>接收方要响应三种事件</strong>：</p>
<ol>
<li>序号在接收窗口内的分组被正确接收<ul>
<li>如果该分组以前没收到过，则缓存该分组。</li>
<li>如果该分组的序号为 rcv_base，则该分组以及 rcv_base 往后缓存的连续分组被交付上层，并移动 rcv_base。（窗口整个移动）</li>
<li>发送 ACK，ACK 的序号是接收到的分组的序号</li>
</ul>
</li>
<li>序号在 [rcv_base-N, rcv_base-1] 内的分组被正确接收，发送 ACK，即使这个分组之前已经被接收方正确接收，ACK 的序号是接收到的分组的序号</li>
<li>其他情况，丢弃分组</li>
</ol>
<h3 id="选择重传需要解决的问题"><a href="#选择重传需要解决的问题" class="headerlink" title="选择重传需要解决的问题"></a>选择重传需要解决的问题</h3><p>选择重传的方式提升了效率，但是代价是窗口同步问题。（回退 N 步没有）</p>
<h4 id="窗口同步问题"><a href="#窗口同步问题" class="headerlink" title="窗口同步问题"></a>窗口同步问题</h4><p>发送窗口和接收窗口可能存在不同步的问题，即 send_base != rcv_base</p>
<p><strong>原因</strong></p>
<p>接收方根据 数据分组序号信息移动接收窗口，并发送 ACK 分组。发送方根据 ACK 分组的序号移动发送窗口，如果 ACK 分组错误或者丢失，则发送方发送窗口无法正确被标记。</p>
<p><strong>发送窗口的滞后</strong></p>
<p>接收窗口先移动，发送窗口只能与接收窗口同步，或者滞后。</p>
<p>至多滞后 N 个序号，这是因为接收窗口最多一次移动 N 步，而发送窗口可能由于序号为 rcv_base 的 ACK 分组丢失或者出错，连一步都移动不了</p>
<p><strong>示例</strong></p>
<p>发送方发送 0 到 4 号分组，传输到接收方</p>
<p><img src="/2022/04/09/Reliable-transmission/1648559215136-0532653f-1536-43e4-8f9a-a65e32c8b7dd-16493429072624.png" alt="(a)"></p>
<p>接收方接收，并返回 0 到 4 号 ACK，接收窗口向前滑动5个位置</p>
<p><img src="/2022/04/09/Reliable-transmission/1648559215290-9e8dccff-ae82-435b-9ef7-a01ce588bee0-16493429072625.png" alt="(b)"></p>
<p>0 到 4 号 ACK 传输到达发送方，但是 0 号 ACK 丢失，发送方接收 1 到 4 号 ACK，并记录 1 到 4 号 分组已收到确认，但是发送窗口不能向前移动。</p>
<p>一段时间后，0 号分组计时器超时，重传 0 号分组，传输到达接收方，接收方接收该分组并反馈 0 号 ACK，若发送方能正确接收该 ACK，则发送窗口也移动到 send_base = 5</p>
<h4 id="有限序号范围问题"><a href="#有限序号范围问题" class="headerlink" title="有限序号范围问题"></a>有限序号范围问题</h4><p>实际上，这也是因为发送窗口和接收窗口不同步。</p>
<p>当窗口长度为 N，实际上是这样的，0,N-1…，长度为 N 的窗口滑动，但是索引值却并非在 0~N-1 取值，索引值 % N = 序号。如果窗口长度过大，接收方可能无法判断分组是新分组还是旧分组的重传。</p>
<p><img src="/2022/04/09/Reliable-transmission/1641715373288-1bffa27c-c45d-44ee-a971-9f57bb9aa4c4-16493429072626.png" alt="img" style="zoom: 67%;"></p>
<p><img src="/2022/04/09/Reliable-transmission/1641715247816-3e91619a-488b-4b8e-89e1-d512dd2fcaea-16493429072627.png" alt="img"></p>
<p>此时接收方窗口的序号是3、0、1，而接收到序号0的分组，无法判断是应该在新的 0 序号对应的分组还是上个窗口的 0 重传</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟化</title>
    <url>/2022/04/05/Virtualization/</url>
    <content><![CDATA[<p>操作系统的虚拟化技术包括虚拟地址空间、虚拟 CPU</p>
<p>虚拟地址空间主要是为了提供一个易用的物理内存抽象，实现内核与用户、进程与进程空间的隔离；虚拟化 CPU 包括 CPU 模式和中断切换，主要是为了实现对系统的安全访问和多进程的并行</p>
<span id="more"></span>
<h1 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h1><p>以 32 位操作系统举例，它的寻址空间为 4G = 2 的 32 次方，一个字节大小的内存单元对应一个地址</p>
<p>为什么叫虚拟，因为物理内存一共就 4G，但操作系统为<strong>每一个进程都分配了4G的内存空间，这个内存空间是虚拟的</strong>。以 linux 操作系统为例，每个进程 4G 的虚拟内存，将最高的 1G 字节供内核使用，称为内核空间，而将较低的 3G 字节，供各个进程使用，称为用户空间。</p>
<blockquote>
<p>如果你在一个程序中打印出一个地址，那只是一个虚拟地址。虚拟地址只是提供地址如何在内存中分布的假象，只有操作系统（和硬件）才知道物理地址。</p>
</blockquote>
<h2 id="虚拟地址空间的构成"><a href="#虚拟地址空间的构成" class="headerlink" title="虚拟地址空间的构成"></a>虚拟地址空间的构成</h2><p>包括内核空间和用户空间，如下图所示。</p>
<p><img src="/2022/04/05/Virtualization/1642770176746-362621fb-2a65-447d-a7e6-d0f10f18e8f6.png" alt="内核空间和用户空间"></p>
<h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>与进程相关的数据结构。例如<strong>页表、进程控制块、内核栈</strong>等。</p>
<ul>
<li>不同的进程共享同一个内核空间，这表示：所有进程内核空间映射到同一个物理地址空间</li>
<li>不同的进程在内核空间中的页表、PCB 和内核栈等资源独立，而共享内核空间中的内核代码和内核数据等。<ul>
<li>每个进程的页表管理的空间包含用户空间和内核空间，页表管理的内核空间可以帮助进程找到自己在内核空间中独立的那部分资源（即 PCB、内核栈等）</li>
<li>进程 A 切换到进程 B 时把进程信息 PCBA 压入内核栈 A，进程 B 切换到进程 C 时把进程信息 PCBB 压入内核栈 B。</li>
<li>内核代码所使用的栈是进程的内核栈，并且，各个进程的内核栈是独立的，也就是说，操作系统在各个进程中锁表现的状态是不一样的。</li>
</ul>
</li>
</ul>
<h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><p>代码：编译链接生成的可执行文件是汇编指令，汇编指令以二进制形式装载到内存中，每条指令可用几个字节存储。</p>
<p>栈：存放临时变量。通过栈的推入和弹出处理临时变量</p>
<p>堆：非局部变量生命周期较长，通常很多个方法中都会用到，由程序员自主使用内存 API 函数分配回收。</p>
<p>静态区（全局区）：存储全局变量和静态变量，分为初始化和未初始化两个分区。</p>
<blockquote>
<p>图示堆栈生长方式只是一种约定，当多个线程（threads）在地址空间中共存时，就没有像这样分配空间的好办法了</p>
<p><strong>虚拟空间地址连续，会映射到不连续的物理空间</strong></p>
</blockquote>
<h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><p>操作系统是一个程序，但不能称作进程。它管理着进程，进程是有生命周期的，操作系统是永存的。<strong>操作系统的运行也同样要占用CPU</strong></p>
<p>在操作系统这个程序中，为了跟踪每个进程的状态，使用了如下数据结构</p>
<ul>
<li>进程控制块（PCB， process control block）</li>
<li>进程列表（process list）</li>
</ul>
<p>如下是一个进程控制块，进程控制块包括了上下文信息、进程状态和为进程分配的内存、文件资源等信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寄存器上下文（register context）</span></span><br><span class="line"><span class="comment">// the registers xv6 will save and restore </span></span><br><span class="line"><span class="comment">// to stop and subsequently restart a process </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span> </span><br><span class="line">  <span class="type">int</span> eip; </span><br><span class="line">  <span class="type">int</span> esp; </span><br><span class="line">  <span class="type">int</span> ebp; </span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> ebx; </span><br><span class="line">  <span class="type">int</span> ecx; </span><br><span class="line">  <span class="type">int</span> edx; </span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> esi; </span><br><span class="line">  <span class="type">int</span> edi; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 进程状态枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span> UNUSED, EMBRYO, SLEEPING, </span><br><span class="line">                  RUNNABLE, RUNNING, ZOMBIE &#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// the information xv6 tracks about each process </span></span><br><span class="line"><span class="comment">// including its register context and state </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span> </span><br><span class="line">	<span class="comment">// 内存设置</span></span><br><span class="line">  <span class="type">char</span> *mem;                   <span class="comment">// Start of process memory </span></span><br><span class="line">  uint sz;                     <span class="comment">// Size of process memory </span></span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> *kstack;                <span class="comment">// Bottom of kernel stack </span></span><br><span class="line">                               <span class="comment">// for this process </span></span><br><span class="line">                              </span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>       <span class="comment">// Process state </span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process </span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan </span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed </span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory </span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// // 上下文切换 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>        <span class="comment">// Trap frame（栈帧） for the current interrupt</span></span><br><span class="line">                               <span class="comment">// 栈帧也是一个包含多个寄存器的结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="内核空间和用户空间的切换"><a href="#内核空间和用户空间的切换" class="headerlink" title="内核空间和用户空间的切换"></a>内核空间和用户空间的切换</h3><p>发生系统调用时进行的是模式切换而非进程切换。</p>
<p><strong>模式切换</strong>：仅仅需要寄存器进栈出栈，不会导致 CPU 中的数据缓存失效、MMU 中的页表缓存失效</p>
<p><strong>进程切换</strong>：不仅需要寄存器进栈出栈，还会使 CPU 中的数据缓存失效、MMU 中的页表缓存失效（缓存失效是必须的，因为要切换到另一个进程的地址空间）</p>
<blockquote>
<p>代码里面具有各个语句和各个变量的虚拟地址，当进程切换之后，页表也会更新，根据自己进程的页表来找物理内存</p>
</blockquote>
<p>虚拟地址空间切换实际上指的是用户空间的切换，通过切换页表来实现。页表切换后 TLB 就失效了，页表缓存失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致 TLB 失效，因为线程无需切换地址空间。</p>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>调度：进程是资源管理的基本单位，线程是程序执行的基本单位。</p>
<p>系统开销：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O 设备等。创建线程：内核空间分配 TLB 等，用户空间分配栈。</p>
<p>进程切换分两步：</p>
<ol>
<li>切换页表以使用新的地址空间，这会导致 TLB 失效。</li>
<li>切换内核栈和硬件上下文（例如进程控制块和线程控制块）。</li>
</ol>
<p>对于线程切换，第 1 步是不需要做的，因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，第 2 步是进程和线程切换都要做的。</p>
<h3 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h3><p>程序中调用时发生系统调用</p>
<p>fork</p>
<ul>
<li>一个现有进程可以调用 fork() 创建一个新进程，该新进程被称为<strong>子进程</strong>（child process），调用fork的进程称为<strong>父进程</strong>。</li>
<li><p>子进程通过拷贝的方式，获得 此时的 父进程地址空间副本（包括堆、栈等资源）。</p>
</li>
<li><ul>
<li>父进程处于等待 fork 返回的状态。因此，子进程复制之后，在 fork() 被调用之前的代码不会被执行，且两个进程都停留在 fork 函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回<ul>
<li>子进程中返回 0，而父进程中返回子进程 ID。</li>
</ul>
</li>
</ul>
</li>
<li><p>作用：运行相同程序的拷贝</p>
</li>
</ul>
<p>exec</p>
<ul>
<li><p>exec指的是一个函数簇，包括execlp()、execv()和execvp()等</p>
</li>
<li><p>函数原型：</p>
<p>  int execvp(const char <em>file, char </em>const argv[]); // file为需要运行的文件名，argv[]为输入的参数列表</p>
</li>
<li><p>给定可执行程序的名称及该程序需要的参数后，exec() 会从该程序中加载代码和静态数据，并用它 <strong>覆写</strong> 自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新<strong>初始化</strong>。然后操作系统就执行该程序，将参数 argv 传递给该进程。——并没有创建新进程，而是直接将当前运行的程序替换为另一个程序</p>
</li>
<li>调用了 exec() 的程序，exec() 之后的语句不会被执行</li>
</ul>
<h2 id="虚拟地址到物理地址的映射"><a href="#虚拟地址到物理地址的映射" class="headerlink" title="虚拟地址到物理地址的映射"></a>虚拟地址到物理地址的映射</h2><p>一个基本的负责地址转换的<strong>内存管理单元</strong>（Memory Management Unit，MMU）需要包含：<strong>基址寄存器、界限寄存器</strong>。</p>
<ul>
<li>基本的映射方法：基址 + 偏移</li>
<li>每个进程分配的空间有限，并且不能访问别人的空间，因此需要<strong>界限寄存器</strong></li>
</ul>
<p>如果只使用基址和界限，为进程分配一块连续的物理内存，容易产生<strong>内部碎片</strong>（internal fragmentation），指的是<strong>已经分配的内存单元内部有未使用的空间</strong>（即碎片），造成了浪费。主要是堆栈空间冗余。</p>
<p>进程需要把用到的基址和界限寄存器中的内容保存在内存中，放在某种每个进程都有的结构中，例如进程控制块（Process Control Block，PCB）中。类似地，当操作系统恢复执行某个进程时（或第一次执行），也必须给基址和界限寄存器设置正确的值。</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>为了减少内部碎片，可以采用<strong>分段</strong>（segmentation）的方法为进程分配内存。分段法将用户空间看成几个段的组合，每个段具有自己的基址和界限，不同段分配的空间可以不连续。</p>
<p><img src="/2022/04/05/Virtualization/1643438704868-7d431f3d-de31-497f-8400-36fd33dbc504.png" alt="段寄存器"></p>
<p>注意到栈向低地址生长，地址范围 28 KB ~ 26 KB。其他段向高地址生长。如果试图访问的虚拟地址不在段内，会发生段异常（segmentation violation）或段错误（segmentation fault）</p>
<p>分段只能减少内部碎片，而不能完全避免内部碎片，总得多分配一点保证程序运行。</p>
<p>分段的问题</p>
<ul>
<li><p>分段操作相关的寄存器在每次 cpu 模式切换时需要存储和恢复</p>
</li>
<li><p>段不连续且不均匀分配，导致物理内存在各个位置充满大小不一致的碎片，因而很难将物理内存分配给新的段，或扩大已有的段。这种问题被称为<strong>外部碎片</strong>。</p>
<blockquote>
<p>解决方法：紧凑、空闲列表管理</p>
</blockquote>
</li>
</ul>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>为虚拟空间分配物理内存时以页（page）为单位分配。即将虚拟空间分成多个页，每个页对应一个物理帧。</p>
<p>页表（page table）保存了<strong>页</strong>（<strong>虚拟</strong>地址空间）和物理帧（<strong>物理内存</strong>空间）的映射关系。</p>
<blockquote>
<p>物理帧不是硬盘空间/外存的单元 </p>
</blockquote>
<p>虚拟页面号（virtual page number，VPN）和页内的偏移量（offset）组成一个虚拟地址。假设进程的虚拟地址空间是 64 字节，每页大小 16 字节，共 4 个页。那么虚拟地址需要用 6 位描述，前两位是虚拟页号（VPN），用来区分不同的页，后四位区分一个页中的不同字节。例如，虚拟地址 = 010101，VPN=1，offset=5，表示第 1 页第5 个字节。</p>
<p>操作系统会将物理内存分成多个物理帧，物理帧和帧内的偏移量组成一个物理地址。假设第 1 页对应的物理帧号是 7，如图所示。则虚拟地址 010101 对应的物理地址是 112+5 = 117 = 1110101（图中物理帧 0~15，16~31，…）</p>
<p><img src="/2022/04/05/Virtualization/1643442576051-58a6712b-62dd-4570-abec-25a272edc855.png" alt="虚拟页与物理帧的对应关系"></p>
<p>页表是一个数据表，进程创建时由操作系统为其生成对应页表（分配物理内存空间）。页表由页表项（<strong>PTE</strong>）组成，第 i 个页表项存储了 VPN = i 的虚拟页的信息，包括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>物理帧号 PFN</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>有效位</td>
<td>是否为该虚拟页分配物理帧</td>
</tr>
<tr>
<td>存在位（present bit）</td>
<td>表示该页是否被调入内存中（有可能暂存硬盘），=1表示被调入内存</td>
</tr>
<tr>
<td>脏位（dirty bit）</td>
<td>表示页面在调入内存后是否被修改过，供时钟置换算法及调出页面时是否要回写到外存后是否被</td>
</tr>
<tr>
<td>参考位（reference bit，也被称为访问位，accessed bit）</td>
<td>记录本页一段时间内的访问次数，或记录本页多久未被访问</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>如果有效位是1，该PTE中就会存储物理内存中相应的物理页的起始地址。如果有效位是0，且PTE中的地址为null，这表示这个虚拟页还未被分配，而如果有效位是0且PTE中有地址，那么这个地址指向该虚拟页在磁盘上的起始位置</p>
<p>用有效位和存在位一起判断？</p>
</blockquote>
<p><strong>页表在内核空间中</strong>。如果页表在用户空间，那么用户就可能自己修改页表，从而访问任何内存（其他进程专用的、操作系统专用的）</p>
<p>页式访问机制会产生两个问题</p>
<ul>
<li><p>内存访问性能：访问一个内存单元需要2次内存访问，第一次访问页表，确定数据的物理地址，第二次访问数据。访问页表的步骤可以加速。</p>
</li>
<li><p>页表大小：页表可能很大，占据大量内存，导致内存利用效率降低。</p>
</li>
</ul>
<p><strong>快表</strong></p>
<p>为了改善内存访问性能，利用局部性原理加速访问页表的步骤——将常访问的页面保存至 CPU 缓存，该缓存称为<strong>地址变换高速缓存</strong>（Translation Look-aside Buffer，TLB），又可称为快表。配置快表后，CPU 访问页面会先去查看快表内是否存在，然后再去查看主存的页表。</p>
<p>例：某一页式系统，其页表存放在主存中：</p>
<p>(1) 如果对主存的一次存取需要 1.5μs，试问实现一次页面访问时存取时间是多少？</p>
<p>答：页式访问需要访存两次，一次页表，一次数据，所以需要 1.5∗2=3μs。</p>
<p>(2)如果系统有快表且其平均命中率为 85%，而页标项在快表查询的时间可忽略不计，试问此时的存取时间为多少？</p>
<p>答：快表命中时访存一次，未命中时访存两次，所以需要 0.85∗1.5+0.15∗3=1.725μs。（0.85概率找到页表项，0.15概率没有找到页表项，此时需要到主存的页表再去找）</p>
<p><strong>多级页表</strong></p>
<p>页表大小问题可以通过多级页表的方法优化。</p>
<p>分割：将庞大的页表分成多张较小的页表，并设置一张页目录表。逻辑地址的虚页号进一步划分为页目录号和虚页号，页目录号用于查询页表，虚页号用于查询物理帧号。</p>
<p>按需调入：进程执行开始时只需要将页目录表调入内存，然后次级页表和页面可以在后面执行需要时再调入。同时，</p>
<p>假设有 256 个虚拟页，可以拆分为 16*16 个部分，以 16 个页表项为一页（这里是页表页，而不是之前的虚拟页）。虚页号此时是 相对虚页号，即 16 个页 0~15，而非绝对虚页号，即 256 个页 0~255</p>
<h4 id="页面置换算法-cache淘汰算法"><a href="#页面置换算法-cache淘汰算法" class="headerlink" title="页面置换算法/cache淘汰算法"></a>页面置换算法/cache淘汰算法</h4><p>什么是交换空间？</p>
<p>用于与内存换入换出的硬盘空间。操作系统把物理内存进行分页。当内存资源不足时，把某些页的内容转移至硬盘上的一块空间上，以释放内存空间。硬盘上的那块空间叫做交换空间（swap space）,而这一过程被称为交换。物理内存和交换空间的总容量就是虚拟内存的可用容量</p>
<p>在程序运行过程中，如果要访问的页面不在内存中（根据页表项的存在位判断），就发生缺页中断从而将该页调入内存中。此时</p>
<ul>
<li><strong>如果内存已无空闲空间</strong>，CPU通知操作系统将暂时不用的页面 <strong>换出</strong> 到外存，将腾出的内存分配给要访问的页面，要访问的页面在外存，需要将其重新 <strong>换入</strong> 内存。</li>
<li>如果内存有空闲物理页帧，操作系统将页面装入内存，并页表项填入页帧号，存在位修改为1</li>
</ul>
<blockquote>
<p>生成进程时，就要为所有页面分配物理帧，也会发生缺页中断。因此，要访问的页面不在内存中必定在外存，不会临时再生成</p>
</blockquote>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）</p>
<p><strong>局部页面置换</strong>：置换页面的选择范围仅限于 当前进程 占用的物理页面内（进程内）</p>
<p><strong>最佳置换</strong>（OPT, Optimal replacement algorithm）</p>
<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<p>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1 </p>
<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长</p>
<p><strong>最近最少使用</strong>（LRU, Least Recently Used）</p>
<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最少使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时</p>
<ul>
<li>页面在链表中存在，将这个页面移到链表表头。</li>
<li>页面在链表中不存在，将其插入到表头</li>
</ul>
<p>这样就能保<strong>证链表表尾的页面是最近最久未访问的</strong>。</p>
<p>实现方式：LinkedHashMap（JAVA）,使用哈希表作为缓存，对应的实际上是硬件 TLB</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<p>4，7，0，7，1，0，1，2，1，2，6</p>
<p>上方是表头，设页数上限为5。链表变化过程如图</p>
<p><img src="/2022/04/05/Virtualization/1643691165540-3cc3a1fe-245c-4ffb-997f-90d3987f7e9c.png" alt="LRU 过程示意"></p>
<p><strong>LRU 和 LFU 的优缺点</strong></p>
<p>LRU </p>
<p>优点：实现简单，通常具有高命中率</p>
<p>缺点：如果一些不常使用的数据一次性出现过多，那么链表表头都是无用的数据，从而会导致缓存命中率低下</p>
<p>LFU 缺点</p>
<ul>
<li>需要为每个记录项维护频率信息，带来额外开销</li>
<li>对突发性的稀疏流量无力，因为前期经常访问的记录已经占用了缓存，偶然的流量不太可能会被保留下来，而且过去的一些大量被访问的记录在将来也不一定会使用上，这样就一直把“坑”占着了。</li>
</ul>
<p>LFU优点：如果数据的分布在一段时间内是固定的话，那么LFU可以达到最高的命中率</p>
<p><strong>先进先出</strong></p>
<p>使用队列，最新进入的页面放在表尾，最早进入的页面放在表头。当缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。</p>
<ul>
<li>问题 可能会把有用的页面淘汰掉。（即此时加入的页面之前已存在）</li>
<li>改进 第二次机会算法（SCR，Second Chance Replacement Policy），基于 second chance 位维护最早页面指针</li>
</ul>
<p>第二次机会算法</p>
<p>数据结构：链表、最早页面指针</p>
<p>每个页面有一个 second chance 位，也叫做引用位。上面叫做 参考位/访问位</p>
<p>当一个页面被二次引用，它的 second chance 位设置为1。这表示该页面后面还有可能会被引用到，所以下次置换先跳过这个页面，也就是再给它一次机会留在内存中。这样可以减少页面置换。</p>
<p>步骤</p>
<ul>
<li><p>引用一个界面时，先用一个 遍历指针 从头到尾查找页面在链表中是否存在</p>
</li>
<li><ul>
<li>如果到尾部、未查找到、且有剩余空间，加入页面，它的 second chance 被设置为 0，最早页面指针后移一位<ul>
<li>如果已经分配物理内存/在链表中，它的 second chance 被设置为1</li>
<li>如果到尾部、未查找到、且无剩余空间。需要替换内存中的一个页面，从 <strong>最早页面指针</strong> 往后查找可以被替换的页面：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果页面的 second chance 是1，那么置为0，最早页面指针后移一位；<ul>
<li>如果页面的 second chance 是0，那么将这个页面置换出去，最早页面指针后移一位。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意下图中 最早页面指针（蓝色箭头） 的变化</p>
<p><img src="/2022/04/05/Virtualization/1643693169495-5747d18e-5424-4b59-9b6c-09bdb5590391.png" alt="第二次机会算法"></p>
<h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p><strong>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</strong></p>
<p>虚拟地址空间首先划分为若干个段，每段都有自己的段号，然后每段分成若干个大小固定的页，相应的内存划分为和页面大小的物理帧。</p>
<p>逻辑地址结构</p>
<p>段页式的逻辑地址由段号(segment)、虚页号(virtual page number) 和页内偏移(offset) 组成</p>
<p>硬件支持</p>
<p>段页式存储管理方式的硬件支持包括段表和页表。段表项代表进程的一个段，段表项包括段号、段长，但<strong>段基址实际上是页表基址</strong>。</p>
<p>例如，段基址指向页表的第 2 个页表项，虚页号为 3，则找到第 5 个页表项。虚页号是相对虚页号，而非绝对虚页号。</p>
<h1 id="虚拟-CPU"><a href="#虚拟-CPU" class="headerlink" title="虚拟 CPU"></a>虚拟 CPU</h1><p>采用时分共享，每个进程轮流运行一段时间，进程并发执行，产生有多个 CPU 的假象</p>
<p>安全：在进程占用 CPU 时，对它的权限进行限制；</p>
<p>可控：操作系统能控制进程的运行。时分共享 CPU 方式存在的问题 —— <strong>如果一个进程在CPU 上运行，这就意味着操作系统没有运行。</strong></p>
<p>手段—— <strong>CPU 双模式</strong>（安全）、<strong>控制权转移</strong>（可控）</p>
<h2 id="CPU-双模式"><a href="#CPU-双模式" class="headerlink" title="CPU 双模式"></a>CPU 双模式</h2><p>将操作系统的运行状态分为用户态和内核态，主要是为了<strong>对访问能力进行限制</strong>，防止随意进行一些比较危险的操作导致系统的崩溃</p>
<p><strong>用户模式</strong></p>
<ul>
<li>用户空间——应用程序的代码和数据</li>
<li>可执行非特权指令</li>
</ul>
<p><strong>内核模式</strong></p>
<ul>
<li><p>内核空间——存放的是操作系统内核代码和数据（如进程控制块和进程列表等）</p>
</li>
<li><p><strong>可执行特权指令，可以访问一切内存和寄存器</strong></p>
</li>
<li><p>切换到内核模式的方式——执行系统调用</p>
<p>在用户模式执行系统调用的方式——调用操作系统提供的 API，例如读取文件、创建和销毁进程、与其他进程通信，以及分配更多内存</p>
<p>陷阱表（trap table）记录了相关处理程序的位置。</p>
<p><strong>执行系统调用将发生什么？</strong></p>
<ul>
<li>执行陷阱指令，进入内核模式</li>
<li>保存进程信息（例如进程控制块）到内核栈</li>
<li>查找陷阱表，执行对应处理程序</li>
<li>执行从陷阱返回指令，从内核栈恢复寄存器，回到用户模式</li>
</ul>
</li>
</ul>
<p>当陷入内核，执行的都属于操作系统的程序，相当于操作系统接管了 CPU</p>
<p><img src="https://cdn.nlark.com/yuque/__puml/19d56db61d9fe6cdb199e9e3e11ab4e7.svg" alt></p>
<p>Intel 的 x86 处理器 可以运行在 ring0 ~ ring3 四个不同的权限级别。不过 Linux 和 Windows 只利用了其中的两个运行级别：</p>
<p>内核模式，对应 ring0 级<br>用户模式，对应 ring3 级</p>
<h2 id="控制权转移"><a href="#控制权转移" class="headerlink" title="控制权转移"></a>控制权转移</h2><p>协作方式——程序在最后执行系统调用交还控制权</p>
<p>非协作方式——利用时钟中断重新获得控制权</p>
<p>中断的处理过程</p>
<ol>
<li>保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。</li>
<li>开中断：以便执行中断时能响应较高级别的中断请求。</li>
<li>中断处理</li>
<li>关中断：保证恢复现场时不被新中断打扰</li>
<li>恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态</li>
</ol>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度策略相关概念"><a href="#调度策略相关概念" class="headerlink" title="调度策略相关概念"></a>调度策略相关概念</h3><p><strong>抢占与非抢占</strong></p>
<p>抢占式：当有比正在运行的进程<strong>优先级</strong>更高的进程就绪时，系统可强行剥夺当前运行进程的 CPU 使用权，提供给更高优先级的进程使用。</p>
<p>非抢占式：某一进程被调度运行后，除非自身原因导致不能运行，否则一直运行下去。</p>
<p><strong>I/O 密集型和 CPU 密集型进程</strong></p>
<p>I/O 密集型：需要频繁地进行 I/O 操作的进程。 I/O 操作会阻塞进程</p>
<p>CPU 密集型：需要大量的 CPU 时间进行计算。</p>
<h3 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h3><ul>
<li><p><strong>周转时间</strong>（Turnaround Time）：每个进程从提出请求到运行完成的时间。运行完成时刻 - 任务到达时刻</p>
</li>
<li><p>加权周转时间（Turnaround Time With Weight）：周转时间与实际运行时间的比值。</p>
</li>
<li><p>等待时间：进程处于等待CPU调度的时间之和。</p>
</li>
<li><p><strong>响应时间</strong>：从提出请求到第一次回应的时间。</p>
</li>
<li><p>公平性（Fairness）：保证每个进程都能获得一定程度的CPU时间。</p>
</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>批处理系统没有太多的用户操作，在该系统中，调度算法（即以下四种算法）目标是保证吞吐量和<strong>周转时间</strong>。</p>
<p><strong>先来先服务</strong>（first-come first-serverd，FCFS）</p>
<ul>
<li><strong>非抢占式</strong>，按照请求的顺序进行调度。</li>
<li>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行</li>
</ul>
<p><strong>最短作业优先</strong>（shortest job first，SJF）</p>
<ul>
<li><strong>非抢占式</strong>，按运行时间最短（假设操作系统知道每个任务用时）的顺序进行调度。区别于 STCF</li>
<li>有利于短作业，但不利于长作业。因为如果一直有短作业到来，那么长作业永远得不到调度。</li>
</ul>
<p><strong>最短完成时间优先</strong>（Shortest Time-to-Completion First，STCF）</p>
<ul>
<li><strong>最短作业优先的抢占式版本</strong>。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，<strong>则挂起当前进程，运行新的进程</strong>。否则新的进程等待。</li>
</ul>
<p><strong>最高响应比优先</strong>（Highest Response Ratio Next, HRRN)</p>
<p>是对 FCFS 和 SJF 的综合平衡，调度时计算每个进程的响应比 R ，总是选择 R 最高的进程执行，属于<strong>非抢占式</strong>调度算法。</p>
<p><img src="/2022/04/05/Virtualization/1643024036695-ef32003d-a133-42c3-9347-7c8e035b9784.png" alt></p>
<p>当等待时间相同时，则运行时间越短响应比越高，实现短作业优先（SJF)</p>
<p>当运行时间相同时，等待时间越长响应比越高，实现先来先服务（FCFS）</p>
<p>实际上等价于将调度队列的各个任务按照 R 排序，R 大的在队头。</p>
<h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法（即以下三种算法）的目标是<strong>减少响应时间</strong>。即</p>
<p><strong>时间片轮转</strong>（Round Robin，RR）</p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，<strong>并将它送往就绪队列的末尾</strong>，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的<strong>效率</strong>和<strong>时间片的大小</strong>有很大关系：</p>
<ul>
<li>时间片太小，会导致进程频繁切换，浪费资源。</li>
<li>时间片过长，以至于所有进程都能在一个时间片内执行完毕，则 RR 算法退化成为 FCFS 算法。</li>
</ul>
<p><strong>优先级调度</strong>（Highest Priority First，HPF）</p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>多级反馈队列</strong>（Multi-Level Feedback Queue，MLFQ）</p>
<p>基本思想</p>
<ul>
<li>减少周转时间：通过先执行短工作来实现（SJF），然而，操作系统通常不知道工作要运行多久</li>
<li>减少响应时间：轮转。轮转算法虽然降低了响应时间，周转时间却很差。</li>
</ul>
<p>关键问题：没有工作长度的先验信息，不知道工作要运行多久，如何设计一个能同时减少响应时间和周转时间的调度程序——也就是，让短工作先执行，并且要加入轮转</p>
<p>MLFQ 将刚到的工作假设为短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ近似于SJF</p>
<p>多级反馈队列算法(MLFQ)是 RR 算法和 HPF 算法的综合平衡，<strong>动态调整进程的优先级和时间片大小</strong>，实现思想如下：</p>
<ol>
<li>设置多个就绪队列，并为每个队列赋予不同的优先级，第 1 级队列的优先级最高，第 2 级队列次之，其余队列的优先级逐次降低； 优先级越高的队列，每个进程的运行时间片越小（当作短任务）。即便进程被阻塞，也正常计算其占用时间</li>
<li>当一个新进程进入内存后，首先放入第 1 级队列的末尾，按 FCFS 的原则排队等待调度。当该进程执行时，如果其能在时间片内完成便撤离系统；如果它在一个时间片结束未完成，该进程进入第 2 级队列按照 FCFS 的原则等待调度，以此类推。对于最后一级队列，进程执行一个时间片结束未完成会回到该队列的队尾。（如图中的环，如果前面队列的任务过多，可能导致饥饿问题）</li>
<li>仅当第 1 级队列为空时，调度程序才调度第 2 级队列的进程进行执行，以此类推。</li>
</ol>
<p><img src="/2022/04/05/Virtualization/1643033924079-f75ee3ea-89da-44bb-bcfb-b1b8055447d1.png" alt="多级反馈队列"></p>
<p>优点：</p>
<p>短作业可以在前面的队列内完成，长作业可以得到部分执行。</p>
<p>交互型作业通常较短，系统只要能使其第1级队列所规定的时间片内完成，即可使终端用户感到满意。</p>
<p>不必人为估计进程的执行时间。</p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要切换 100 次。</p>
<p>假设多级队列从队列 1 开始分配的时间片为 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要切换 7 次。1+2+4+8+16+32+64</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/2022/04/07/app-layer/</url>
    <content><![CDATA[<h1 id="网络分层结构"><a href="#网络分层结构" class="headerlink" title="网络分层结构"></a>网络分层结构</h1><p><strong>TCP/IP 五层模型：应用层、传输层、网络层、数据链路层、物理层</strong><br><span id="more"></span><br>应用层：为应用程序提供服务，数据单位称为报文</p>
<ul>
<li>HTTP</li>
<li>DNS（Domain Name System），将域名转化为 IP 地址</li>
<li>FTP（File Transfer Protocol），文件传输协议</li>
<li>SMTP（Simple Mail Transfer Protocol）</li>
</ul>
<p>传输层：为主机间进程通信提供服务，数据单位称为报文段</p>
<ul>
<li>TCP（Transmission Control Protocol）</li>
<li>UDP（User Datagram Protocol）</li>
</ul>
<p>网络层：为主机之间的逻辑通信（IP寻址）提供服务，选择合适的路由和交换结点，数据单位称为数据报</p>
<ul>
<li>IP（Internet Protocol），定义了 IP 数据报的字段以及端系统和路由器如何处理 IP 数据报</li>
<li>路由选择协议：IP 数据报根据什么样的路由从源传输到目的</li>
<li>ICMP，因特网控制报文协议</li>
</ul>
<p>链路层：将 IP 数据报组装成帧，数据单位称为帧</p>
<blockquote>
<p>封装：一个应用层报文向下层传输时被附加下层的首部字段，每层的数据包含两部分，即本层首部字段和有效载荷（上一层的数据）</p>
<p>封装的目的：对于每一层的用户来说，只需要考虑本层的协议。</p>
</blockquote>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS（Domain Name System，域名系统）</p>
<ul>
<li>由分层的 DNS 服务器实现的分布式数据库，包括根域名服务器、顶级域名服务器（Top-Level Domain，TLD）和权威域名服务器</li>
<li>用于查询该分布式数据库的协议</li>
</ul>
<blockquote>
<p>根域名服务器：记录了顶级域名服务器的 IP 地址</p>
<p>顶级域名服务器：例如 .com 服务器，存放了 *.com 服务器的 IP 地址</p>
<p>权威域名服务器：例如 baidu.com，存放了 *.baidu.com 服务器的 IP 地址</p>
<p>DNS 通常运行在 UDP 之上，也可以运行在 TCP 之上，统一使用 53 号端口（DNS 服务器开 53 号端口）</p>
</blockquote>
<h3 id="DNS-查询过程"><a href="#DNS-查询过程" class="headerlink" title="DNS 查询过程"></a>DNS 查询过程</h3><p><strong>递归查询</strong></p>
<p>当 DNS 服务器接收到请求，如果 DNS 服务器本地没有存储查询的 DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。</p>
<p><strong>迭代查询</strong></p>
<p>DNS 服务器若没有可以响应的结果，会向客户机提供其他能够解析查询请求的 DNS 服务器地址，客户机根据此地址，向另一台 DNS 服务器提交请求， 不断重复直到得到查询的结果为止。</p>
<p><img src="/2022/04/07/app-layer/image-20220402105631355.png" alt="DNS 查询过程"></p>
<p>假设主机 cis.poly.edu 想知道主机 gain.cs.umass.edu 的 IP 地址，在 DNS 查询过程中，主机与本地 DNS 服务器的查询方式是递归查询，本地 DNS 服务器与各级 DNS 服务器的查询方式是迭代查询。</p>
<p>在上图的查询过程中，权威域名服务器的主机名为 dns.umass.edu，表示该服务器记录了所有域名为 *.umass.edu 的服务器的 IP 地址</p>
<hr>
<p><strong>问题</strong></p>
<ol>
<li><p>权威域名服务器 dns.umass.edu 很可能无法记录所有域名为 *.umass.edu 的服务器的 IP 地址，那么实际中权威域名是否与更低级的 DNS 服务器进行了递归查询？</p>
</li>
<li><p>DNS 协议中提到的地址是否为 IP 地址？</p>
</li>
</ol>
<hr>
<h3 id="基于-DNS-缓存的-DNS-查询过程"><a href="#基于-DNS-缓存的-DNS-查询过程" class="headerlink" title="基于 DNS 缓存的 DNS 查询过程"></a>基于 DNS 缓存的 DNS 查询过程</h3><ul>
<li><p>搜索本机 DNS 缓存</p>
<ul>
<li><p>浏览器 DNS 缓存</p>
</li>
<li><p>操作系统中的 DNS 缓存和 hosts 文件</p>
</li>
</ul>
</li>
<li><p>若本机 DNS 缓存未命中，向本地 DNS 服务器发起查询，若本地 DNS 服务器没有查询的 DNS 信息，向各级 DNS 服务器发起迭代查询</p>
</li>
<li><p>本地 DNS 服务器得到 IP 地址，并缓存（域名, IP 地址），将得到的 IP 地址返回本机</p>
</li>
<li><p>操作系统和浏览器得到 IP 地址，并缓存（域名, IP 地址）</p>
</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP 允许传输任意类型的数据。传输的类型由 Content-Type 加以标记。</p>
<p>无状态。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系。</p>
<p>支持客户端/服务器模式</p>
<p><strong>HTTP 常用的请求方法</strong></p>
<p>PUT：上传文件，向服务器添加数据，可以看作增</p>
<p>DELETE：删除文件</p>
<p>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</p>
<p>GET：获取资源，查询服务器资源</p>
<h4 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h4><p>HTTP 请求由请求行、请求头部、空行和请求体四个部分组成</p>
<ul>
<li>请求行：包括请求方法，访问的资源 URL，使用的 HTTP 版本。</li>
<li>请求头：格式为“属性名:属性值”，服务端根据请求头获取客户端的信息，主要有 cookie、host、connection、accept-language、accept-encoding、user-agent。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 请求报文示例</span><br><span class="line">POST /xxx HTTP/1.1 请求行</span><br><span class="line"></span><br><span class="line">Accept:image/gif.image/jpeg, 请求头</span><br><span class="line">Accept-Language:zh-cn</span><br><span class="line">Connection:Keep-Alive</span><br><span class="line">Host:localhost</span><br><span class="line">User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)</span><br><span class="line">Accept-Encoding:gzip,deflate</span><br><span class="line"></span><br><span class="line">username=dabin 请求体</span><br></pre></td></tr></table></figure>
<p>HTTP 响应也由四个部分组成，分别是：状态行、响应头、空行和响应体</p>
<ul>
<li>状态行：协议版本，状态码及状态描述。</li>
<li>响应头：响应头字段主要有 connection、content-type、content-encoding、content-length、set-cookie、Last-Modified、Cache-Control、Expires。</li>
<li>响应体：服务器返回给客户端的内容。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 响应报文示例</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">Server:Apache Tomcat/5.0.12 响应头</span><br><span class="line">Date:Mon,6Oct2003 13:23:42 GMT</span><br><span class="line">Content-Length:112</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;响应体&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><div class="table-container">
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Redirection（重定向）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
</div>
<p>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p>
<p>200 OK</p>
<h4 id="HTTP1-0-和-HTTP1-1-的区别"><a href="#HTTP1-0-和-HTTP1-1-的区别" class="headerlink" title="HTTP1.0 和 HTTP1.1 的区别"></a>HTTP1.0 和 HTTP1.1 的区别</h4><ul>
<li>长连接：HTTP1.0 默认使用短连接，每次请求都需要建立新的TCP连接，连接不能复用。HTTP1.1 支持长连接，复用 TCP 连接，允许客户端通过同一连接发送多个请求。不过，这个优化策略也存在问题，当一个队头的请求不能收到响应的资源时，它将会阻塞后面的请求。这就是“队头阻塞”问题。</li>
<li>断点续传：HTTP1.0 不支持断点续传。HTTP1.1 新增了 range 字段，用来指定数据字节位置，支持断点续传。</li>
<li>错误状态响应码：在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突、410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>Host 信息：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名。到了 HTTP1.1 时代，虚拟主机技术发展迅速，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址，故 HTTP1.1 增加了 HOST 信息，用于区分同一 IP 的多个虚拟主机。</li>
</ul>
<h4 id="HTTP1-1-和-HTTP2-0-的区别"><a href="#HTTP1-1-和-HTTP2-0-的区别" class="headerlink" title="HTTP1.1 和 HTTP2.0 的区别"></a>HTTP1.1 和 HTTP2.0 的区别</h4><ul>
<li>新的二进制格式：HTTP1.1 基于文本格式传输数据；HTTP2.0 采用二进制格式传输数据，解析更高效。</li>
<li>多路复用：在一个连接里，允许同时发送多个请求或响应，并且这些请求或响应能够并行的传输而不被阻塞，避免 HTTP1.1 出现的”队头堵塞”问题。</li>
<li>头部压缩，HTTP1.1 的 header 带有大量信息，而且每次都要重复发送；HTTP2.0 把 header 从数据中分离，并封装成头帧和数据帧，使用特定算法压缩头帧，有效减少头信息大小。并且HTTP2.0 在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。比如请求 a 发送了所有的头信息字段，请求 b 则只需要发送差异数据，这样可以减少冗余数据，降低开销。</li>
<li>服务端推送：HTTP2.0 <strong>允许服务器向客户端推送资源</strong>，无需客户端发送请求到服务器获取。</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 是无状态的，然而一个站点通常希望能够识别用户。</p>
<p>当用户<strong>第一次访问</strong>并登陆一个网站的时候，会经历以下4个步骤：</p>
<ul>
<li><p>客户端发送一个 HTTP 请求到服务器</p>
</li>
<li><p>服务器用一个 HTTP Response 响应客户端，响应报文首部包含 Set-cookie 字段，表示服务器为客户端分配了一个 cookie ，服务器用 cookie 值来识别用户</p>
</li>
<li>客户端保存 cookie ，之后向服务器发送 HTTP 请求时，请求的首部会包含一个 cookie 字段，而服务器的响应不需要再包含 Set-cookie 字段</li>
</ul>
<blockquote>
<p>Set-cookie 和 cookie 字段有多个属性，主要包括：</p>
<p>NAME=VALUE    要保存的 Key/Value</p>
<p>Expires    过期时间</p>
<p>Domain    生成该 cookie 的域名，如 domain=”www.baiducom”</p>
</blockquote>
<p>Session 原理</p>
<p>Session 对象会存放用户的某些数据，例如在该网站存储的用户名-密码等</p>
<ul>
<li>客户端第一次发送请求到服务器端，服务器端创建一个 Session，同时会创建一个特殊的 Cookie（name为JSESSIONID 的固定值，value 为 session 对象的 ID，用于区分不同用户），然后将该 Cookie 发送至客户端</li>
<li>客户端在之后每次发送请求到服务器端，http 请求体都会携带该 name 为 JSESSIONID 的 Cookie</li>
<li>服务器端根据 name 为 JSESSIONID 的 Cookie 的 value(sessionId)，去查询 Session 对象。<ul>
<li>查询不到（Session 对象默认存活30分钟），重新创建 Session 并发生对应的 Cookie 给客户端</li>
<li>查询到，得到 Session 对象</li>
</ul>
</li>
</ul>
<p><img src="/2022/04/07/app-layer/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW4xMzMzMzMzNjY3Nw==,size_16,color_FFFFFF,t_70.png" alt></p>
<p><strong>Cookie 和 Session 的区别？</strong></p>
<ul>
<li>作用范围不同，Cookie 保存在客户端，Session 保存在服务器端。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效</li>
<li>隐私策略不同，Cookie 存储在客户端，容易被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些</li>
<li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K；对于 Session 来说存储没有上限，但出于对服务器的性能考虑，Session 内不要存放过多的数据，并且需要设置 Session 删除机制。</li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<p>通过使用 SSL，HTTPS 能够加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<blockquote>
<p>HTTPS 使用 443 号端口</p>
<p>由于需要先进行认证、密钥协商，导致消耗时空资源</p>
</blockquote>
<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p><strong>对称密钥加密</strong>（Symmetric-Key Encryption)，加密和解密使用同一密钥</p>
<ul>
<li>优点：运算速度快</li>
<li>缺点：密钥需要传输，而传输环境是不安全的</li>
</ul>
<p>非对称密钥加密，又称公钥加密（Public-Key Encryption），加密和解密使用不同的密钥 </p>
<ul>
<li>优点：保密性好（只需要传输公钥，公钥被任何人获取都可以，因为私钥只有一个人知道，只有他能解密）</li>
<li>缺点：运算速度慢</li>
</ul>
<h4 id="HTTPS-的加密方式"><a href="#HTTPS-的加密方式" class="headerlink" title="HTTPS 的加密方式"></a>HTTPS 的加密方式</h4><p>HTTPS 采用<strong>混合的加密方式</strong>，服务端先告知客户端自己的公钥。然后客户端用公钥加密自己的对称密钥，服务端用私钥解得对称密钥，然后用对称密钥加密传输</p>
<ul>
<li>使用非对称密钥加密方式，传输对称密钥，保证安全性</li>
<li>使用对称密钥加密方式进行通信，保证效率</li>
</ul>
<p><img src="/2022/04/07/app-layer/image-20220402105707967.png" alt="HTTPS 密钥传输过程"></p>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><blockquote>
<p>非对称密钥加密方式存在的安全性问题</p>
<p>客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。</p>
<p>由于 S 公钥明文在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器（AS）的公钥。</p>
<p>当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。<br>S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！</p>
</blockquote>
<p>简而言之，<strong>客户端不能判断公钥是攻击者发出的还是服务器发出的，即不能判断公钥是否安全。</strong></p>
<p><strong>通过在传输密钥之前进行认证，确保获取的是信任机构的公钥。</strong></p>
<p>认证过程</p>
<p>服务端发送证书（包括证书内容和证书签名算法）和签名</p>
<ul>
<li>使用证书签名算法（hash 算法）对证书内容进行 hash 运算。（证书内容是一串数字）</li>
<li>对 hash 后的值用私钥加密（私钥来自于 CA 机构），得到签名。</li>
<li>将证书内容和签名一同发送</li>
</ul>
<p>客户端获得证书和签名</p>
<ul>
<li>用 CA 机构的公钥对签名解密（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。</li>
<li>用证书里的签名算法对证书内容进行 hash 运算。</li>
<li>比较解密后的签名和对证书内容做 hash 运算后得到的 hash 值，相等则表明证书可信。</li>
</ul>
<p><img src="/2022/04/07/app-layer/image-20220402105718405.png" alt="HTTPS 认证过程"></p>
<hr>
<p>证书内容实际上就是浏览器的公钥</p>
<p>思考：为什么这样认证能保证公钥是可信的？</p>
<p>浏览器保存了 CA 机构的公钥，只要证书中的 hash 算法不是 CA 机构的，或者不是用 CA 机构的私钥加密证书，一定不会取等。当且仅当 hash 算法和私钥都由 CA 机构提供，才会取等。</p>
<hr>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、默认网关 IP 地址和本地 DNS 服务器地址。</p>
<p><img src="/2022/04/07/app-layer/image-20220402110655433.png" alt></p>
<p>DHCP 工作过程如下：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。广播：指目的 IP 地址为：255.255.255.255</li>
<li>DHCP 服务器收到 Discover 报文之后，广播 Offer 报文给客户端（广播，因为 Discover 报文并不包含客户端的有效源地址信息），该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，广播 Request 报文给该 DHCP 服务器。（Request 报文中的 DHCP server ID 字段用来让接收到 Request 报文的 DHCP 服务器判断是否需要自己提供服务）</li>
<li>DHCP 服务器广播 ACK 报文给客户端，表示客户端此时可以使用提供给它的信息</li>
</ol>
<p><img src="/2022/04/07/app-layer/image-20220402105738824.png" alt="DHCP IP 配置过程"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>basic calculation</title>
    <url>/2022/04/24/basic-calculation/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>统计频数</title>
    <url>/2022/04/18/calculate-freq/</url>
    <content><![CDATA[<p>统计数组中数字出现频数的方法</p>
<span id="more"></span>
<h1 id="原地哈希"><a href="#原地哈希" class="headerlink" title="原地哈希"></a>原地哈希</h1><p>原地哈希算法通常用来统计大小在 [1, n] 范围内元素的频数。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>设数组 nums 的长度为 n，即下标范围 0~n-1。如果数组中<strong>任意元素都满足</strong>：1&lt;=x&lt;=n，则我们可以通过原地哈希的方法对 x 的频数进行统计：</p>
<ul>
<li>哈希函数：hash(x) = (x-1)%n，该哈希函数表示，对于数字 x，它将被映射到数组中 (x-1)%n 的位置<ul>
<li>模 n 的原因：x 可能已经被 +n 过，需要通过模 n 的方法恢复它本来的值</li>
</ul>
</li>
<li>频数统计：<ul>
<li>nums[hash(x)] += n，每次遇到一次 x，都会把 nums[hash(x)] 的值加上 n，作为频数信息</li>
<li>x 的频数等于 nums[hash(x)] / n</li>
</ul>
</li>
</ul>
<p>例题：给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (num-<span class="number">1</span>) % n;</span><br><span class="line">        nums[x] += n;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">2</span>*n) &#123;</span><br><span class="line">            ret.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相关题目</p>
<p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a>，找频数为 0 的数</p>
<p><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a>，<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a>，找频数为 2 的数</p>
</blockquote>
<h2 id="部分元素不满足大小在-1-n"><a href="#部分元素不满足大小在-1-n" class="headerlink" title="部分元素不满足大小在 [1, n]"></a>部分元素不满足大小在 [1, n]</h2><p>假设仍旧按照上面的统计 [1,n] 元素，会存在的问题是频数统计这块：若 nums[hash(x)]  不满足大小在 [1, n] 区间，则将其 +n 后，如果在后面遍历到了 nums[hash(x)]，nums[hash(x)]%n 并非原来的数。</p>
<p>例题：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<a href="https://leetcode-cn.com/problems/first-missing-positive/">41. 缺失的第一个正数</a></p>
<p>原地哈希，只适用频数为 0 和不为 0 的情况。</p>
<p>对于 1&lt;=nums[i]&lt;=n，它将被映射到 nums[i]-1 的索引位置，并修改该位置的元素为：nums[num - 1] = -Math.abs(nums[num - 1]); 也就是保证该索引位置的元素一定是负数，多次遇到值和 nums[i] 相同的元素，始终保持 nums[num - 1] 为负数，表示 nums[i] 频数不为0</p>
<blockquote>
<p>注意到在将负数处理为 n+1 后，不能延用原来的原地哈希方法，因为对于 n+1， +n 后再 % n 无法恢复原来的值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 法1 ：我们可以将数组所有的数放入哈希表，随后从 1 开始依次枚举正整数，并判断其是否在哈希表中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将法1的空间复杂度优化为 O(1)，需要使用原地哈希</span></span><br><span class="line">    <span class="comment">// 实际上，对于一个长度为 N 的数组，其中没有出现的最小正整数只能在 [1,N+1] 中。这是因为如果 [1,N] 都出现了，那么答案是 N+1，否则答案是 [1,N] 中没有出现的最小正整数。这样一来，我们将所有在 [1,N] 范围内的数放入哈希表，也可以得到最终的答案</span></span><br><span class="line">    <span class="comment">// 问题转化为统计 [1,N] 的元素频数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 令nums[x-1]为负数，这种方法仅局限于频数上限为1，因为再取相反数频数信息就丢失了（任意偶数），其中的减1操作同样是为了把下标变成0开始。恢复下标为 y 的元素值：nums[y]=|nums[y]|，即取绝对值</span></span><br><span class="line">    <span class="comment">// 负数的处理：由于用取负数来记录正整数的频数，因此对原来就存在的负数要处理。由于止只统计 [1,N] 的频数，因此可以把负数转化为正整数 N+1，即在这个区间外的正整数，它的频数不会被统计</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i] = n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Math.abs(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">            <span class="comment">// 注意每次取某个下标的数都要用 绝对值 来取得</span></span><br><span class="line">            nums[num - <span class="number">1</span>] = -Math.abs(nums[num - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h1><p>设一个数组 nums，它的长度表示为 n。</p>
<p>摩尔投票法的核心思想为对拼消耗。每次从序列里选择两个不相同的数字删除掉（或称为「抵消」），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个元素。具体的证明过程需要参考论文，论文地址：<a href="https://leetcode-cn.com/link/?target=https%3A%2F%2Fwww.cs.ou.edu%2F~rlpage%2Fdmtools%2Fmjrty.pdf">MJRTYA Fast Majority Vote Algorithm</a></p>
<h2 id="求出现频数-gt-n-2-的数字"><a href="#求出现频数-gt-n-2-的数字" class="headerlink" title="求出现频数 &gt; n/2 的数字"></a>求出现频数 &gt; n/2 的数字</h2><p>Boyer-Moore 算法的详细步骤：</p>
<ul>
<li>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</li>
<li><p>遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：</p>
<ul>
<li>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</li>
<li>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</li>
</ul>
</li>
<li><p>在遍历完成后，candidate 即为整个数组的众数。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">candidate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            candidate = num;</span><br><span class="line">        &#125;</span><br><span class="line">        count += (num == candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>能否处理频数等于 nums.length/2 的情况？</p>
</blockquote>
<h3 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h3><p><strong>以下解法中，哈希表、随机化和分治对众数的频数并没有限制（即限制频数 &gt;n/2）</strong></p>
<ul>
<li><p>哈希表统计</p>
</li>
<li><p>排序。如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 $\lfloor \dfrac{n}{2} \rfloor$ 的元素（下标从 0 开始）一定是众数。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 n 为奇数的情况，第二个例子是 n 为偶数的情况。</p>
<p>  <img src="/2022/04/18/calculate-freq/a70cb9316157ecd7eeffe7900d3ca83849079824964e8a0aaefbcffd4040f175-image.png" alt="image.png" style="zoom:50%;"></p>
<p>  对于每种情况，数组下面的线表示如果众数是数组中的最小值时覆盖的下标，数组上面的线表示如果众数是数组中的最大值时覆盖的下标。<strong>对于其他的情况，这条线会在这两种极端情况的中间</strong>。（先将边界找出）</p>
<p>  对于这两种极端情况，它们会在下标为 $\lfloor \dfrac{n}{2} \rfloor$ 的地方有重叠。因此，无论众数是多少，返回 $\lfloor \dfrac{n}{2} \rfloor$ 下标对应的值都是正确的。</p>
</li>
<li><p>随机化。随机挑选一个元素检查它是否是众数，如果是就返回，否则继续随机挑选。</p>
<p>  是放回抽样，在第 k 次抽到众数的概率是 ${(\frac{1}{2})}^k$，因此随机变量 k，即抽取次数的期望值 E(k)=2，因此期望时间复杂度是 O(N)，即抽取 E(K) 次，每次需要遍历数组判断抽到的元素是否为众数。</p>
</li>
<li><p>分治。如果数 <code>a</code> 是数组 <code>nums</code> 的众数，如果我们将 <code>nums</code> 分成两部分，那么 <code>a</code> 必定是至少一部分的众数。</p>
<p>  这样一来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。</p>
<p>  merge() 方法为：如果 a1 != a2，则判断 a2 和 a1 哪一个是区间的众数（区间 [l, r]，左半部分[l, mid]，右半部分 [mid+1, r]）</p>
</li>
</ul>
<blockquote>
<p>参考 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></p>
</blockquote>
<h2 id="求出现频数-gt-n-k-的数字"><a href="#求出现频数-gt-n-k-的数字" class="headerlink" title="求出现频数 &gt; n/k 的数字"></a>求出现频数 &gt; n/k 的数字</h2><p>可以用反证法证明，出现次数超过 n/k 的数<strong>最多</strong>只有 k−1 个（可能小于 k-1 个）。否则必然违背「数总共只有 n 个」或者「当前统计的是出现次数超过 n/k 的数」的前提条件。</p>
<p>我们可以使用有限变量来代表这 k - 1 个候选数及其出现次数。</p>
<p>假设当前遍历到的元素为 x：</p>
<ul>
<li>如果 x 本身是候选者的话，则对其出现次数加 1；</li>
<li>如果 x 本身不是候选者，检查是否有候选者的出现次数为 0：<ul>
<li>若有，则让 x 代替其成为候选者，并记录出现次数为 1；</li>
<li>若无，则让<strong>所有</strong>候选者的出现次数减 1。</li>
</ul>
</li>
</ul>
<p>上述做法可以保证：若存在出现次数超过 n/k 的数，最后必然会成为这 k−1 个候选者之一。证明略。</p>
<p>当处理完整个数组后，这 k−1 个数可能会被填满，但不一定都是符合出现次数超过 n/k 要求的。（出现次数超过 n/k 的数<strong>最多</strong>只有 k−1 个）</p>
<p>需要遍历数组并检查 k-1 个数每个数的出现频次，如果频次超过 n/k 才加入到结果。</p>
<h2 id="摩尔投票法的性能分析"><a href="#摩尔投票法的性能分析" class="headerlink" title="摩尔投票法的性能分析"></a>摩尔投票法的性能分析</h2><p>用摩尔投票法求出现频次 &gt; n/2 的数字时，该数字是唯一的，因此用 O(N) 的时间和 O(1) 的空间就可以得到结果；然而，用摩尔投票法求出现频次 &gt; n/k 的数字时，需要遍历数组再次统计 k-1 个候选人的频数，这会导致时间复杂度为 O(2*N)，在这种情况下，反而不如直接使用哈希表，虽然哈希表会带来 O(N) 的空间开销。</p>
<h1 id="统计字符串的频数"><a href="#统计字符串的频数" class="headerlink" title="统计字符串的频数"></a>统计字符串的频数</h1><p>一个字符串 s，只包含四种字符 A C G T，编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p>
<p>法1：哈希表的键为字符串，每个键大小 10 个字符，20 个字节；</p>
<p>法2：哈希表的键为字符串的等效。<strong>由于 s 中只含有 4 种字符，我们可以将每个字符用 2 个比特表示</strong>：00 01 10 11，如此一来，一个长为 10 的字符串就可以用 20 个比特表示，而一个 int 整数有 32 个比特，足够容纳该字符串，因此我们可以将 s 的每个长为 10 的子串用一个 int 整数表示（只用低 20 位）。键大小一个字节。</p>
<p>两种方法都需要用滑动窗口来获取子串。</p>
<ul>
<li>法1，需要维护一个可变字符串，可用 StringBuffer </li>
<li>法2，用位运算。先左移两位，然后将高位置零，然后加上低位两个比特。由于只用到了低 20 位，需要将高位置零，可以通过和高位全 0，低 20 位全 1 的二进制数与运算来实现，该二进制数=(1 &lt;&lt; 20) - 1</li>
</ul>
<p>对于一个字符串数组，如果对于其中的每个字符串，需要知道它的包含字符情况。（即是否包含，不要求具体数量）</p>
<ul>
<li><p>若将字符串当作字符数组，判重复杂度O(L1*L2)</p>
</li>
<li><p>若将字符串记录为 count数组（只需要存储0、1），遍历count复杂度O(26)</p>
</li>
<li>假设只包含小写字母，因为 count 只需要存储 0、1（<strong>否则要用更大的进制</strong>。不推荐，不如直接用哈希表），进一步将count映射为二进制数，一个 int 足以存储，位运算复杂度 O(1)</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2022/04/02/deadlock/</url>
    <content><![CDATA[<p>产生死锁的必要不充分条件、解决死锁的方法</p>
<span id="more"></span>
<h1 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h1><p>对资源（不止是锁，还有内存、IO等）的请求都可能导致死锁。四个必要条件同时满足才 <strong>可能</strong> 产生死锁（<strong>必要不充分</strong>）。</p>
<ul>
<li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li>
<li><p><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。（才有可能成环）</p>
</li>
<li><p><strong>不可抢占</strong>：资源只能等待进程使用完自愿释放，不能被抢占。</p>
</li>
<li><strong>环路等待</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。如图所示，图中，圆形表示线程，方形表示资源。</li>
</ul>
<p><img src="/2022/04/02/deadlock/image-20220402135304631.png" alt="产生死锁的资源分配图"></p>
<h1 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h1><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除</strong>四种。</p>
<ul>
<li><strong>预防</strong>是采用某种策略，<strong>限制并发进程对资源的请求</strong>，破坏死锁必要条件，确保系统不可能进入死锁状态</li>
<li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生</li>
<li><strong>检测</strong>是指使用死锁检测器，<strong>当死锁发生时</strong>，死锁检测器能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li>
<li><strong>解除</strong>是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li>
</ul>
<h2 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h2><p>只要破坏四个必要条件中的任何一个就能够预防死锁的发生。</p>
<ul>
<li><p>破坏<strong>互斥</strong>条件：大多数情况下，资源往往不能同时访问，因此很难避免互斥。</p>
</li>
<li><p>破坏<strong>占有并等待</strong>条件：静态分配策略——进程在开始运行时，一次性申请所有需要的资源。这种策略 <strong>严重地降低了资源利用率</strong>。因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成了一个进程占有了一些几乎不用的资源而使其他需要该资源的进程产生等待的情况。</p>
</li>
<li>破坏<strong>非抢占</strong>条件：剥夺式调度算法——进程请求不能立即分配的资源，则释放自身已占有资源。例如使用如下 trylock 语句。会导致资源利用率下降。</li>
</ul>
<p><img src="/2022/04/02/deadlock/image-20220402135725012.png" alt></p>
<ul>
<li>破坏<strong>环路等待</strong>条件：层次分配策略。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源。证明略。最简单的例子，给资源统一编号，进程只能按编号顺序来请求资源。假如系统共有两个锁（L1 和 L2），那么我们每次都先申请 L1 然后申请 L2</li>
</ul>
<p>一般比较<strong>实用</strong>的 预防死锁的方法，是通过考虑破坏第二个条件和第四个条件。</p>
<h2 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h2><p>预防死锁的方法会导致 <strong>低效的进程运行 和 资源使用率</strong> 。而死锁的<strong>避免</strong>相反，它的角度是<strong>允许</strong>系统中<strong>同时存在四个必要条件</strong> ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智和合理的选择</strong> ，仍然可以避免死锁，因为四大条件是产生死锁的必要不充分条件。</p>
<p>我们将系统的状态分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，每当在为申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p>
<p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（T1、T2、T3…..Tn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。</p>
<p>那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的避免死锁算法就是 Dijkstra 的<strong>银行家算法</strong>，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，银行家算法 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，就真的分配资源给该进程。</p>
<p>例子</p>
<p><img src="/2022/04/02/deadlock/image-20220402135655731.png" alt="资源需求-分配图"></p>
<p>四个进程，三种需要分配的资源。</p>
<ul>
<li>资源请求矩阵 = C - A</li>
<li><strong>可用资源向量</strong>由系统资源向量 R 和已分配资源矩阵 A 计算得到：[2 1 2] = [9-7 3-2 6-4]</li>
</ul>
<p>如果此时线程 T1 和 T2 均发出<strong>资源请求向量</strong> Request(1, 0, 1)，为了保证系统的安全性，如何分配资源给这两个线程？说明所采用策略的原因。</p>
<p>假设分配给 T1 ：</p>
<ul>
<li>(1, 0, 1) 小于 T1 的需求 (2, 2, 2)，也小于可用资源向量 V，允许分配</li>
<li>分配之后，V = (1, 0, 1)，资源请求矩阵第一行变为 (1, 2, 1)，可用资源 <strong>无法</strong> <strong>一次性</strong> 满足某个线程的需求（即 V 小于资源请求矩阵任意一行），所以分配给 T1 是不安全的。<strong>无法</strong> <strong>一次性</strong> ：（需要等待其他线程释放资源，且互相等待，造成死锁）</li>
</ul>
<p>假设分配给 T2 ：</p>
<ul>
<li>(1, 0, 1) 小于 T2 的需求，也小于可用资源向量 V，允许分配</li>
<li>分配之后，V = (1, 0, 1)，资源请求矩阵第二行变为 (1, 0, 1)，可用资源可以 一次性满足某个线程的需求，所以分配给 T2 是安全的。分配给 T2 后修改各个矩阵。</li>
</ul>
<p>死锁的避免改善<strong>解决了资源使用率低的问题</strong>，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 安全性检查 ，需要<strong>花费</strong>较多的<strong>时间</strong>。</p>
<h2 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h2><p>对资源的分配加以限制可以预防和避免死锁的发生，但是都不利于各进程对系统资源的<strong>充分共享</strong>。解决死锁问题的另一条途径是<strong>死锁检测和解除</strong></p>
<p>类比乐观锁和悲观锁，死锁的检测和解除就像是乐观锁 ，分配资源时不去考虑会不会发生死锁，等到真的死锁出现了再来解决，而死锁的预防和避免更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎。</p>
<p>死锁检测和恢复技术。<strong>死锁检测器会定期运行，通过构建资源图来判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它</strong>。</p>
<h3 id="进程-资源分配图"><a href="#进程-资源分配图" class="headerlink" title="进程-资源分配图"></a>进程-资源分配图</h3><p>操作系统中的每一刻时刻的系统状态都可以用<strong>进程-资源分配图</strong>来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种<strong>有向图</strong>，可用于<strong>检测系统是否处于死锁状态</strong>。</p>
<p>用一个方框表示一个资源类，方框中的黑点表示该资源类中的各个资源，每个进程用一个圆圈表示，用 <strong>有向边</strong> 来表示<strong>进程申请资源和资源被分配的情况</strong>。（资源指向进程，表示进程占有这个资源）</p>
<p>图中 2-21 是<strong>进程-资源分配图</strong>的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，发生了死锁，出现在 P2、R2、P3、R3 环路。</p>
<p><img src="/2022/04/02/deadlock/image-20220402135648340.png" alt></p>
<p>进程-资源分配图中存在环路并不一定是发生了死锁。</p>
<p>图 2-22 便是一个有环路而无死锁的例子。（资源类有多个资源）虽然进程 P1 和进程 P3 分别占用了一个资源 R1 和一个资源 R2，并且因为等待另一个资源 R2 和另一个资源 R1 形成了环路，但进程 P2 和进程 P4 分别占有了一个资源 R1 和一个资源 R2，它们申请的资源得到了满足，在有限的时间里会归还资源，于是进程 P1 或 P3 都能获得另一个所需的资源，环路自动解除，系统也就不存在死锁状态了。</p>
<h3 id="死锁检测步骤"><a href="#死锁检测步骤" class="headerlink" title="死锁检测步骤"></a>死锁检测步骤</h3><p>知道了死锁检测的原理，我们可以利用下列步骤编写一个 <strong>死锁检测</strong> 程序，检测系统是否产生了死锁。</p>
<ol>
<li>如果进程-资源分配图中无环路，则此时系统没有发生死锁</li>
<li>如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。</li>
<li>如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。</li>
</ol>
<h2 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h2><p>当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：</p>
<ol>
<li><strong>结束所有进程</strong>：这种方法简单，但以前的工作全部作废，损失很大。</li>
<li><strong>一次性撤销涉及死锁的所有进程，继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li>
<li><strong>逐个撤销</strong>涉及死锁的进程，<strong>回收其资源直至死锁解除。</strong></li>
<li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2022/04/07/dp/</url>
    <content><![CDATA[<p>各种问题的递推思路和递推表达式</p>
<span id="more"></span>
<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>后续的扩展需阅读<a href="https://zhuanlan.zhihu.com/p/139368825">背包九讲</a></p>
<h2 id="1-01-背包问题"><a href="#1-01-背包问题" class="headerlink" title="1 01 背包问题"></a>1 01 背包问题</h2><p>有 n 个可待选择的物品，每个物品只有一件，它们都有各自的重量和价值。</p>
<p>设 weights = [1,2,3]，values = [4,5,6]</p>
<p><strong>基本问题1：用这 n 个物品，能组成的所有重量</strong></p>
<p>设 f(w, i) 表示用前 i 个物品能得到重量 w，递推图如下：</p>
<p><img src="/2022/04/07/dp/image-20220410162156883.png" alt></p>
<p>f(w, i) 值为 T/F，表示是否能组成重量 w。</p>
<p><strong>限制重量：即限制 w 维度的范围</strong></p>
<p><strong>基本问题2：用这 n 个物品，能组成的所有重量和对应的价值集合</strong></p>
<p>令 f(w, i) 为重量对应的价值集合，之所以是集合，是因为 f(w, i) 可以由多个 f(?, i-1) 递推得到。由于状态值是集合，即 f(w, i) 对应一组数，从空间上，可以把这组数画到第三维。</p>
<p>因此，可以定义 f(w, v, i) 表示用前 i 个物品能得到重量 w，且价值为 v。</p>
<p><strong>基本问题3：用这 n 个物品，能组成的所有重量和对应的最大价值</strong></p>
<p>根据基本问题2，可以求出所有的 f(w, v, i)，记录各个 (w, i) 取值的最大 v 即可。</p>
<p>更好的做法是，定义 f(w, i) 表示用前 i 个物品得到重量 w 时的最大价值，f(w, i) 满足最优子结构性质。在这种情况下，递推表示式为：</p>
<script type="math/tex; mode=display">
f[w][i] = max(f[w][i-1], f[w-weights[i]][i-1] + values[i])</script><p>即不选或者选第 i 个物品。</p>
<p>根据递推式对应的递推图，容易知道，只需要两列空间。为了优化为一列空间，可以让递推过程为：每次从 f(W, i) 往 f(0, i) 更新，这样，每次递推的时候，对于 max 中的第二项，可以保证它是 i-1 的结果，没有被 i 的结果填充。空间复杂度优化，时间复杂度没有优化。</p>
<h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></p>
<p><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量 II</a></p>
<p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">一和零</a></p>
<p>等效为 01 背包问题：strs 即可选择的物品数组，每个物品的属性有：字符串中 0 的个数、字符串中 1 的个数</p>
<p>根据基本问题3 进行推广，这里应该定义 f(i, j, k) 表示用前 i 个物品得到 j 个 0 和 k 个 1 时的最大子集长度。</p>
<p>递推式为：</p>
<script type="math/tex; mode=display">
dp[i][j][k]=\left\{\begin{matrix}
dp[i-1][j][k] & j<zeros \ or \ k<ones\\
max(dp[i-1][j][k],dp[i-1][j-zeros][k-ones]+1) & j\geq zeros \ and\ k\geqslant ones
\end{matrix}\right.</script><p>同样可以将复杂度优化，三维到二维。类似地，不需要 i 维度，根据二维的递推图可知，需要从右下往左上递推。</p>
<p><a href="https://leetcode-cn.com/problems/profitable-schemes/">盈利计划</a></p>
<p>集团里有 n 名员工，他们可以完成各种各样的工作创造利润。</p>
<p>第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。（每种工作只能完成一次，不能重复完成）</p>
<p>工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。</p>
<p>有多少种计划可以选择？</p>
<h2 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2 完全背包问题"></a>2 完全背包问题</h2><p>有 n 个可待选择的物品，每个物品有无限件可用，它们都有各自的重量和价值。求用这 n 个物品，能组成的所有重量和对应的最大价值。</p>
<p>定义 f(i, j) 表示用前 i 个物品得到重量 j 时的最大价值，对于完全背包问题，递推式为：</p>
<script type="math/tex; mode=display">
f[i][j]=max\left \{ f[i-1][j-k*weights[i]]+k*values[i],\ \ \ k*weights[i]\leq j \right \}</script><p>该递推式的复杂度是线性倍的 O(NW)</p>
<p>上述递推式可以优化为：</p>
<script type="math/tex; mode=display">
f[i][j]=max\left \{ f[i-1][j],\ f[i][j-weights[i]]+values[i] \right \}</script><p>这是因为如果使用原来的递推式，在计算 f(i, j) 和 f(i, j-weights[i]) 的时候有重复计算。证明如下：</p>
<script type="math/tex; mode=display">
\begin{align*}

  f[i][j] &= max\left \{ f[i-1][j-k*weights[i]]+k*values[i],\ \ \ k*weights[i]\leq j \right \} \\ 

  &= max\left \{ f[i-1][j],\ f[i-1][j-weights[i]]\ ...\ f[i-1][j-\lfloor \frac{j}{weights[i]} \rfloor*weights[i]] \right \} \\

\end{align*}</script><p>所以：</p>
<script type="math/tex; mode=display">
f[i][j-weights[i]]=max\left \{ f[i-1][j-weights[i]]\ ...\ f[i-1][j-\lfloor \frac{j}{weights[i]} \rfloor*weights[i]] \right \}</script><p>所以：</p>
<script type="math/tex; mode=display">
f[i][j]=max\left \{ f[i-1][j],\ f[i][j-weights[i]]+values[i] \right \}</script><p>进一步地，对于这个递推式，通过控制递推方向为右下到左上，同样可以优化为一维的空间复杂度。</p>
<h3 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h3><p><a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换II</a></p>
<p>给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算 n 分有几种表示法</p>
<p>设 f(i, j) 表示前 i 种硬币构成面值为 j 的方案数量。则递推式为：</p>
<script type="math/tex; mode=display">
f[i][j]=\sum_{0}^{k_{max}}f[i-1][j-k*coins[i]],\ \ \ \ k_{max}=\lfloor \frac{j}{coins[i]} \rfloor</script><p>类似地，去掉重复计算的部分，递推式可以优化为：</p>
<script type="math/tex; mode=display">
f[i][j]=f[i-1][j]+f[i][j-coins[i]]</script><h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><h2 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h2><p>设 f(i) 表示以 nums[i] 结尾的最长上升子序列（可以是长度，子序列等）</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h2 id="相关题目-2"><a href="#相关题目-2" class="headerlink" title="相关题目"></a>相关题目</h2><p>通常是设置更多的条件来判断序列是否为上升序列，需要重写排序方法</p>
<p>二维排序</p>
<ul>
<li><p>面试题 17.08. 马戏团人塔</p>
</li>
<li><p>最长数对链</p>
</li>
<li>俄罗斯套娃信封问题</li>
</ul>
<p>三维排序：面试题 08.13. 堆箱子</p>
<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>设 f(i, j) 表示 text1 第 i 个元素开始，text2 第 j 个元素开始的结果</p>
<p>则递推式为：</p>
<script type="math/tex; mode=display">
f[i][j]=\left\{\begin{matrix}
1+f[i+1][j+1] & if\ s[i]==s[j]\\ 
max\left \{ f[i+1][j],\ f[i][j+1] \right \}  & else
\end{matrix}\right.</script><p>则递推图为：</p>
<p><img src="/2022/04/07/dp/image-20220410214301011.png" alt></p>
<p>那么在边界处，即 i=M-1 和 j=N-1 时，递推式会有越界问题。</p>
<p>为了便于处理，可以多分配一行一列，它们的初值是 0，然后边界位置就可以正常用递推式了。</p>
<h1 id="1027-最长等差数列"><a href="#1027-最长等差数列" class="headerlink" title="1027. 最长等差数列"></a>1027. 最长等差数列</h1><p>需要注意的是，子序列中元素的相对位置必须和原来保持一致。</p>
<p>递推，dp[i] 需要记录以 nums[i] 为结尾的 (公差 d, 对应的最长等差序列长度)，因此，dp 数组每个元素应该用哈希表存储</p>
<h1 id="子数组问题"><a href="#子数组问题" class="headerlink" title="子数组问题"></a>子数组问题</h1><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>用 f(i) 表示以第 i 个数结尾的「连续子数组的最大和」便于递推。不递推所有连续子数组和（即使用 f(i, j) 表示 i~j的连续子数组和）</p>
<h1 id="环形数组问题"><a href="#环形数组问题" class="headerlink" title="环形数组问题"></a>环形数组问题</h1><p>环形数组的连续子数组的最大和</p>
<p>先不考虑环：求以i为结尾的连续子数组最大和，得到其中的最大值</p>
<p>考虑环：求 以i为结尾的连续子数组最小和min，考虑环的情况下，环形数组的连续子数组的最大和 = 总和-min</p>
<p>圆环回原点问题（字节跳动高频面试题之圆环回原点问题）</p>
<script type="math/tex; mode=display">
dp[i][j] = dp[i-1][(j-1+length)\%length] + dp[i-1][(j+1)\%length]</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backToOrigin</span>(<span class="params">self,n</span>):</span><br><span class="line">        <span class="comment">#点的个数为10</span></span><br><span class="line">        length = <span class="number">10</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> 第一行只有dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>，其他都为<span class="number">0</span></span><br><span class="line">第一行初始化之后，后面的行根据递推式易知可以递推出来</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                <span class="comment">#dp[i][j]表示从0出发，走i步到j的方案数</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][(j-<span class="number">1</span>+length)%length] + dp[i-<span class="number">1</span>][(j+<span class="number">1</span>)%length]</span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>graph alg</title>
    <url>/2022/04/24/graph-alg/</url>
    <content><![CDATA[<p>图的存储方式、搜索遍历方式，图的各种算法</p>
<span id="more"></span>
<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><p>图的存储方法主要有两种：邻接链表和邻接矩阵。两种方式都可以表示无向图和有向图。</p>
<ul>
<li>邻接链表适合存储稀疏图（边的条数 |E| 远小于节点个数的平方 |V^2^|）</li>
<li>邻接矩阵适合存储稠密图，以及需要快速判断两个节点是否存在边的场景。需要注意到，对于无向图，邻接矩阵是一个对称矩阵，因此，我们实际上只需要 |V^2^|/2 的空间来存储邻接矩阵</li>
</ul>
<p>在图的规模较小的情况下（节点数较少），邻接矩阵通常是不错的选择。</p>
<p><img src="/2022/04/24/graph-alg/image-20220425093330113.png" alt="image-20220425093330113"></p>
<p>对邻接链表/邻接矩阵稍加修改，即可存储权重图。</p>
<ul>
<li>邻接链表，令存储元素为边的权值</li>
<li>邻接矩阵，对于存在的边，令存储元素为边的权值，对于不存在的边，根据场景，选择 0 或无穷值</li>
</ul>
<p>需要注意到，邻接链表和邻接矩阵存储的是边的信息，可以拓展到边的权重等各种信息，而非存储节点的信息。</p>
<h1 id="图的搜索遍历方式"><a href="#图的搜索遍历方式" class="headerlink" title="图的搜索遍历方式"></a>图的搜索遍历方式</h1><p>为了便于对图进行遍历，首先定义节点属性：每个节点具有的属性，例如<strong>节点编号、节点状态和节点对应的某个特定输出</strong>（当图的节点作为函数的状态节点时）</p>
<p>对于图中的任意一个节点，它在搜索的过程中有<strong>三种状态</strong>，即：</p>
<p><strong>「未搜索」</strong>：我们还没有搜索到这个节点；</p>
<p><strong>「搜索中」</strong>：我们搜索过这个节点，但还没有从该节点<strong>回溯</strong>；防止往回走重复路径</p>
<p><strong>「已完成」</strong>：我们搜索过并且从这个节点回溯过。这说明我们已经搜索了从该节点出发能到达的所有节点。对于「已完成」的节点，后续不会再访问它。</p>
<p>通常，我们用一个与节点数量相同的数据结构，命名为 visited，存储节点的搜索状态。</p>
<ul>
<li>不需要回溯时，节点是否被访问只取决于两种搜索状态：未搜索（false）和已搜索（true），已搜索对应「搜索中」和「已完成」这两种状态</li>
<li><strong>需要回溯时，才区分为三种状态</strong></li>
</ul>
<p><strong>以下探讨从图 G 的一个结点 s 出发进行搜索的方式，注意不一定能将整张图搜索完。</strong>要将整张图搜索完，需要以每个节点为源结点调用一次 bfs 或者 dfs</p>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>从图 G 的源结点 s 出发进行广度优先搜索。注意，</p>
<ul>
<li>一次 bfs 不一定能将整张图搜索完</li>
<li><strong>bfs 没有回溯的概念</strong></li>
</ul>
<p>在以下 bfs 的实现中：</p>
<ul>
<li>为了形象化 bfs 层序遍历的本质，令每个节点拥有属性 d，表示层数，也可以表示从源结点 s 到当前节点的最短路径（<strong>路径无权值情况下</strong>）</li>
<li><p>为了形象化图的连接关系，令每个节点拥有属性 p，表示其父结点</p>
</li>
<li><p>之所以在访问到的时候才初始化节点，是为了适配节点作为函数状态的场景，这种场景下，无法在一开始就初始化全部节点。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(G, s)</span>&#123;</span><br><span class="line">    Queue&lt;node&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 队列元素为节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// visited 初始化</span></span><br><span class="line">    <span class="keyword">for</span> v in G.v</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化起始节点的属性 s.init(); </span></span><br><span class="line">    s.d = <span class="number">0</span>;</span><br><span class="line">    s.p = NULL;</span><br><span class="line">    q.offer(s);</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="type">node</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> v in G.Adj[n]&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="comment">// v.init();</span></span><br><span class="line">                v.d = u.d + <span class="number">1</span>;</span><br><span class="line">                v.p = u;</span><br><span class="line">                visited[v] = <span class="literal">true</span>;</span><br><span class="line">                q.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历过程中访问-NULL-节点"><a href="#遍历过程中访问-NULL-节点" class="headerlink" title="遍历过程中访问 NULL 节点"></a>遍历过程中访问 NULL 节点</h3><p>在以上实现方式中，每次访问的是非空节点。在某些场景下，需要访问并且记录空节点。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a></li>
<li><a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/">二叉树的完全性检验</a></li>
</ul>
<p>通常来说，当图为树形结构的时候才需要这么处理，这是因为访问 NULL 节点可以维护树的一些基本性质（<strong>例如二叉性质，空的子节点也应该访问</strong>），便于对树进行分析。</p>
<p>假设图是一颗二叉树，bfs 并且访问空节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">q.offer(root);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">    <span class="type">node</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 版本1，只遍历非空节点</span></span><br><span class="line">    <span class="keyword">if</span>(n.left != <span class="literal">null</span>) q.offer(n.left);</span><br><span class="line">    <span class="keyword">if</span>(n.right != <span class="literal">null</span>) q.offer(n.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 版本2，空节点也遍历</span></span><br><span class="line">    <span class="keyword">if</span>(n != <span class="literal">null</span>)&#123;</span><br><span class="line">        q.offer(n.left);</span><br><span class="line">        q.offer(n.right);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本 1 搜索到的节点：     </p>
<p><img src="/2022/04/24/graph-alg/image-20220425101943684.png" alt="image-20220425101943684"></p>
<p> 版本 2 搜索到的节点：</p>
<p><img src="/2022/04/24/graph-alg/image-20220425101954477.png" alt="image-20220425101954477"></p>
<p>关于版本2，假设将层序遍历结果写成线性形式 arr=[1,2,null,3,4,null,null,null,null]，则可以根据元素的位置得到 它的左节点位置、右节点位置。对于元素 arr[i] != null，设 m 是 [0,i] 中 null 节点的个数，且设索引从 0 开始。则：</p>
<ul>
<li>左节点索引为：2(i-m)+1</li>
<li>右节点索引为：2(i-m)+2</li>
</ul>
<p>版本 1 没有类似结论的原因是：对于一个非空节点，它的子节点不一定在遍历结果中。换句话说，null 作为额外信息，能够帮助我们恢复二叉树结构。</p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>修改循环体的结构即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">layerSize</span> <span class="operator">=</span> q.size(); <span class="comment">// 需要提前记录，而不能写为 for i in q.size()，因为循环过程 q.size() 会改变</span></span><br><span class="line">    <span class="keyword">for</span> i in layerSize&#123;</span><br><span class="line">        <span class="type">node</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> v in G.Adj[n]&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="comment">// v.init();</span></span><br><span class="line">                v.d = u.d + <span class="number">1</span>;</span><br><span class="line">                v.p = u;</span><br><span class="line">                visited[v] = <span class="literal">true</span>;</span><br><span class="line">                q.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>从图 G 的源结点 s 出发进行深度优先搜索。注意，</p>
<ul>
<li>一次 dfs 不一定能将整张图搜索完</li>
<li><strong>dfs 有回溯的概念</strong></li>
</ul>
<p>在以下 dfs 的实现中：</p>
<ul>
<li><p>为了形象化 dfs 深度优先遍历的本质，令每个<strong>节点</strong>拥有：</p>
<ul>
<li>属性 d，表示<strong>发现时间</strong>，刚访问到本节点，也可以表示从源结点 s 到当前节点的最短路径（<strong>路径无权值情况下</strong>）</li>
<li><p>属性 f，表示<strong>完成时间</strong>，已经访问完本节点能到达的所有结点。</p>
<p>并且，令节点的<strong>状态为三种</strong>而非两种，visited 是三值的</p>
</li>
</ul>
</li>
<li><p>为了形象化图的连接关系，令每个节点拥有属性 p，表示其父结点</p>
</li>
<li><p>之所以在访问到的时候才初始化节点，是为了适配节点作为函数状态的场景，这种场景下，无法在一开始就初始化全部节点。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dfs(G, s)&#123;</span><br><span class="line">    <span class="comment">// time 是外部变量，整个 dfs 过程对应唯一一个 time 变量</span></span><br><span class="line">    <span class="comment">// 之所以 ++time，是因为调用 dfs(G, s) 的代码处没有加时间</span></span><br><span class="line">    ++time; </span><br><span class="line">    s.d = time;</span><br><span class="line">	visited[s] = gray;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> v in G.Adj[s]&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[v] == white)&#123;</span><br><span class="line">            v.p = s;</span><br><span class="line">            dfs(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经访问完本节点能到达的所有结点</span></span><br><span class="line">    visited[s] = black;</span><br><span class="line">    ++time;</span><br><span class="line">    s.f = time;</span><br><span class="line">&#125;</span><br><span class="line">Dfs(G)&#123;</span><br><span class="line">    <span class="comment">// visited 初始化</span></span><br><span class="line">    <span class="keyword">for</span> v in G.v</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> v in G.V&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[v] == white)</span><br><span class="line">            dfs(G, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>无回溯版本的写法</strong>，不维护 d 和 f 属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dfs(G, s)&#123;</span><br><span class="line">	visited[s] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> v in G.Adj[s]&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[v] == <span class="literal">false</span>)&#123;</span><br><span class="line">            v.p = s;</span><br><span class="line">            dfs(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>先来看深度优先搜索在一个有向图上的运行过程。</p>
<ul>
<li><p>图中节点只记录 d 和 f 属性，发现时间/完成时间</p>
</li>
<li><p>边则分为树边和非树边（后向（back）边、横向（cross）边、前向（forward）边），其中树边用阴影标记，非树边用虚线标记，非树边中的三种边又各自标记为 B、C、F</p>
</li>
</ul>
<p>对边进行分类的意义将在后面提到。</p>
<p><img src="/2022/04/24/graph-alg/image-20220425112400943.png" alt="深度优先搜索在有向图上的运行过程"></p>
<p>深度优先搜索的一个重要性质是：</p>
<p>节点的发现时间和完成时间具有<strong>括号化结构</strong>。如果以左括号表示发现节点，右括号表示完成节点，根据搜索过程画出来的括号会是一个有效的括号字符串。</p>
<p><img src="/2022/04/24/graph-alg/image-20220425141808805.png" alt="深度优先搜索的性质"></p>
<p>(a) 表示有向图的深度优先搜索过程，(b) 表示深搜过程每个节点的发现时间和完成时间得到的括号化结构</p>
<p>定理</p>
<p><img src="/2022/04/24/graph-alg/image-20220425142531677.png" alt></p>
<p><img src="/2022/04/24/graph-alg/image-20220425142833640.png" alt="image-20220425142833640"></p>
<p><img src="/2022/04/24/graph-alg/image-20220425143022405.png" alt="image-20220425143022405"></p>
<p>第一种情况，符合树边的定义。第二种情况，第一次探索边 (u, v) 说明 u 此时一定是灰色，而 v 也为灰色，说明它们此前已经处于一个深度优先树中，对于第三种情况</p>
<p><img src="/2022/04/24/graph-alg/image-20220425143420328.png" alt="image-20220425143420328"></p>
<p><img src="/2022/04/24/graph-alg/image-20220425143447559.png" alt="image-20220425143447559"></p>
<h3 id="回溯相关的题目"><a href="#回溯相关的题目" class="headerlink" title="回溯相关的题目"></a>回溯相关的题目</h3><p>需要注意的是，这里的图，节点经常是可以多次访问的。我们需要修改dfs 的回溯版本，状态不应该有 black</p>
<p>从某个节点搜索完它能到达的所有结点之后，回溯到它的父结点，子路径visited被重置。唯一区别，每个节点的visited不同（即能访问的目标节点不同），搜索过程中，所有节点并不共享同一个visited。<br>注意添加元素和回溯元素的代码位置</p>
<p><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></p>
<p><img src="/2022/04/24/graph-alg/image-20220425111027552.png" alt="image-20220425111027552"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上一个节点的排列、visited需要作为参数传入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; preList, <span class="type">int</span>[] visited)</span>&#123; </span><br><span class="line">    <span class="comment">// 搜索终止条件</span></span><br><span class="line">    <span class="comment">// dfs不需要返回值，每次搜索到最后位置（即代表找到一条有效路径），更新结果即可。</span></span><br><span class="line">    <span class="keyword">if</span> (preList.size() == n) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(preList)); <span class="comment">// 如果在下边的分支处使用的是推入再弹出法，则这里加入的preList都是同样的，因为是引用，内容会在最终preList更新完之后确定。因此，需要res.add(preList的拷贝)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            preList.add(nums[i]);</span><br><span class="line">            dfs(preList, visited);</span><br><span class="line">            preList.remove(preList.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个节点对应一个（前缀）排列，每个节点根据当前的visited数组情况产生分支。树深度为n=3</p>
<p>因此，树角度，每个节点应该包含两个属性：当前排列、当前visited数组。当树深度为n，停止生长。</p>
<p>从搜索角度，每个节点接收上一个节点的属性作为输入（自上而下的搜索思路，而非自下而上），根据visited数组产生分支进入下一个节点，当节点的属性：当前排列长度为n时，停止搜索并返回。</p>
<p>注意区别于搜索。</p>
<p><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></p>
<p>每次用 剩余元素 凑成全排列。对于剩余元素集合，如果第一个拿出来的数相同，那么剩余的数也相同，则这两套全排列也相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 剪枝策略</span></span><br><span class="line">        <span class="keyword">if</span>(set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        preList.add(nums[i]);</span><br><span class="line">        dfs(preList, visited); <span class="comment">// 以 nums[i] 开头的不重复全排列</span></span><br><span class="line">        preList.remove(preList.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></p>
<p>背包问题求组合，会浪费大量空间。因此，搜索求。</p>
<p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></p>
<p>设 candidates = [2, 1, 2, 2, 5], target = 5。为了去重以及第一个break，先将它排序 </p>
<p><img src="/2022/04/24/graph-alg/image-20220425112047920.png" alt="image-20220425112047920"></p>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>许多实际应用都用有向无环图来指明事件的优先次序、顺序逻辑。例如穿衣服可以这么穿：</p>
<p><img src="/2022/04/24/graph-alg/image-20220425143754658.png" alt></p>
<p>上图描述的是经过拓扑排序后的节点次序，这个<strong>次序与节点的完成时间正好相反</strong></p>
<p>可以将图的拓扑排序看做是将图的 <strong>所有</strong> 结点在一条水平线上展开，图的所有边都由左指向右。如果存在多个入度为 0 的节点，能构成多个线性排序的子图，仍旧可以把它们放到一条水平线上，虽然存在断点。</p>
<p>需要注意的是，有向边为：（前提节点，完成后可以到达的节点）。</p>
<p>拓扑排序的实现方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode <span class="title function_">topoLogicalSort</span><span class="params">(G)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    Dfs(G); <span class="comment">// 每个节点为 black 时，将其插入到链表头部</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对 Dfs(G) 进行修改，只需要修改 dfs(G, s)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(G, s)</span>&#123;</span><br><span class="line">    <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">	visited[s] = gray;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">    <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">    <span class="keyword">for</span> v in G.Adj[s]&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[v] == white)&#123;</span><br><span class="line">            dfs(G, v);</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == gray) &#123;</span><br><span class="line">            valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经访问完本节点能到达的所有结点</span></span><br><span class="line">    visited[s] = black;</span><br><span class="line">    <span class="comment">// 创建链表节点，添加到链表头部</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(s.val);</span><br><span class="line">    x.next = head;</span><br><span class="line">    head = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p><strong>图能够得到拓扑排序</strong>的<strong>充要</strong>条件：有向无环图</p>
<p><strong>有向图无环</strong>的<strong>充要</strong>条件：对其进行深度优先搜索不产生后向边</p>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p><a href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a>：得到一种拓扑排序结果</p>
<p><a href="https://leetcode-cn.com/problems/course-schedule/">课程表</a>：判断是否存在拓扑排序，本质上等价于判断有向图是否有环。</p>
<h1 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h1><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>在一给定的连通无向图 G = (V, E) 中，用 (u, v) 代表连接顶点 u 与顶点 v 的边，用 w(u, v) 代表此边的权重。V 表示结点的集合，E 表示边的集合。</p>
<p>对于一个有着 n 个结点的连通无向图，我们希望找到一个无环子集 T⊆E，将所有结点连接起来，且 T 的边权重总和最小，即令：$w(T)=\sum_{(u,v)\epsilon T}^{}w(u,v)$最小。</p>
<p>由于 T 是无环的，并且连通所有的结点，因此，T 是一颗树，称其为图 G 的生成树；又由于 T 的边权重总和是所有生成树中最小，所以称 T 为图 G 的最小生成树。</p>
<p><img src="/2022/04/24/graph-alg/image-20220425150859709.png" alt></p>
<p>解决最小生成树的两个算法：Kruskal 算法和 Prim 算法。两种算法都是贪心算法。</p>
<h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>Kruskal 算法使用并查集，每个集合代表当前当前森林中的一棵树。MST 表示获得最小生成树，获得最小生成树的算法中，将维护一颗树 A（用边的集合表示），保证每次对 A 进行操作时，A 是最终获得的最小生成树的一部分。<img src="/2022/04/24/graph-alg/image-20220425150821799.png" alt="image-20220425150821799"></p>
<ul>
<li>算法的 1~3 行将集合 A 初始化为一个空集，并创建 |V| 颗树，每棵树仅包含一个节点。</li>
<li>算法第 4 行将所有的边按照升序排序，排序的元素是节点对，排序的规则是按照边的权重。便于 for 循环进行检查</li>
<li>算法的 5~8 行的 for 循环按照权重从低到高的次序对每条边逐一进行检查，对于边 (u, v) 来说，检查端点 u 和端点 v 是否属于同一棵集合，如果是，该条边不能加入到森林里（否则将形成环路），如果不是，则两个端点分别属于不同的树，把这条边加入到集合 A 中，然后把两棵树进行合并。</li>
</ul>
<p><strong>时间复杂度分析</strong>：O(ElogV)，依赖于并查集的维护算法、</p>
<p><img src="/2022/04/24/graph-alg/image-20220425201219394.png" alt></p>
<p><img src="/2022/04/24/graph-alg/image-20220425201253982.png" alt></p>
<p><img src="/2022/04/24/graph-alg/image-20220425201330041.png" alt></p>
<h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>在 Prim 算法的执行过程中，所有不在树 A 中的节点都存放在一个基于 key 属性的最小优先队列 Q 中。对于每个节点 v，属性 v.key 保存的是连接 v 和树 A 中节点的所有边中最小边的权重。</p>
<p><strong>每次，检查从树 A 中的节点能到达的属于队列 Q 的节点，选择其中权重最小的边加入树 A</strong></p>
<p><img src="/2022/04/24/graph-alg/image-20220425154846888.png" alt></p>
<p><img src="/2022/04/24/graph-alg/image-20220425154926083.png" alt></p>
<p>Prim 算法的关键在于维护最小优先队列，队列存放的是节点，维护的规则为：</p>
<p>对于所有属于队列的节点，队头节点具有一条连接到树 A 的最小权值的边。实际上也就是<strong>根据节点的属性 key 来维护最小优先队列</strong>。</p>
<p>在下面的伪代码中，由于我们保持了上述规则，因此在将队头节点 u 加入树 A 后，可以更新其子节点 v 到树 A 的 key 属性，每次从队列中选出一个节点加入到树 A，都会导致队列中部分元素的属性 key 变化，而<strong>这在上面的 Prim 算法示意图中并没有体现出来</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 伪代码描述</span><br><span class="line">MST-PRIM(G, w, r):</span><br><span class="line">	for u in G.V:</span><br><span class="line">		u.key = INF // 无穷大，一开始节点只在 Q 中</span><br><span class="line">		u.p = NULL</span><br><span class="line">    r.key = 0</span><br><span class="line">    </span><br><span class="line">    Q = G.V</span><br><span class="line">    while(!Q.isEmpty()):</span><br><span class="line">    	u = EXTRACT-MIN(Q) // 一开始，会把节点 r 选出</span><br><span class="line">    	for v in G.Adj[u]:</span><br><span class="line">    		if v belongsto Q and w(u,v) &lt; v.key:</span><br><span class="line">    			v.p = u</span><br><span class="line">    			v.key = w(u,v)</span><br><span class="line">    			// 维护队列性质不变</span><br><span class="line">    			Q.update()</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析</strong>：</p>
<ul>
<li>使用二叉堆实现最小优先队列。O(V+VlogV+ElogV) = O(VlogV+ElogV)<ul>
<li>初始化队列：BUILD-MIN-HEAP，O(V)</li>
<li>while 语句的执行次数是 V 次，每次EXTRACT-MIN(Q) 操作实际上包括：弹出队头元素，MAX-HEAPIFY，因此 O(logV)，while 总共的EXTRACT-MIN(Q) 时间复杂度 O(VlogV)</li>
<li>while 总共的 for 次数是 E 次，每次需要 MAX-HEAPIFY 维护队列，while 总共的 for 时间复杂度 O(ElogV)</li>
</ul>
</li>
<li>使用斐波那契堆实现最小优先队列。O(E+VlogV)</li>
</ul>
<p>常见的一些实现方式中，并没有维护最小优先队列，而是遍历剩余未添加到树 A 的节点，并查看其 key 属性，找到符合条件的节点。</p>
<p><strong>Prim 算法的 Java 实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> parent; <span class="comment">// 标记本节点的父结点，-1 表示不存在</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 标记本节点</span></span><br><span class="line">    <span class="type">boolean</span> inQueue; <span class="comment">// true 表示该节点在队列中</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> k, <span class="type">int</span> p, <span class="type">int</span> v, <span class="type">boolean</span> iQ)&#123;</span><br><span class="line">        <span class="built_in">this</span>.key = k;</span><br><span class="line">        <span class="built_in">this</span>.parent = p;</span><br><span class="line">        <span class="built_in">this</span>.val = v;</span><br><span class="line">        <span class="built_in">this</span>.inQueue = iQ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接矩阵存储图，0 表示无连接</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Node&gt; <span class="title function_">mstPrim</span><span class="params">(<span class="type">int</span>[][] graph)</span>&#123;</span><br><span class="line">    PriorityQueue&lt;Node&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Node&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Node e1, Node e2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> e1.key - e2.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// nodes 中 inQueue 属性为 false 的节点即为树 A 中的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> graph.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MAX_VALUE, -<span class="number">1</span>, i, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            n.key = <span class="number">0</span>; <span class="comment">// 保证一开始的队头元素符合要求</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传递引用</span></span><br><span class="line">        q.offer(n); </span><br><span class="line">        nodes.add(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">u</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        u.inQueue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[u.val][i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">v</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(v.inQueue &amp;&amp; graph[u.val][i] &lt; v.key)&#123;</span><br><span class="line">                    v.parent = u.val;</span><br><span class="line">                    v.key = graph[u.val][i];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 删除再加入，维护队列性质</span></span><br><span class="line">                    q.remove(v);</span><br><span class="line">                    q.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nodes; <span class="comment">// 通过节点的 parent 属性得到树结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2022/04/21/network-layer/</url>
    <content><![CDATA[<p>网络层：为主机之间的逻辑通信（IP寻址）提供服务，选择合适的路由和交换结点，数据单位称为数据报</p>
<ul>
<li>IP（Internet Protocol），定义了 IP 数据报的字段以及端系统和路由器如何处理 IP 数据报</li>
<li>路由选择协议：IP 数据报根据什么样的路由从源传输到目的</li>
<li>ICMP，因特网控制报文协议</li>
</ul>
<span id="more"></span>
<h1 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h1><p><img src="/2022/04/21/network-layer/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt></p>
<ul>
<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li>
<li><strong>生存时间</strong> ：<strong>TTL</strong>，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。<strong>以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报</strong>。</li>
<li><strong>协议</strong> ：<strong>指出携带的数据应该上交给哪个协议进行处理</strong>，例如 <strong>ICMP、TCP、UDP</strong> 等。</li>
<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分（只通过首部计算校验和）可以减少计算的工作量。</li>
<li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，<strong>相同数据报的不同分片具有相同的标识符</strong>。</li>
<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<p><img src="/2022/04/21/network-layer/23ba890e-e11c-45e2-a20c-64d217f83430.png" alt></p>
<blockquote>
<p>网络层是不可靠数据传输</p>
</blockquote>
<h1 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h1><p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p><img src="/2022/04/21/network-layer/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" alt style="zoom:50%;"></p>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p><strong>在分类的基础之上</strong>，通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<h3 id="无分类"><a href="#无分类" class="headerlink" title="无分类"></a>无分类</h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为构成超网 。</p>
<blockquote>
<p>路由聚合</p>
<p>有如下的4个/24地址块，试进行最大可能的聚合。</p>
<p>212.56.132.0 /24<br>212.56.133.0 /24<br>212.56.134.0 /24<br>212.56.135.0 /24</p>
<p>将上面四个地址块进行二进制转换</p>
<p>212.56.10000100.0 /24<br>212.56.10000101.0 /24<br>212.56.10000110.0 /24<br>212.56.10000111.0 /24</p>
<p>相同的前缀有22位，保留相同位数，将相同比特后面的数（到末尾）填充为0，所以很容易得出聚合后的地址块为：212.56.132.0/22</p>
</blockquote>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<h1 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h1><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<p>ARP 实现由 IP 地址得到 MAC 地址。</p>
<p><img src="/2022/04/21/network-layer/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" alt></p>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<p><img src="/2022/04/21/network-layer/8006a450-6c2f-498c-a928-c927f758b1d0.png" alt></p>
<h1 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h1><p>ICMP 最典型的应用是差错报告。</p>
<p>ICMP 通常被认为是 IP 的一部分，但从体系结构上讲它是位于 IP 之上的，因为 ICMP 报文封装在 IP 数据报中，如下图所示。</p>
<p><img src="/2022/04/21/network-layer/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" style="zoom: 67%;"></p>
<p>ICMP 报文分为差错报告报文和询问报文。常用的几种类型如下</p>
<p><img src="/2022/04/21/network-layer/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" style="zoom: 50%;"></p>
<h2 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h2><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<p><img src="/2022/04/21/network-layer/image-20220425211201320.png" alt></p>
<h2 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h2><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。<strong>第一个数据报 P1 的生存时间 TTL 设置为 1</strong>，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 <strong>ICMP 时间超过差错报告报文</strong>；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h1 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h1><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以<strong>使用 NAT 来将本地 IP 转换为全球 IP</strong>。</p>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下<strong>拥有 n 个全球 IP 地址的专用网</strong>内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2719067e-b299-4639-9065-bed6729dbf0b.png" alt="NAT 转换表"></p>
<p>需要注意的是，NAT 使能路由器才具有 NAT 地址转换功能，该路由器拥有受限的几个全球 IP 地址</p>
<p>所有离开 NAT 使能路由器的报文的源 IP 地址相同，所有进入 NAT 使能路由器的报文的目的 IP 地址相同。这里的 IP 地址指的是外网的 IP 地址，即图上的 172.38.1.5</p>
<h1 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h1><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>VPN 使用公用的互联网作为本机构<strong>各专用网之间的</strong>通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p>
<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，<strong>目的地址是路由器 R2 的全球地址</strong> 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。（VPN 用的这几个 NAT 路由器是已知的）</p>
<p><img src="/2022/04/21/network-layer/1556770b-8c01-4681-af10-46f1df69202c.jpg" alt></p>
<h1 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h1><p>路由器从功能上可以划分为：路由选择和分组转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c3369072-c740-43b0-b276-202bd1d3960d.jpg" alt="路由器的结构" style="zoom:80%;"></p>
<h1 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h1><ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<p><img src="/2022/04/21/network-layer/1ab49e39-012b-4383-8284-26570987e3c4.jpg" alt></p>
<h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><p><strong>自治系统</strong>（Autonomous System，AS）</p>
<p>每个 AS 由一组通常处在相同管理控制下的路由器组成，例如由相同的 ISP 运营或属于相同的公司网络</p>
<p><img src="/2022/04/21/network-layer/image-20220422100237090.png" alt="自治系统" style="zoom:80%;"></p>
<p>在上图中，从路由器连出的细线表示直接与该路由器相连的子网，粗线表示路由器之间的连接。注意到，路由器 1b、1c、2a 和 3a 都是网关路由器（负责向本 AS 之外的路由器转发分组）</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择（域内路由选择）：内部网关协议 RIP 和 OSPF</li>
<li>自治系统间的路由选择（域间路由选择）：外部网关协议 BGP</li>
</ul>
<blockquote>
<p>在某个 AS 内的一台路由器，怎样知道如何将分组路由选择到位于本 AS 外部的目的地呢？</p>
<ul>
<li>如果本 AS 仅有一个网关路由器，沿着最低费用路径转发到网关路由器，然后由网关路由器转发到另一个 AS 的网关路由器</li>
<li>如果本 AS 有多个网关路由器？域间路由选择协议</li>
</ul>
</blockquote>
<h2 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h2><p>全称是路由信息协议 RIP (Routing Information Protocol) 。</p>
<p>参考图最短路径算法，修改松弛规则为：无向图，已经知道源 s 到目的 v 的当前最短路径 s.v，对于与源 s 相邻的节点 u，易知 u 到目的 v 的当前最短路径为 edge(u, s)+s.v</p>
<p><img src="/2022/04/21/network-layer/1620-16506253250823.png" alt="路由表更新方法" style="zoom: 67%;"></p>
<p>RIP 协议特点</p>
<ul>
<li>距离矢量路由协议。用跳数评估路由代价。</li>
<li>仅和相邻路由器交换信息。</li>
<li>按固定的时间间隔发 RIP 报文（自己的路由选择表信息），例如，每隔 30 秒。</li>
</ul>
<p>RIP 协议缺陷：</p>
<ul>
<li>用跳数评估路由并非最佳评估方式。应该用带宽（单位时间可传输比特数）评估</li>
<li>最大跳数限制为 15，这使得路由器无法学习到到超过 15 跳的路由器的路由表项</li>
<li>收敛速度慢，为了避免环路，需要做额外的许多工作</li>
</ul>
<h2 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h2><p><strong>OSPF 基本原理</strong>：</p>
<ol>
<li>网络上的各个路由器向自己的邻接路由器发送自己的链路状态信息摘要，多次执行以后（收敛），每个路由器能建立一个全网的链路信息拓扑图（图的节点是路由器，边的权值是带宽）。</li>
<li>对于某个路由器，由于它已经获得了全网的链路信息拓扑图，它可以以自己为源结点 s，使用 dijkstra最短路径算法来判断到任意一个节点的最优路由</li>
</ol>
<p><img src="/2022/04/21/network-layer/image-20220422192723421.png" alt="OSPF原理图"></p>
<p>邻接路由器的选择：需要先发现自己的所有邻居（以广播的方式），然后在邻居中选举 DR 和 BDR，网络中所有路由器只与 DR 和 BDR 建立邻接关系。</p>
<p><img src="/2022/04/21/network-layer/image-20220422192049617.png" alt="邻接路由器的选择"></p>
<p><strong>OSPF 协议特点</strong></p>
<ul>
<li>链路状态路由协议。用链路开销（带宽）评估路由代价。（OSPF 还解决了 RIP 的另外两个缺陷）</li>
<li>每隔 30 分钟向邻接路由器（1个或者多个邻接路由器）发送本路由器的链路状态信息摘要，或者触发式更新（网络发生变化时）</li>
<li>增量更新，减少每次发送的链路状态信息摘要数据</li>
</ul>
<p><img src="/2022/04/21/network-layer/image-20220422192612690.png" alt="增量更新"></p>
<p><strong>OSPF 分区域管理</strong></p>
<p>当网络很庞大时，每个节点都维护一个全网的链路信息拓扑图，非常地耗费时空资源，并且实际上是很浪费的，因为节点通常只放问某个区域内的网络节点。</p>
<p>因此，将网络分为几个区域，每个区域内，路由器维护自己区域的链路信息拓扑图，并选择一个区域边界路由器 ABR 用来连接两个不同的区域。需要注意到，一个 ABR 处于两个区域中，而非两个 ABR 连接两个区域。因此，ABR 知道两个区域的链路信息拓扑图。</p>
<h1 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h1><p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<p><img src="/2022/04/21/network-layer/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" alt="img" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>随机数问题</title>
    <url>/2022/04/14/random-number-question/</url>
    <content><![CDATA[<p>生成离散均匀分布的随机数的方法、打乱数组和随机抽样</p>
<span id="more"></span>
<h1 id="随机数的生成"><a href="#随机数的生成" class="headerlink" title="随机数的生成"></a>随机数的生成</h1><p>定义 rand(N) ：生成 [1,N] 的均匀随机整数</p>
<p>性质：</p>
<ol>
<li><p>rand(N) + x 可生成 [1+x, N+x] 的均匀随机整数。要实现 0 ~ 6 随机器，只需要在 rand7() 的返回值上进行 -1 操作即可。</p>
<p> 注意 rand(N) + x ≠ rand(N+x)，因为起点不是 1</p>
</li>
<li><p>rand(N+x) ≠ rand(N) + rand(x)。</p>
<p> rand(7) + rand(7) 会产生 [2, 14] 范围内的数，但每个数并非等概率：</p>
<ul>
<li>产生2的概率为：1/7 * 1/7，即两个离散均匀分布同时输出 1</li>
<li>产生4的概率为：1/7 <em> 1/7 + 1/7 </em> 1/7 + 1/7 * 1/7</li>
</ul>
</li>
<li><p>rand(N<em>N) = (randN() - 1) </em> N + (randN() - 1)，这里的 rand(N<em>N) 表示 [0, N\</em>N-1] 的离散均匀分布。</p>
</li>
</ol>
<p>生成的数不等概率的原因在于：两次随机值的不同组合「相加」的会出现相同的结果.鉴于此，可以从另一个角度看两次随机值对应的结果，即x、y对应一个进制数(xy)7，在这里是七进制数，而非看作x+y。也就是说1、1对应117，而非1+1=2.</p>
<p>进一步地，为了统一进制数为通用形式，即每个位的范围是0~6，而非1~7，可以先将rand7()做减一操作。如果不做此操作，那么两位七进制数就是117到777，起始数是8</p>
<p>最终，由于rand7()输出的是1 到 7 范围内的均匀随机整数，为了调整输出值为7进制数，则令输出为：(rand7() - 1) * 7 + (rand7() - 1)，两个加数分别表示七进制数的第1位和第0位。对应一个007到667（即十进制数0~48）的离散均匀分布.容易利用加法性质进行偏移。</p>
<p>也就是说，求两次rand7，并且把两次的结果表示为一个7进制数。生成的7进制数是均匀随机的</p>
<h2 id="拒绝采样"><a href="#拒绝采样" class="headerlink" title="拒绝采样"></a>拒绝采样</h2><p>拒绝采样可以由 rand(N) 得到 rand(M)，M &lt; N。在拒绝采样中，如果生成的随机数满足要求，那么就返回该随机数，否则会不断生成，直到生成一个满足要求的随机数为止。</p>
<p>例如，用 rand10 进行拒绝采样，可得到 rand7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> rand10();</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= <span class="number">1</span> &amp;&amp; ans &lt;= <span class="number">7</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出 1~7 中任意数字的概率为：</p>
<p><img src="/2022/04/14/random-number-question/image-20220414214209781.png" alt></p>
<p>实际上，根据上述证明过程，我们可以利用拒绝采样生成 [1, 10] 区间内的整数构成的所有子集的离散均匀分布。但是，通常只有 1~x 的离散均匀分布是有意义的。</p>
<p>来看另一个例子，用 Rand49() 实现 Rand10()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> rand49(); <span class="comment">// 进制转换</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &lt;= ans &amp;&amp; ans &lt;= <span class="number">40</span>) <span class="keyword">return</span> ans % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> rand49(); </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &lt;= ans &amp;&amp; ans &lt;= <span class="number">10</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种拒绝采样方式都是可以的，但是法 1 的效率更高，因为对于 rand49() 的绝大多数输出，都能得到一个有效的返回值，减少了 rand49() 的执行次数。</p>
<p>法1 的正确性同样可以通过求概率的方式证明。</p>
<h1 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h1><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>如何随机打乱一个数组？不妨设数组 nums，其长度为 n。我们可以使用如下方法打乱：</p>
<ul>
<li>将数组中所有的数都放到数据结构 waiting 中，并初始化打乱后的数组 shuffle；</li>
<li>从 0 开始顺序遍历 shuffle 的所有位置并填入数字，在第 i 次遍历中<ul>
<li>从 waiting 中随机等概率抽取一个数 num，将其作为 shuffle 的第 i 个元素</li>
<li>从 waiting 中移除 num</li>
</ul>
</li>
</ul>
<h3 id="合理性证明"><a href="#合理性证明" class="headerlink" title="合理性证明"></a>合理性证明</h3><p>证明：对于原数组 nums 中的任意一个数字来说，被移动到打乱后的数组的第 i 个位置的概率为：</p>
<p><img src="/2022/04/14/random-number-question/image-20220414215914112.png" style="zoom:150%;"></p>
<p>也即 nums 中的任意一个数字在第 i 次被抽到的概率。/n</p>
<p>因此，对于原数组 nums 中的任意一个数，被移动到打乱后的数组的任意一个位置的概率都是相同的，都是 1/n。</p>
<p>从排列的角度：把所有排列（n! 种）存起来，等概率抽取一个作为 shuffle 数组。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>主要需要实现的功能：</p>
<ul>
<li>从 waiting 中随机等概率抽取一个数 num</li>
<li>从 waiting 中删除 num</li>
</ul>
<p>对于任意一个线性数据结构，例如对于数组 A，从中随机等概率抽取一个数的方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">picked</span> <span class="operator">=</span> random.nextInt(A.length); <span class="comment">// 随机等概率生成 [0, A.length-1] 的数字</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> A[picked]</span><br></pre></td></tr></table></figure>
<p>为了方便删除元素，可以选用 List 而非数组作为 waiting 的数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">picked</span> <span class="operator">=</span> random.nextInt(list.size());</span><br><span class="line">    shuffled[i] = list.remove(picked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析：</p>
<p>List 的删除操作与数组的删除操作相比，时间复杂度都是 O(N)，只不过 List 已经封装好，调用 remove() 即可。如果这里要使用数组的话，也是可以的，每次将剩下的数都往 0 方向连续排列，并维护剩余数字的数量即可。</p>
<p>优化 waiting 的更新操作：</p>
<ul>
<li>为了改进删除操作，类似 LRU 的想法，可以用链表存储数字，用一个变量维护链表长度，用 HashMap 保存 (数字 num，链表中的对应结点)，调用 Java 中双向链表的 remove() 方法即可。实现过程需要注意重复数字的情况，这种情况下，键值对应该改为 (数字，结点集合)</li>
<li>上面的方法存储的是剩余的数集，而下面提到的无放回抽样的想法是存储剩余的坐标。相比之下，无放回抽样介绍的方法实现起来更加简单。</li>
</ul>
<h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><p>不需要使用额外的空间存储 shuffle 数组。</p>
<p>设指针 x，维护 nums[0:x-1] 为打乱后的结果，nums[x:n-1] 为剩余数字：</p>
<p>对于下标 x 而言，我们从 [x,n−1] 中随机出一个位置与 x 进行值交换，当所有位置都进行这样的处理后，我们便得到了一个公平的洗牌方案。</p>
<h1 id="随机抽样"><a href="#随机抽样" class="headerlink" title="随机抽样"></a>随机抽样</h1><p>分为无放回抽样和有放回抽样。</p>
<p>对于线性数据结构随机抽取的方法，适用于链表、数组等。</p>
<h2 id="有放回抽样-水塘抽样法"><a href="#有放回抽样-水塘抽样法" class="headerlink" title="有放回抽样-水塘抽样法"></a>有放回抽样-水塘抽样法</h2><p>从 n 个样本中抽取一个样本，然后放回，要求每个样本被抽到的概率相等，即为 1/n。</p>
<p>从 nums[0] 开始，遍历整个数组，对遍历到的 nums[i]，随机选择区间 [0,i) 内的一个整数，如果其等于 0，则将抽样值记为 nums[i]，否则抽样值不变。</p>
<p>之前如果设置了 ans ，现在又得到0，不影响。只与后面是否又得到0有关</p>
<p>假设最终成为答案的样本编号为 i，那么 i 成为答案的充要条件为「在遍历到 i 时被选中」并且「遍历大于 i 的所有元素时，均没有被选择」，因此 nums[i] 作为最终抽样值的概率为：</p>
<p><img src="/2022/04/14/random-number-question/image-20220414222453324.png" style="zoom:130%;"></p>
<p>0~i-1 位置的元素即便被选中过，也不会影响这个概率计算式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode head;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">20220116</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(ListNode _head)</span> &#123;</span><br><span class="line">        head = _head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="literal">null</span> &amp;&amp; ++idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (random.nextInt(idx) == <span class="number">0</span>) ans = t.val;</span><br><span class="line">            t = t.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相关题目：<a href="https://leetcode-cn.com/problems/linked-list-random-node/">链表随机节点</a></p>
</blockquote>
<p>如果是从二维数组中抽取，也是可以的，二维遍历即可，循环体不需要改变。</p>
<h2 id="无放回抽样"><a href="#无放回抽样" class="headerlink" title="无放回抽样"></a>无放回抽样</h2><p>从 n 个样本中抽取一个样本，不放回，要求每次抽取是等概率抽取。</p>
<p>基于有放回抽样，关键在于维护剩余的元素连续存放。</p>
<p><strong>分析：</strong></p>
<p>对于一个一维数组 nums 进行无放回抽样，nums 长度为 n。nums 所有元素初值为 0，表示未被抽取，若 nums[i] 被抽取，置 nums[i] 为 1，表示它已经被取出。</p>
<p>设已经进行了 k 次抽样，则数组中有 n<em>−</em>k 个 1 和 k 个 0。我们不能够改变数组元素的位置，但又需要让剩余的还没被抽到的元素连续存放。因此，可以建立 map：</p>
<ul>
<li>性质：map[0:k-1] 存储 nums 中剩余元素的下标，即值为 0 的元素的下标；map[k:n-1] 存储 nums 中值为 1 的元素的下标</li>
<li>抽样：当我们进行下一次翻转操作时，我们只需要在 [0, k-1) 这个区间生成随机数 x，并将 map[x] 映射到的矩阵的位置进行翻转即可。</li>
</ul>
<p>每次将 map[x] 进行翻转后，需要维护 map 的性质不变：</p>
<p>在将 map[x] 进行翻转后，此时矩阵中有 k−1 个 0，所以我们需要保证 map[0..k−2] 都映射到矩阵中的 0。由于此时 map[x] 映射到了矩阵中的 1，map[k−1] 仍旧映射到矩阵中的 0，因此我们可以将 map[x] 与 map[k−1] 的值进行交换。</p>
<p>实际上，我们只关心 map[x] 被交换后的值，因此，可以不需要交换操作：</p>
<ul>
<li>只需要用 map[k-1] 将 map[x] 覆盖</li>
<li>然后需要额外的变量 k，表示剩余为 0 的个数，执行覆盖操作后让 k 自减即可</li>
</ul>
<p>以下实现方式并不显式地创建 map，而是用哈希表记录 map[0:k-1] 中被改变的坐标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n, total; <span class="comment">// total 表示剩余为 0 的个数</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.total = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] flip() &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> rand.nextInt(total);</span><br><span class="line">        total--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找位置 x 对应的映射</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> map.getOrDefault(x, x);</span><br><span class="line">        <span class="comment">// 将位置 x 对应的映射设置为位置 total 对应的映射（即用边界的坐标覆盖 map[x]）</span></span><br><span class="line">        map.put(x, map.getOrDefault(total, total));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> idx; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相关题目：<a href="https://leetcode-cn.com/problems/random-flip-matrix/">随机翻转矩阵</a></p>
</blockquote>
<p>如果是从二维数组中抽取，也是可以的，将二维坐标 (i, j) 等效为一维坐标 i*n+j 即可。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/04/20/sort/</url>
    <content><![CDATA[<p>排序算法的评价标准主要有：时间复杂度、空间复杂度和稳定性（待排序的序列中有两元素相等，排序之后它们的先后顺序不变）</p>
<span id="more"></span>
<p><img src="/2022/04/20/sort/sort.png" alt="img"></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>维护循环不变量，即将数组划分为 （有序区，无序区），每次在无序区中选出最小的数（通过记录当前遇到的最小值的方法），放到有序区的后面（与无序区第一个元素进行交换）。</p>
<p><img src="/2022/04/20/sort/selectionSort.gif" alt="img"></p>
<p>性能分析：</p>
<ul>
<li><p>稳定性：交换操作可能导致两相等元素的相对位置改变，因此是<strong>不稳定</strong>的</p>
</li>
<li><p>时间复杂度：始终为 O(N^2)</p>
</li>
</ul>
<p>如果是对链表进行选择排序，可以进行适当的修改，使得选择排序是稳定的：</p>
<p>每次在无序区中选出最小的数，放到有序区的后面。对于链表，可以让选出的最小的数对应的节点从表中断开，然后插入到（有序区，无序区）的分界位置。</p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>维护循环不变量，即将数组划分为 （无序区，有序区），每次在无序区中<strong>通过不断交换的方法</strong>将最大的数放到无序区的最后。</p>
<p><strong>通过不断交换的方法</strong>选出最大的数：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
</ul>
<p><img src="/2022/04/20/sort/bubbleSort.gif" alt="img"></p>
<p>性能分析：</p>
<ul>
<li><p>稳定性：<strong>虽然有交换操作</strong>，但是这种交换操作不会导致两相等元素的相对位置改变，因此是稳定的</p>
</li>
<li><p>时间复杂度：始终为 O(N^2)</p>
</li>
</ul>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>维护循环不变量，即将数组划分为 （有序区，无序区），每次把无序区的第一个元素插入到有序区的合适位置中。</p>
<p>插入操作：对于数组来说，需要执行多次的赋值操作，对于链表才是真正意义上的插入操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,key;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        key = arr[i];</span><br><span class="line">        j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (arr[j]&gt;key)) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/20/sort/insertionSort.gif" alt="img"></p>
<p>性能分析：</p>
<ul>
<li><p>稳定性：由于是从后往前顺序地找插入点，因此不会导致两相等元素的相对位置改变，因此是<strong>稳定</strong>的。从前往后找插入点可能会不稳定，除非在相等时继续往后走。</p>
</li>
<li><p>时间复杂度：始终为 O(N^2)</p>
</li>
</ul>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="Partition算法"><a href="#Partition算法" class="headerlink" title="Partition算法"></a>Partition算法</h2><p>作用：给定一个数组 A 和数组中任意一个元素 pivot=A[r]， 通过一趟扫描，以 pivot 为分界线将数组中的元素原地重排为两部分，使得左边的数小于等于 pivot，右边的数大于 pivot。（等于号在哪一边都可以，具体实现的时候注意即可），最后返回 pivot=A[r] 排序之后的位置。</p>
<h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法 1"></a>实现方法 1</h3><p>双指针实现：设数组 A[p…r]，选取 pivot=A[r]，即数组最后一个元素，便于最后返回它排序之后的位置。所谓的双指针，指的是指针 i 和 j 维护了两个区域，见下方循环不变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> p, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> A[r];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> p-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=p;j&lt;r;++j)&#123;</span><br><span class="line">        <span class="comment">// [p, i] 的元素都 &lt;= pivot，i+1 的元素不满足。将满足条件的 A[j] 与 A[i+1] 交换并移动 i 指针到 i+1 的位置</span></span><br><span class="line">        <span class="keyword">if</span>(A[j] &lt;= pivot)&#123;</span><br><span class="line">            ++i; </span><br><span class="line">            swap(A, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(A, i+<span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第 3~6 行的 for 循环的每一轮迭代的开始和结束，数组将被划分为四个区域，每一个区域都满足一定的性质，我们将这些性质作为<strong>循环不变量</strong>：</p>
<p>在第 3~6 行的 for 循环的每一轮迭代的开始和结束（即上一轮 for 的 ++j 之后，本轮 for 的 if 语句前），对于任意下标 k，有：</p>
<ol>
<li><p>若 p≤k≤i，则 A[k]&lt;=x。 </p>
</li>
<li><p>若 i+1&lt;=k&lt;=j-1，则 A[k]&gt;x。</p>
</li>
<li>若 j&lt;=k&lt;=r-1，A[k] 与 x 无特定大小关系。</li>
<li>若 k=r，则 A[k]=x。</li>
</ol>
<p>证明：我们需要证明这个循环不变式在第一轮迭代之前是成立的，并且在之后的每一轮迭代后仍然成立。使用<strong>归纳法</strong>证明。</p>
<ul>
<li><p>初始化（第一轮迭代之前）：在第一轮迭代之前，x=A[r]，i=p-1，j=p，因为区域 1 和 2 为空，所以循环不变量的前两个条件都满足，第三个条件根据赋值操作也显然满足。注意 j=p 虽然在第 3~6 行的循环体中，但是它不属于迭代更新操作。</p>
</li>
<li><p>保持（每一轮迭代后）：根据第四行中条件判断的不同结果，需要考虑两种情况。当 A[j]&gt;x 和当 A[j]&lt;=x，易知两种情况下，一轮迭代之后循环不变式依旧成立。</p>
</li>
<li><p><strong>终止</strong>：当终止时，j=r。于是，数组中的每个元素必然属于循环不变量所描述的四个区域中的一个，易知区域 3为空。当继续执行倒数第二行代码时，A[r] 将被交换到正确的位置，数组 [p, i+1] 元素都 &lt;= x，[i+2, r] 元素都 &gt; x。</p>
</li>
</ul>
<p>缺陷：不高效。从直观上来说，每个小于 pivot 的值基本上都需要交换一次，而大于 pivot 的值可能要交换多次（这句话可以看区域 2 理解，每次交换会把区域 2 的头换到区域 2 中间，而之后再遇到说不定还得继续交换）。</p>
<p><strong>关于相对位置：[p, i] 区域元素的相对位置与之前一致，[i+1, j-1] 区域元素相对位置无法保证</strong>。</p>
<h3 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法 2"></a>实现方法 2</h3><p>双向扫描：设数组 A[p…r]，选取 pivot=A[r]。保持两个指针向中间扫描，在前面找到大于 pivot 的值，同时在后面找到小于等于 pivot 的值，把他们做一次交换，就可以一次把这两个数字放到其所属区域（这两个位置之后不会再被交换到其他地方）。</p>
<p>相较于实现方法 1，这种方法元素交换次数更少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> p, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> A[r];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=p, j=r-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j &amp;&amp; A[i] &lt;= x)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j &amp;&amp; A[j] &gt; x)</span><br><span class="line">            --j;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= j)&#123;</span><br><span class="line">            swap(A, i, j);</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(A, i, r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每次循环结束，[0,i) 的数&lt;=x，(j,r] 的数&gt;x。while 执行完后由于 pivot 在索引 r 处，因此要把 &gt;x 的数换过来，也就是把 i 或者 j+1 位置换过来。</p>
<h3 id="随机化-Partition"><a href="#随机化-Partition" class="headerlink" title="随机化 Partition"></a>随机化 Partition</h3><p>随机化 partition 的想法是，通过对序列的随机抽样，保证主元 pivot 是等概率从数组中选取的，因此在平均情况下，能够获得较好的期望性能。（期望在平均情况下，主元 pivot 更接近中位数的位置）</p>
<p>具体做法：首先随机抽样一个元素 x=A[ind]，然后将其与 A[r] 元素交换，再调用上述 partition 函数即可。</p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>最坏时间复杂度：当数组已经有序（升序或降序）时，时间复杂度 O(N^2^)，这是因为每次 partition 操作后，子问题的大小是 N-1 和 1</p>
<p>最好时间复杂度：O(NlogN)，即每次 partition 操作都能把主元放到中点。</p>
<p>空间复杂度：递归，每次 partition 需要空间 O(1)，递归深度 logN，因此空间复杂度 O(logN)</p>
<p>稳定性：不稳定，这是因为 partition 操作是不稳定的</p>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p>
<p><a href="https://leetcode-cn.com/problems/move-zeroes/">移动零</a></p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>类似 partition，维护两段的循环不变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] != <span class="number">0</span>) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href>颜色分类</a></p>
<p>法1：两次 partition，第一次：维护 0 和 非 0；第二次：在非 0 中维护 1 和非 1</p>
<p>法2：一次 partition，需要维护的循环不变量为三段：0、1、其他</p>
<p>用指针 p0 维护 0 区，指针 p1 维护 1 区。用指针 i 从左向右遍历整个数组：</p>
<ul>
<li><p>如果遇到 1，那么将其与 nums[p1] 进行交换，并将 p1 向后移动一个位置</p>
</li>
<li><p>如果遇到 0，那么将其与 nums[p0] 进行交换，并将 p0 向后移动一个位置。如果 p0&lt;p1，说明 nums[p0]=1，此时会把 1 交换给 nums[i]，那么我们需要再将 nums[i] 与 nums[p1] 进行交换，并将 p1 向后移动一个位置</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p0</span> <span class="operator">=</span> <span class="number">0</span>, p1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            swap(nums, i, p1);</span><br><span class="line">            ++p1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            swap(nums, i, p0);</span><br><span class="line">            <span class="keyword">if</span> (p0 &lt; p1) &#123;</span><br><span class="line">                swap(nums, i, p1);</span><br><span class="line">            &#125;</span><br><span class="line">            ++p0;</span><br><span class="line">            ++p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法3：一次 partition，需要维护的循环不变量为三段：0、其他、2。过程略</p>
<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第k大元素</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myFindKth</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> K)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> partition(a, l, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x == a.length-K) <span class="keyword">return</span> a[x];</span><br><span class="line">    <span class="comment">// 注意 x-1，这是因为如果选择 [l,x]，主元 a[x] 不会被移动，partition 不生效</span></span><br><span class="line">    <span class="comment">// 并且x位置的元素也肯定不可能是解</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; a.length-K) <span class="keyword">return</span> myFindKth(a, l, x-<span class="number">1</span>, K);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> myFindKth(a, x+<span class="number">1</span>, r, K);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序用数据结构“堆”来存放数据，数据结构“堆”不仅用在堆排序，同时也用于构造优先队列。</p>
<h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>如图，二叉堆是一个<strong>完全二叉树</strong>，除了最底层不保证填满外，该树是完全充满的。二叉堆使用数组存储元素，树上的每个节点对应数组中的一个元素，节点与数组中元素的对应关系是从根节点开始，每层从左至右填充到数组当中。</p>
<p>设数组长度为 n，以下假设数组下标从1~n，实际应该从 0 开始，见 <a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p>
<p><img src="/2022/04/20/sort/image-20220425213733262.png" alt></p>
<p>二叉堆满足如下性质：</p>
<ul>
<li><p>设用数组 A 存放二叉堆，A.heapsize 表示需要维护下班在 [1, A.heapsize] 范围的数组元素为一个二叉堆。</p>
</li>
<li><p>给定一个结点对应在数组中的下标 i，其父结点下标、左孩子和右孩子下标分别为：</p>
<script type="math/tex; mode=display">
  parent(i)=\lfloor i/2 \rfloor \\
  left(i)=2i \\
  right(i)=2i+1</script></li>
<li><p>若以节点 i 为根节点的树是一个二叉堆，则它的左右两颗子树也是二叉堆</p>
</li>
</ul>
<p>若数组下标从 0 开始，前两条性质应当修改为：</p>
<ul>
<li>A.heapsize 表示需要维护下班在 [0, A.heapsize] 范围的数组元素为一个二叉堆。</li>
<li>给定一个结点对应在数组中的下标 i，其父结点下标、左孩子和右孩子下标分别为：</li>
</ul>
<script type="math/tex; mode=display">
parent(i)=\lfloor (i-1)/2 \rfloor \\
left(i)=2i+1 \\
right(i)=2i+2</script><p>通过对二叉堆结点关系进行限制，我们可以创建两种堆：最大堆和最小堆。</p>
<ul>
<li><p>最大堆：除了根以外的所有结点 i 都满足：A[parent(i)] &gt;= A[i]，因此，根节点是最大元素，每颗子树是最大堆。</p>
</li>
<li><p>最小堆：除了根以外的所有结点 i 都满足：A[parent(i)] &lt;= A[i]，因此，根节点是最小元素，每颗子树是最小堆。 </p>
</li>
</ul>
<p>以下讨论最大堆的基本操作，包括：</p>
<ul>
<li>MAX-HEAPIFY，时间复杂度为 O(logn)，最大堆的最基本操作，用于维护最大堆</li>
<li>BUILD-MAX-HEAP，时间复杂度为 O(N)，推导较复杂，功能是将数组构造为一个最大堆</li>
<li>HEAPSORT：堆排序</li>
<li>MAX-HEAP-INSERT、HEAP-EXTRACT-MAX、HEAP-INCREASE-KEY 和 HEAP-MAXIMUM：时间复杂度都是 O(logn)，功能是用堆维护优先队列</li>
</ul>
<h2 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h2><h3 id="MAX-HEAPIFY"><a href="#MAX-HEAPIFY" class="headerlink" title="MAX-HEAPIFY"></a>MAX-HEAPIFY</h3><p>对于一个根节点为 i 的二叉堆，<strong>假设它的左右两颗子树都已经是最大堆</strong>，通过 MAX—HEAPIFY 操作，可将这个二叉堆转化为最大堆。</p>
<p><img src="/2022/04/20/sort/image-20220425215723705.png" alt="image-20220425215723705"></p>
<p>第 3 行的作用是，从 A[i]、A[left[i] 和A[right[i]] 中选出最大值，最大值的索引存储为largest。基于前提条件：i 的左右两颗子树都已经是最大堆，如果 A[i] 是最大的，那么以 i 为结点的子树已经是最大堆，结束。如果最大值 i 的某个孩子结点，则将其与根节点交换。交换后，A[i]、A[left[i] 和A[right[i]] 满足最大堆性质，未被交换的子树仍然是最大堆，而被交换了的子树满足MAX-HEAPIFY函数的条件，对其递归调用该函数即可。</p>
<p>证：交换后 A[i] 是 i 为根节点的子树最大值：<br>根据：i 的左右两颗子树都已经是最大堆，易知 A[left[i] 和 A[right[i]] 是这两个最大堆中的最大值，因此交换后满足：A[i] 是 i 为根节点的子树最大值。</p>
<p>max(A[i], A[l], A[r]) 的实现：比较两次，每次更新更大值的索引<br>largest = i;<br>if(l &lt;= A.heapsize &amp;&amp; A[l] &gt; A[largest])<br>    largest = l;<br>if(r &lt;= A.heapsize &amp;&amp; A[r] &gt; A[largest])<br>    largest = r;</p>
<p>注意保证l和r&lt;=A.heapsize，即在二叉堆中</p>
<h3 id="BUILD-MAX-HEAP"><a href="#BUILD-MAX-HEAP" class="headerlink" title="BUILD-MAX-HEAP"></a>BUILD-MAX-HEAP</h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/2022/04/07/transport-layer/</url>
    <content><![CDATA[<p>传输层提供了进程间的逻辑通信</p>
<span id="more"></span>
<p>套接字的唯一标识符</p>
<ul>
<li>端口号存在于 UDP/TCP 报文段的首部当中，IP 地址存在于网络层首部</li>
<li>UDP 套接字由二元组（目的IP地址，目的端口号）唯一标识。</li>
<li>TCP 套接字由四元组（源IP地址，源端口号，目的IP地址，目的端口号）唯一标识</li>
</ul>
<p>如果我们确定一台主机上打开了某个端口，也许就能知道该端口对应的进程。进而管理/攻击这个进程。</p>
<p><strong>传输层的多路复用与多路分解</strong></p>
<ul>
<li>多路复用：发送方从本机不同的套接字中收集数据块，并添加传输层首部（按照目的 IP 地址合并，合并后共享一个传输层首部）</li>
<li>多路分解：接收方将传输层报文段分段交付到正确的套接字</li>
</ul>
<h1 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h1><ul>
<li>UDP（User Datagram Protocol，用户数据报协议）<ul>
<li>无连接的。在进程通信前没有握手过程，自然也没有挥手过程。</li>
<li>面向报文。实际上的意思是，UDP 每个报文是独立的，不存在顺序关系（没有序号）</li>
<li>不可靠数据传输：到达的字节流可能乱序且不完整</li>
<li>没有流量控制和拥塞控制（不维护缓存窗口）</li>
</ul>
</li>
<li>TCP（Transmission Control Protocol，传输控制协议）<ul>
<li>面向连接。握手建立连接，挥手释放连接</li>
<li>全双工，可以 <strong>同时</strong> 进行报文的收发（报文段既包含发送的数据，又包含 ACK）</li>
<li>面向字节流（把应用层传下来的报文看成字节流，字节流被划分有<strong>有序号</strong>的报文段）</li>
<li>可靠数据传输：无差错（字节流顺序不变）、数据完整传输（不丢包）</li>
<li>流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<blockquote>
<p>UDP 相较于 TCP 的优点：</p>
<p>TCP 为了实现可靠数据传输，会带来额外的资源开销。</p>
<p>空间上，TCP 需要的首部字段更多，一个 TCP 报文段的有效载荷占比相对 UDP 来说更少；TCP 在连接建立和拆除的时候需要发额外的报文段</p>
<p>时间上，具体的时间消耗有，在连接建立和拆除的时候需要发额外的报文段，每次收发数据都要更新缓冲窗口、定时器，一旦检测到丢包会进行重传，这会导致时延</p>
</blockquote>
<h1 id="面向报文与面向字节流"><a href="#面向报文与面向字节流" class="headerlink" title="面向报文与面向字节流"></a>面向报文与面向字节流</h1><p>从概念上，面向报文指的是：UDP 每个报文是独立的，不存在顺序关系（没有序号），面向字节流指的是：TCP 把应用层传下来的报文看成字节流，字节流被划分有<strong>有序号</strong>的报文段。这里有两个重点：</p>
<ul>
<li>UDP 报文无序号字段，而 TCP 字节流有序号字段</li>
<li>缓冲区对 UDP 报文和 TCP 报文（字节流）有不同的处理方式</li>
</ul>
<h2 id="TCP-粘包"><a href="#TCP-粘包" class="headerlink" title="TCP 粘包"></a>TCP 粘包</h2><p><strong>发送端</strong>对于 TCP 报文为了优化传输效率，可能会使用 Nagle算法，将多次时间间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包（统一加首部）。（每一次尽量发送更多的数据，优化传输效率）。这样会导致多个数据连在一起，接收端难以将收到的 TCP 报文还原为原来的几个独立数据段。这就是 <strong>TCP 粘包现象</strong>。</p>
<ul>
<li><p>如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象。这种情况下，Nagle 优化了传输效率。</p>
</li>
<li><p>如果多个分组毫不相干，甚至是并列关系，那么<strong>这个时候就一定要处理粘包现象</strong>了。</p>
</li>
</ul>
<p>对于 UDP，每个报文是独立的，会独立添加首部字段并封包，因此接收端容易根据首部区分不同的报文段。假如有三个数据包，大小分别为 2k、4k、6k，如果采用 UDP 发送的话，不管发送方缓存有多大，我们必须要进行至少三次的发送才能把数据包发送完。</p>
<h2 id="TCP-粘包的处理方法"><a href="#TCP-粘包的处理方法" class="headerlink" title="TCP 粘包的处理方法"></a>TCP 粘包的处理方法</h2><p>发送方：对于发送方造成的粘包问题，可以通过关闭 Nagle 算法来解决。</p>
<p>接收方：接收方的传输层没有办法处理粘包现象，只能将问题交给<strong>应用层来处理</strong>。实际上，应用层解决 TCP 粘包的方法对发送方和接收方都进行了约束。</p>
<ul>
<li><p>一、格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要<strong>确保每条数据的内部不包含开始符和结束符</strong>。</p>
</li>
<li><p>二、发送数据长度：发送每条数据时，将数据的长度一并发送，<strong>例如规定数据的前4位是数据的长度</strong>，<strong>应用层</strong>（接收方）在处理时可以根据长度来判断每个分组的开始和结束位置。</p>
</li>
</ul>
<h1 id="UDP-和-TCP-的应用场景"><a href="#UDP-和-TCP-的应用场景" class="headerlink" title="UDP 和 TCP 的应用场景"></a>UDP 和 TCP 的应用场景</h1><p>TCP 用于有必要实现可靠传输的情况：FTP文件传输、HTTP / HTTPS</p>
<p>UDP 主要用于两种场景</p>
<ul>
<li>对高速传输和实时性有较高要求的场景，可以容忍一定的丢包率：通常是视频流的传输，例如网上会议、直播过程中传输的视频数据（文字、文件等数据仍需要 TCP）</li>
<li>短连接通信，如果业务只需要发一两个包，同时业务自己有简单的轮询或重复机制（编程额外加入，不属于UDP协议，可以检测丢包）。在这样的场景下，如果用 TCP，仅仅握手就需要3个包，这样显然有点不划算，一个典型的例子是 DNS 查询。</li>
</ul>
<p>DNS 为什么使用 UDP：需要传输的 DNS 报文段少，如果使用 TCP 需要的额外开销相比之下不划算</p>
<p>DNS 用 UDP 传输的缺点：无法传输大的报文段</p>
<blockquote>
<p>在早期的 DNS 协议中，MTU = 576，通过限制基于 UDP 的 DNS 报文段最大长度为 512 字节，避免生成的 IP 数据报大小超过 MTU</p>
<p>问题：512 字节是否包含 UDP 首部？即便不包含，512 + 20（UDP 报文段首部） + 20（IP 数据报首部） = 552 &lt; 576，并不等于 576</p>
</blockquote>
<p>DNS 为什么使用 TCP </p>
<ul>
<li><p>DNS 报文段超过 MTU，会造成数据的分片和丢失，需要依靠 TCP 进行可靠传输；</p>
</li>
<li><p>随着 DNS 报文段增大，TCP 协议头以及三次握手带来的额外开销比例逐渐降低，不再是占据总传输数据大小的主要部分；</p>
</li>
</ul>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="UDP-首部格式"><a href="#UDP-首部格式" class="headerlink" title="UDP 首部格式"></a>UDP 首部格式</h2><p>UDP 首部字段一共 8 个字节，包括：</p>
<ul>
<li>源端口号、目的端口号</li>
<li>长度：整个报文段的字节数（首部加数据）</li>
<li>校验和（checksum），2个字节</li>
</ul>
<p>实际使用时，添加了 12 个字节的伪首部字段。</p>
<p><img src="/2022/04/07/transport-layer/image-20220402105823002.png" alt="UDP 首部"></p>
<p>校验和（checksum）：用于差错检测，但是无法知道出错的字段是哪一个，也就是说检错的对象是整个报文段</p>
<p>校验和的发送和接收：</p>
<ul>
<li><p>发送方计算校验和：由于校验和大小是 2 个字节，即 16 比特，因此发送方将整个报文段看作 16bit 字的组合，对所有 16bit 字进行 求和、取反，求和时如果有溢出要回卷，得到 16 bit 大小的检验和字段</p>
<blockquote>
<p>所谓 “回卷” 就是当进行 16 比特的加法运算的时候，如果进位到 17位，则将第 17 位和后 16 位进行加法和运算。即当进位1，将其看作 0000 0000 0000 0001 ，并与低 16 位比特求和，若仍有进位，重复此回卷操作。</p>
</blockquote>
</li>
<li><p>接收方：将整个报文段求和（包括校验和字段），如果求和结果出现比特 0 ，则判断出现差错。</p>
<blockquote>
<p>有可能出现某个位，校验和出错（即 0 -&gt; 1 或者 1 -&gt; 0），且同时其他字的和在该位的结果也出错，这将导致报文段求和结果为0，无法检测出该错误。但是因为网络当中连续突发的错占绝大部分，这种跳跃性的出错概率很小，所以检验和的检错率还是比较高的。总之，在这里我们默认它足以完成差错检测任务</p>
</blockquote>
</li>
</ul>
<h2 id="UDP-报文段的大小限制"><a href="#UDP-报文段的大小限制" class="headerlink" title="UDP 报文段的大小限制"></a>UDP 报文段的大小限制</h2><blockquote>
<p>最大传输单元（Maximum Transmission Unit，MTU）是 <strong>链路层数据帧</strong> 中 <strong>有效载荷</strong> 的最大长度，一般以字节记。链路层数据帧中有效载荷就是 IP 数据报，所以 MTU 实际上就是 <strong>IP 数据报的长度限制</strong></p>
</blockquote>
<p>当我们发送的 UDP 报文段大于 MTU，则 IP 数据报也一定大于 MTU，这个时候发送方会采取分片（fragmentation），把 IP 数据报分成若干片，使每一片都 &lt;= MTU。这导致接收方网络层需要进行数据报的重组。</p>
<p>如果在传输过程中，某个分片丢失，则发送端需要重传整个 IP 数据报，不能单独传递某个分片。TCP 会重传，但是 UDP 则不会，网络层是没有重传机制的。因此，当某个分片丢失，接收方无法重组 UDP 数据报，会直接丢弃。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><p><img src="/2022/04/07/transport-layer/image-20220402105827330.png" alt="TCP 首部"></p>
<p><strong>序号、确认号</strong>：实现可靠数据传输服务。TCP是全双工的，主机既可以作为发送方又可以作为接收方，主机既有发送序号窗口又有接收序号窗口。</p>
<ul>
<li>序号 ：主机作为发送方时，用于对字节流进行编号，例如序号为 301，表示字节流第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li>
<li>确认号 ：主机作为接收方时，期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>
</ul>
<p><strong>确认 ACK</strong>：当 ACK=1 时确认号字段有效，否则无效。<strong>在连接建立后所有传送的报文段都必须把 ACK 置 1</strong>。</p>
<p><strong>同步 SYN</strong>：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
<p><strong>终止 FIN</strong>：用来释放一个连接，当 FIN=1 时，表示此报文段的<strong>发送方</strong>的数据已发送完毕，并要求释放连接。</p>
<p>复位 RST：当某一方的 TCP 连接出现异常时（例如主机崩溃），另一方每次向该方发送 TCP 报文段，该方都会回应一个 RST 包用于释放连接，另一方一旦收到 RST 报文段，就会释放 TCP 连接，不回应 ACK。<a href="https://zhuanlan.zhihu.com/p/361714600">TCP协议的RST标志位</a></p>
<p><strong>窗口</strong>：接收方愿意接收的字节数量，提供流量控制服务。</p>
<ul>
<li>指示发送方本接收方还有多少可用的缓存空间</li>
<li>全双工服务，TCP 连接两端都各自维护一个接收窗口</li>
</ul>
<p>数据偏移/首部长度 ：通常，选项字段为空时，对应 TCP 报文段首部长度为 20 字节</p>
<p>选项：该字段可选且变长，可用于最大报文段长度（MSS）协商过程</p>
<h2 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h2><p><img src="/2022/04/07/transport-layer/image-20220402105830978-16493810455143.png" alt="TCP 三次握手"></p>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文（SYN 报文），SYN=1，ACK=0，并随机选择一个初始的序号 x。（如果 ISN，Initial Sequence Number 是固定的，攻击者很容易猜出后续的确认号，那么就可以伪装成这个 TCP 连接中的报文段）</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文（SYNACK 报文），SYN=1，ACK=1，确认号为 x+1，同时也随机选择一个初始的序号 y。（不能单发 ACK，因为这样就是一个普通的确认报文，既发 SYN 又发 ACK，这样就知道是第二次握手的报文）</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，SYN=0，ACK=1，确认号为 y+1，序号为 x+1。这与一个普通的 ACK 报文没有区别，也可携带客户到服务器的应用层数据。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<blockquote>
<p>半连接队列</p>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN-RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下的 TCP 连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手的连接。</p>
<p>服务器发送完 SYNACK 报文后，如果未收到客户确认，服务器会进行重传，等待一段时间仍未收到客户确认，进行第二次重传，如果重传次数超过规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, …</p>
</blockquote>
<h3 id="进行三次握手的原因"><a href="#进行三次握手的原因" class="headerlink" title="进行三次握手的原因"></a>进行三次握手的原因</h3><p>主要有两个原因</p>
<ul>
<li>三次握手才能让双方均确认自己和对方的发送和接收能力都正常。传输数据的前提条件。<ul>
<li>第一次握手：服务端可以确认自己的接收能力和对方的发送能力正常；</li>
<li>第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</li>
<li>第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</li>
</ul>
</li>
</ul>
<p>服务端需要第三次握手来确认自己的发送能力和客户端的接收能力正常，。</p>
<blockquote>
<p>从另一个角度来解释第三次握手的意义。</p>
<p>第三次握手可以防止失效的连接请求到达服务器，让服务器错误打开连接。 </p>
<p>比如客户端 A 发出连接请求，可能因为网络阻塞原因，A 没有收到确认报文，于是在等待一个超时重传时间之后， A 再重传一次连接请求。连接成功，等待数据传输完毕后，就释放了连接。然后 A 发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时 B 误认为 A 又发出一次新的连接请求，于是就向 A 发出确认报文段。</p>
<p>如果不采用三次握手，只要 B 发出确认，就建立新的连接了，此时由于之前已经传输完了数据， A 不会响应 B 的确认报文且不发送数据，而 B 一直等待 A 发送数据，浪费资源。如果有第三次握手，只要客户端不响应服务器之后发送的对滞留连接请求的连接确认报文，不进行第三次握手，就不会再次打开连接。</p>
</blockquote>
<ul>
<li><p>告知对方自己的初始序号值，并且确认对方收到自己的初始序号。<strong>保证发送窗口和接收窗口在一开始是同步的</strong></p>
<ul>
<li>如果服务端没有收到发送端的 SYN 报文段（包含发送端的初始序号），发送端会重传 SYN 报文段，直到收到 ACK，表示服务端收到发送端的初始序号</li>
<li><p>如果发送端没有收到服务端 SYNACK 报文段（包含服务端端的初始序号），服务端会重传 SYNACK 报文段，直到收到 ACK</p>
<blockquote>
<p>在流水线可靠数据传输协议中，发送方的 send_base 和接收方的 rcv_base 一开始是相同的。因此，对于接收方来说，假如收到报文段的序号为 send_base+k，则它知道接收窗口对应的是 rcv_base+k 序号，于是可以维护接收窗口。如果 send_base 和 rcv_base 一开始不同步，也就是说接收方不知道 send_base 和 rcv_base 的差值，那么当接收方收到报文段的序号为 send_base+k，它就不清楚到底对应的是接收窗口的哪个序号。</p>
<p>TCP 两方都是接收方，因此都需要知道对方/发送方的初始序号，从而比较自己的接收窗口的 rcv_base，并实现窗口同步。例如 rcv_base = 1，并且知道 send_base = 5，则当收到序号为 8 的报文段，就知道对应接收窗口的序号为 4</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>三次握手已经实现了两个目的，不需要进行第四次握手</p>
<h3 id="SYN-洪范攻击"><a href="#SYN-洪范攻击" class="headerlink" title="SYN 洪范攻击"></a>SYN 洪范攻击</h3><p>在基本的三次握手过程中，服务器第一次收到客户端的 SYN 之后，就会生成 TCP 半连接（分配资源）。攻击者通过发送大量的 SYN 报文段，而不完成第三次握手，导致服务器不断分配无用的资源。</p>
<p>如果攻击者完成第三次握手，那么相当于他自己的资源换服务器的资源，并且实际上它的行为与正常客户一样</p>
<p>应对方法：Syn Cookie 技术</p>
<ol>
<li>服务器接收到一个 SYN 报文段时，不分配资源/不生成一个半开连接</li>
<li>服务器随机生成一个序号，该序号由源、目的 IP 地址和端口号 hash 得到（即每个 SYN 报文段唯一对应一个 server_isn），并作为 SYNACK 的序号 y。</li>
<li>如果客户是合法的，它将返回一个 ACK 报文段，且确认号为 y+1，如果确认号-1 = 源、目的ip地址和端口号的 hash 值，服务器认为该 ACK 对应于之前的一个 SYN 报文段，生成一个具有套接字的全开连接</li>
</ol>
<h3 id="三次握手中的丢包处理"><a href="#三次握手中的丢包处理" class="headerlink" title="三次握手中的丢包处理"></a>三次握手中的丢包处理</h3><p><strong>三次握手连接阶段，最后一次 ACK 包丢失，会发生什么？</strong></p>
<p>服务器发送完 SYNACK 报文后，如果未收到客户确认，服务器会进行重传，等待一段时间仍未收到客户确认，进行第二次重传，如果重传次数超过规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, …</p>
<p>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以 RST 包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。</p>
<p><strong>如果已经建立了连接，但是客户端出现故障了怎么办？</strong></p>
<p>服务端采用定时器 + 超时重试机制，尝试获取确认，直到最后会自动断开连接。</p>
<p>具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据（正常情况下，服务器不会主动向客户端发送数据），服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。</p>
<h2 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h2><p><img src="/2022/04/07/transport-layer/image-20220402105835868.png" alt="TCP 四次挥手"></p>
<p>以下描述不讨论序号、确认号和 ACK，因为在连接建立之后，ACK=1，序号和确认号按照规则自然生成。</p>
<ul>
<li>TCP 连接由客户率先释放。A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<h3 id="为什么是四次挥手"><a href="#为什么是四次挥手" class="headerlink" title="为什么是四次挥手"></a>为什么是四次挥手</h3><p>客户端确定不再需要发送数据时，才会发送 FIN 报文，表示单方面的连接释放，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器确定不再需要发送数据，才会发送 FIN 报文。之后两边才会真正的断开连接。故需要四次挥手。</p>
<h3 id="TIME-WAIT-状态"><a href="#TIME-WAIT-状态" class="headerlink" title="TIME_WAIT 状态"></a>TIME_WAIT 状态</h3><p><strong>需要 TIME_WAIT 状态的原因</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li><p>当服务器没有收到客户的 ACK 报文，保证客户端能收到服务端重传的 FIN 报文，然后客户端会重传 ACK 报文。</p>
<blockquote>
<p>MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL + 服务端 FIN 报文 1MSL」，就能够收到服务端重传的 FIN 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。</p>
</blockquote>
</li>
<li><p>防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</p>
</li>
</ul>
<p><strong>处于 TIME_WAIT 状态的 socket 过多会产生什么后果，怎么处理</strong></p>
<p>场景：</p>
<p>服务端：按照一般的四次挥手过程，TIME_WAIT 是客户端的状态，服务端一般不主动关闭连接。但在部分场景中，当服务端处理完请求会主动关闭 TCP 连接。</p>
<p>在高并发短连接的 TCP 服务器上，当服务器处理完请求后立刻主动关闭连接。这个场景下会出现服务器大量 socket 处于 TIME_WAIT 状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p>
<ul>
<li>高并发会导致服务器在短时间内被占用大量端口，而端口的范围是 0~65535（16 比特），服务器因端口资源不足会拒绝为一部分客户服务。</li>
<li>短连接表示“业务处理+传输数据的时间远远小于 TIMEWAIT 等待的时间，是一个相对时长的概念。并不是 TCP 短连接和 TCP 长连接的意思</li>
</ul>
<p>长连接业务的服务不需要考虑 TIMEWAIT 状态，因为相较于服务消耗的时间，TIMEWAIT 的时间又不算什么了。并且，在实际业务场景中，一般长连接对应的业务的并发量并不会很高。</p>
<blockquote>
<p>HTTP 首部的 Connection 字段</p>
<p>Connection: keep-alive，开启HTTP持久连接（长连接），HTTP 1.1 默认值，服务端处理完请求后不会主动关闭 TCP 连接</p>
<p>Connection: close，关闭HTTP持久连接（短连接），HTTP 1.0 默认值，服务端处理完请求后会主动关闭 TCP 连接</p>
</blockquote>
<p>解决办法：</p>
<ul>
<li>服务器可以设置 SO_REUSEADDR 套接字选项。这个套接字选项通知内核，如果端口忙，但 TCP 状态处于TIME_WAIT，可以重用端口。</li>
<li>打开系统的 TIMEWAIT 重用和快速回收。编辑内核文件 /etc/sysctl.conf 文件，加入以下内容<ul>
<li>net.ipv4.tcp_tw_reuse =1 表示开启重用。允许将 TIME-WAIT sockets 重新用于新的TCP连接，默认为0，表示关闭；</li>
<li>net.ipv4.tcp_tw_recycle =1 表示开启TCP连接中 TIME-WAIT sockets 的快速回收，默认为0，表示关闭。</li>
</ul>
</li>
</ul>
<p><strong>TIME_WAIT 状态能够保证 TCP 传输的可靠性，当服务器大量 socket 处于 TIME_WAIT 状态，首先考虑的应该是分布式服务器，对抗高并发，而不是让一台服务器用自己的方法关闭处于 TIME_WAIT 状态的 socket</strong></p>
<h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><p>流量控制：控制发送方发送速率，保证接收方来得及接收。</p>
<p><strong>接收方发送的</strong>确认报文中的窗口字段，可以用来控制发送方窗口大小，从而控制发送方的发送速率。</p>
<p>设主机 A 维护一个变量 rwnd，表示主机 A 作为接收方还有多大的缓存空间。主机 A 把 rwnd 值放入它发给主机 B 的报文段窗口字段。</p>
<p>考虑这样一种情况：</p>
<ul>
<li>假设主机 A 在时刻 T 之前接收缓存已满，即 rwnd = 0，并且告知了主机 B，这导致主机 B 不会向主机 A 发送数据。</li>
<li>假设在时刻 T，主机 A 的接收缓存又有空间了，但此时主机 A 没有数据要发给主机 B。由于主机 A 没有数据要发给主机 B，这导致主机 A 就不会向主机 B 发送带有 rwnd 新值的报文段。从而导致主机 B 无法正常地继续向主机 A 发送数据</li>
<li>为了解决这个问题，TCP 规范中要求：当主机 A 的 rwnd = 0 时，主机 B 继续不断发送只有一个字节数据的报文段，这些报文段会被主机 A 确认，确认报文段中带有 rwnd 的新值</li>
</ul>
<blockquote>
<p>UDP 并不提供流量控制。考虑主机 A 的一个进程向主机 B 的一个进程发送 UDP 报文段。UDP 会把报文段添加到套接字之前的一个有限大小的缓存中，主机 B 的进程每次从缓存中读取一个报文段，如果读取速度不够快，缓存溢出，报文段丢失。</p>
</blockquote>
<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。</p>
<p>流量控制：接收方接收能力有限导致丢包；</p>
<p>拥塞控制：网络拥塞导致丢包，要降低接入网络的发送方的传输速率，减少丢包</p>
<p><img src="/2022/04/07/transport-layer/1646125033652-f2cee9eb-09ce-43b9-87d1-2068cb65824d.jpeg" alt="拥塞控制比较"></p>
<h3 id="TCP-拥塞控制算法"><a href="#TCP-拥塞控制算法" class="headerlink" title="TCP 拥塞控制算法"></a>TCP 拥塞控制算法</h3><p>发送方维护变量：拥塞窗口 cwnd（congestion window），以 cwnd 作为发送窗口大小。一开始，使用慢开始算法，当 cwnd 达到 ssthresh 时，改用拥塞避免算法</p>
<ul>
<li><p>慢开始 （slow-start）：拥塞窗口按<strong>指数</strong>规律缓慢增长。即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加倍</p>
</li>
<li><p>拥塞避免 （congestion avoidance）：拥塞窗口按<strong>线性</strong>规律缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加1。</p>
</li>
<li><p>快重传 （fast retransmit）：我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。</p>
<p>  比如接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。</p>
<blockquote>
<p>流水线可靠数据传输协议是这样做的，但是由于 TCP 是全双工的，因此接收端可以同时传输数据分组（数据和序号）和 ACK 分组（ACK 和确认号）。于是接收端可以选择是否要等上层数据来才反馈数据和ACK</p>
</blockquote>
<p>  发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
</li>
<li><p>快速恢复 （fast recovery）：主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 减半，但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。<br>  <img src="/2022/04/07/transport-layer/1648560147086-bf65391a-049e-44a9-b2bb-ccb08f80e83e.png" alt="cwnd 随传输轮次的变化过程。">图中，传输轮次变化 1 表示经过一个往返时间 RTT（1 轮即1报文段的一个来回，例如发送方发分组到接收方，接收方发 ACK 到发送方</p>
</li>
</ul>
<h2 id="TCP-可靠数据传输"><a href="#TCP-可靠数据传输" class="headerlink" title="TCP 可靠数据传输"></a>TCP 可靠数据传输</h2><p><strong>基本机制</strong>：</p>
<ol>
<li>检验和</li>
<li>序号和确认号：根据确认号，发送方判断是否重传，根据序号，接收方判断是否按序接收</li>
<li>滑动窗口：既用于实现可靠数据传输，又可以通过改变窗口大小实现流量控制和拥塞控制</li>
<li>超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间 RTT，如果超过了这个时间会被<br> 认为是丢包了，需要重传。最大超时时间是动态计算的。</li>
<li>流量控制：接收方接收能力有限（接收缓冲区不足）导致丢包</li>
<li>拥塞控制：网络拥塞导致丢包，要降低接入网络的发送方的传输速率，减少丢包</li>
</ol>
<p><strong>具体实现方式</strong>：GBN、SR</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
</search>

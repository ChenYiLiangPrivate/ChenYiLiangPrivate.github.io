<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="传输层传输层提供了进程间的逻辑通信">
<meta property="og:type" content="article">
<meta property="og:title" content="传输层">
<meta property="og:url" content="http://example.com/2022/04/07/transport-layer/index.html">
<meta property="og:site_name" content="缘溪行">
<meta property="og:description" content="传输层传输层提供了进程间的逻辑通信">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/image-20220402105823002.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/image-20220402105827330.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/image-20220402105830978-16493810455143.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/image-20220402105835868.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1646125033652-f2cee9eb-09ce-43b9-87d1-2068cb65824d.jpeg">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1648560147086-bf65391a-049e-44a9-b2bb-ccb08f80e83e.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1647264249043-2355ea05-3c85-48db-831d-d71bd6f9f480-16493429072551-16493811925277.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1647264538997-4e356760-a14c-4d0e-90ac-372dedcf20a1-16493429072612-16493812001439.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1647265748305-e77c3ba4-856e-45a9-be13-3a1aff420614.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1647265771972-bbae444e-4cec-4133-9431-08b7730102c3.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1647267039580-ffcd28d7-2f6e-4612-92e2-d64d24c10057-16493429072623.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1647267415807-5656ac65-9ab6-495a-ad99-43d7d2e60e16.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1647267039580-ffcd28d7-2f6e-4612-92e2-d64d24c10057.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1648559215136-0532653f-1536-43e4-8f9a-a65e32c8b7dd-16493429072624.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1648559215290-9e8dccff-ae82-435b-9ef7-a01ce588bee0-16493429072625.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1641715373288-1bffa27c-c45d-44ee-a971-9f57bb9aa4c4-16493429072626.png">
<meta property="og:image" content="http://example.com/2022/04/07/transport-layer/1641715247816-3e91619a-488b-4b8e-89e1-d512dd2fcaea-16493429072627.png">
<meta property="article:published_time" content="2022-04-07T14:45:28.000Z">
<meta property="article:modified_time" content="2022-04-08T08:12:35.505Z">
<meta property="article:author" content="Cyl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/07/transport-layer/image-20220402105823002.png">

<link rel="canonical" href="http://example.com/2022/04/07/transport-layer/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>传输层 | 缘溪行</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">缘溪行</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">13</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/07/transport-layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          传输层
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-07 22:45:28" itemprop="dateCreated datePublished" datetime="2022-04-07T22:45:28+08:00">2022-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-08 16:12:35" itemprop="dateModified" datetime="2022-04-08T16:12:35+08:00">2022-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层提供了进程间的逻辑通信</p>
<span id="more"></span>

<p>套接字的唯一标识符</p>
<ul>
<li>端口号存在于 UDP&#x2F;TCP 报文段的首部当中，IP 地址存在于网络层首部</li>
<li>UDP 套接字由二元组（目的IP地址，目的端口号）唯一标识。</li>
<li>TCP 套接字由四元组（源IP地址，源端口号，目的IP地址，目的端口号）唯一标识</li>
</ul>
<p>如果我们确定一台主机上打开了某个端口，也许就能知道该端口对应的进程。进而管理&#x2F;攻击这个进程。</p>
<p><strong>传输层的多路复用与多路分解</strong></p>
<ul>
<li>多路复用：发送方从本机不同的套接字中收集数据块，并添加传输层首部（按照目的 IP 地址合并，合并后共享一个传输层首部）</li>
<li>多路分解：接收方将传输层报文段分段交付到正确的套接字</li>
</ul>
<h2 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h2><ul>
<li>UDP（User Datagram Protocol，用户数据报协议）<ul>
<li>无连接的。在进程通信前没有握手过程，自然也没有挥手过程。</li>
<li>面向报文。实际上的意思是，UDP 每个报文是独立的，不存在顺序关系（没有序号）</li>
<li>不可靠数据传输：到达的字节流可能乱序且不完整</li>
<li>没有流量控制和拥塞控制（不维护缓存窗口）</li>
</ul>
</li>
<li>TCP（Transmission Control Protocol，传输控制协议）<ul>
<li>面向连接。握手建立连接，挥手释放连接</li>
<li>全双工，可以 <strong>同时</strong> 进行报文的收发（报文段既包含发送的数据，又包含 ACK）</li>
<li>面向字节流（把应用层传下来的报文看成字节流，字节流被划分有<strong>有序号</strong>的报文段）</li>
<li>可靠数据传输：无差错（字节流顺序不变）、数据完整传输（不丢包）</li>
<li>流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<blockquote>
<p>UDP 相较于 TCP 的优点：</p>
<p>TCP 为了实现可靠数据传输，会带来额外的资源开销。</p>
<p>空间上，TCP 需要的首部字段更多，一个 TCP 报文段的有效载荷占比相对 UDP 来说更少；TCP 在连接建立和拆除的时候需要发额外的报文段</p>
<p>时间上，具体的时间消耗有，在连接建立和拆除的时候需要发额外的报文段，每次收发数据都要更新缓冲窗口、定时器，一旦检测到丢包会进行重传，这会导致时延</p>
</blockquote>
<h2 id="UDP-和-TCP-的应用场景"><a href="#UDP-和-TCP-的应用场景" class="headerlink" title="UDP 和 TCP 的应用场景"></a>UDP 和 TCP 的应用场景</h2><p>TCP 用于有必要实现可靠传输的情况：FTP文件传输、HTTP &#x2F; HTTPS</p>
<p>UDP 主要用于两种场景</p>
<ul>
<li>对高速传输和实时性有较高要求的场景，可以容忍一定的丢包率：网上会议、直播</li>
<li>短连接通信，如果业务只需要发一两个包，同时业务自己有简单的轮询或重复机制（编程额外加入，不属于UDP协议，可以检测丢包）。在这样的场景下，如果用 TCP，仅仅握手就需要3个包，这样显然有点不划算，一个典型的例子是 DNS 查询。</li>
</ul>
<p>DNS 为什么使用 UDP：需要传输的 DNS 报文段少，如果使用 TCP 需要的额外开销相比之下不划算</p>
<p>DNS 用 UDP 传输的缺点：无法传输大的报文段</p>
<blockquote>
<p>在早期的 DNS 协议中，MTU &#x3D; 576，通过限制基于 UDP 的 DNS 报文段最大长度为 512 字节，避免生成的 IP 数据报大小超过 MTU</p>
<p>问题：512 字节是否包含 UDP 首部？即便不包含，512 + 20（UDP 报文段首部） + 20（IP 数据报首部） &#x3D; 552 &lt; 576，并不等于 576</p>
</blockquote>
<p>DNS 为什么使用 TCP </p>
<ul>
<li><p>DNS 报文段超过 MTU，会造成数据的分片和丢失，需要依靠 TCP 进行可靠传输；</p>
</li>
<li><p>随着 DNS 报文段增大，TCP 协议头以及三次握手带来的额外开销比例逐渐降低，不再是占据总传输数据大小的主要部分；</p>
</li>
</ul>
<h2 id="UDP-首部格式"><a href="#UDP-首部格式" class="headerlink" title="UDP 首部格式"></a>UDP 首部格式</h2><p>UDP 首部字段一共 8 个字节，包括：</p>
<ul>
<li>源端口号、目的端口号</li>
<li>长度：整个报文段的字节数（首部加数据）</li>
<li>校验和（checksum），2个字节</li>
</ul>
<p>实际使用时，添加了 12 个字节的伪首部字段。</p>
<p><img src="/2022/04/07/transport-layer/image-20220402105823002.png" alt="UDP 首部"></p>
<p>校验和（checksum）：用于差错检测，但是无法知道出错的字段是哪一个，也就是说检错的对象是整个报文段</p>
<p>校验和的发送和接收：</p>
<ul>
<li><p>发送方计算校验和：由于校验和大小是 2 个字节，即 16 比特，因此发送方将整个报文段看作 16bit 字的组合，对所有 16bit 字进行 求和、取反，求和时如果有溢出要回卷，得到 16 bit 大小的检验和字段</p>
<blockquote>
<p>所谓 “回卷” 就是当进行 16 比特的加法运算的时候，如果进位到 17位，则将第 17 位和后 16 位进行加法和运算。即当进位1，将其看作 0000 0000 0000 0001 ，并与低 16 位比特求和，若仍有进位，重复此回卷操作。</p>
</blockquote>
</li>
<li><p>接收方：将整个报文段求和（包括校验和字段），如果求和结果出现比特 0 ，则判断出现差错。</p>
<blockquote>
<p>有可能出现某个位，校验和出错（即 0 -&gt; 1 或者 1 -&gt; 0），且同时其他字的和在该位的结果也出错，这将导致报文段求和结果为0，无法检测出该错误。但是因为网络当中连续突发的错占绝大部分，这种跳跃性的出错概率很小，所以检验和的检错率还是比较高的。总之，在这里我们默认它足以完成差错检测任务</p>
</blockquote>
</li>
</ul>
<p><strong>UDP 报文段的大小限制</strong></p>
<blockquote>
<p>最大传输单元（Maximum Transmission Unit，MTU）是 <strong>链路层数据帧</strong> 中 <strong>有效载荷</strong> 的最大长度，一般以字节记。链路层数据帧中有效载荷就是 IP 数据报，所以 MTU 实际上就是 <strong>IP 数据报的长度限制</strong></p>
</blockquote>
<p>当我们发送的 UDP 报文段大于 MTU，则 IP 数据报也一定大于 MTU，这个时候发送方会采取分片（fragmentation），把 IP 数据报分成若干片，使每一片都 &lt;&#x3D; MTU。这导致接收方网络层需要进行数据报的重组。</p>
<p>如果在传输过程中，某个分片丢失，则发送端需要重传整个 IP 数据报，不能单独传递某个分片。TCP 会重传，但是 UDP 则不会，网络层是没有重传机制的。因此，当某个分片丢失，接收方无法重组 UDP 数据报，会直接丢弃。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h3><p><img src="/2022/04/07/transport-layer/image-20220402105827330.png" alt="TCP 首部"></p>
<p><strong>序号、确认号</strong>：实现可靠数据传输服务。TCP是全双工的，主机既可以作为发送方又可以作为接收方，主机既有发送序号窗口又有接收序号窗口。</p>
<ul>
<li>序号 ：主机作为发送方时，用于对字节流进行编号，例如序号为 301，表示字节流第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li>
<li>确认号 ：主机作为接收方时，期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>
</ul>
<p><strong>确认 ACK</strong>：当 ACK&#x3D;1 时确认号字段有效，否则无效。<strong>在连接建立后所有传送的报文段都必须把 ACK 置 1</strong>。</p>
<p><strong>同步 SYN</strong>：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1。</p>
<p><strong>终止 FIN</strong>：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的<strong>发送方</strong>的数据已发送完毕，并要求释放连接。</p>
<p><strong>窗口</strong>：接收方愿意接收的字节数量，提供流量控制服务。</p>
<ul>
<li>指示发送方本接收方还有多少可用的缓存空间</li>
<li>全双工服务，TCP 连接两端都各自维护一个接收窗口</li>
</ul>
<p>数据偏移&#x2F;首部长度 ：通常，选项字段为空时，对应 TCP 报文段首部长度为 20 字节</p>
<p>选项：该字段可选且变长，可用于最大报文段长度（MSS）协商过程</p>
<h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p><img src="/2022/04/07/transport-layer/image-20220402105830978-16493810455143.png" alt="TCP 三次握手"></p>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文（SYN 报文），SYN&#x3D;1，ACK&#x3D;0，并随机选择一个初始的序号 x。（如果 ISN，Initial Sequence Number 是固定的，攻击者很容易猜出后续的确认号，那么就可以伪装成这个 TCP 连接中的报文段）</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文（SYNACK 报文），SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也随机选择一个初始的序号 y。（不能单发 ACK，因为这样就是一个普通的确认报文，既发 SYN 又发 ACK，这样就知道是第二次握手的报文）</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，SYN&#x3D;0，ACK&#x3D;1，确认号为 y+1，序号为 x+1。这与一个普通的 ACK 报文没有区别，也可携带客户到服务器的应用层数据。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<blockquote>
<p>半连接队列</p>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN-RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下的 TCP 连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手的连接。</p>
<p>服务器发送完 SYNACK 报文后，如果未收到客户确认，服务器会进行重传，等待一段时间仍未收到客户确认，进行第二次重传，如果重传次数超过规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, …</p>
</blockquote>
<h4 id="进行三次握手的原因"><a href="#进行三次握手的原因" class="headerlink" title="进行三次握手的原因"></a>进行三次握手的原因</h4><p>主要有两个原因</p>
<ul>
<li>三次握手才能让双方均确认自己和对方的发送和接收能力都正常。传输数据的前提条件。<ul>
<li>第一次握手：服务端可以确认自己的接收能力和对方的发送能力正常；</li>
<li>第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</li>
<li>第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</li>
</ul>
</li>
</ul>
<p>服务端需要第三次握手来确认自己的发送能力和客户端的接收能力正常，。</p>
<blockquote>
<p>从另一个角度来解释第三次握手的意义。</p>
<p>第三次握手可以防止失效的连接请求到达服务器，让服务器错误打开连接。 </p>
<p>比如客户端 A 发出连接请求，可能因为网络阻塞原因，A 没有收到确认报文，于是在等待一个超时重传时间之后， A 再重传一次连接请求。连接成功，等待数据传输完毕后，就释放了连接。然后 A 发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时 B 误认为 A 又发出一次新的连接请求，于是就向 A 发出确认报文段。</p>
<p>如果不采用三次握手，只要 B 发出确认，就建立新的连接了，此时由于之前已经传输完了数据， A 不会响应 B 的确认报文且不发送数据，而 B 一直等待 A 发送数据，浪费资源。如果有第三次握手，只要客户端不响应服务器之后发送的对滞留连接请求的连接确认报文，不进行第三次握手，就不会再次打开连接。</p>
</blockquote>
<ul>
<li><p>告知对方自己的初始序号值，并且确认对方收到自己的初始序号。<strong>保证发送窗口和接收窗口在一开始是同步的</strong></p>
<ul>
<li>如果服务端没有收到发送端的 SYN 报文段（包含发送端的初始序号），发送端会重传 SYN 报文段，直到收到 ACK，表示服务端收到发送端的初始序号</li>
<li>如果发送端没有收到服务端 SYNACK 报文段（包含服务端端的初始序号），服务端会重传 SYNACK 报文段，直到收到 ACK</li>
</ul>
<p>  A 的初始序号即 A 的发送窗口一开始的 send_base，B 需要知道 A 的初始序号，因为它需要维护的接收窗口一开始的 rcv_base 应该等于 send_base，即<strong>保证发送窗口和接收窗口在一开始是同步的</strong></p>
</li>
</ul>
<p>三次握手已经实现了两个目的，不需要进行第四次握手</p>
<h4 id="SYN-洪范攻击"><a href="#SYN-洪范攻击" class="headerlink" title="SYN 洪范攻击"></a>SYN 洪范攻击</h4><p>在基本的三次握手过程中，服务器第一次收到客户端的 SYN 之后，就会生成 TCP 半连接（分配资源）。攻击者通过发送大量的 SYN 报文段，而不完成第三次握手，导致服务器不断分配无用的资源。</p>
<p>如果攻击者完成第三次握手，那么相当于他自己的资源换服务器的资源，并且实际上它的行为与正常客户一样</p>
<p>应对方法：Syn Cookie 技术</p>
<ol>
<li>服务器接收到一个 SYN 报文段时，不分配资源&#x2F;不生成一个半开连接</li>
<li>服务器随机生成一个序号，该序号由源、目的 IP 地址和端口号 hash 得到（即每个 SYN 报文段唯一对应一个 server_isn），并作为 SYNACK 的序号 y。</li>
<li>如果客户是合法的，它将返回一个 ACK 报文段，且确认号为 y+1，如果确认号-1 &#x3D; 源、目的ip地址和端口号的 hash 值，服务器认为该 ACK 对应于之前的一个 SYN 报文段，生成一个具有套接字的全开连接</li>
</ol>
<h4 id="三次握手中的丢包处理"><a href="#三次握手中的丢包处理" class="headerlink" title="三次握手中的丢包处理"></a>三次握手中的丢包处理</h4><p><strong>三次握手连接阶段，最后一次 ACK 包丢失，会发生什么？</strong></p>
<p>服务器发送完 SYNACK 报文后，如果未收到客户确认，服务器会进行重传，等待一段时间仍未收到客户确认，进行第二次重传，如果重传次数超过规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, …</p>
<p>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以 RST 包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。</p>
<p><strong>如果已经建立了连接，但是客户端出现故障了怎么办？</strong></p>
<p>服务端采用定时器 + 超时重试机制，尝试获取确认，直到最后会自动断开连接。</p>
<p>具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据（正常情况下，服务器不会主动向客户端发送数据），服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。</p>
<h3 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h3><p><img src="/2022/04/07/transport-layer/image-20220402105835868.png" alt="TCP 四次挥手"></p>
<p>以下描述不讨论序号、确认号和 ACK，因为在连接建立之后，ACK&#x3D;1，序号和确认号按照规则自然生成。</p>
<ul>
<li>TCP 连接由客户率先释放。A 发送连接释放报文，FIN&#x3D;1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN&#x3D;1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<h4 id="为什么是四次挥手"><a href="#为什么是四次挥手" class="headerlink" title="为什么是四次挥手"></a>为什么是四次挥手</h4><p>客户端确定不再需要发送数据时，才会发送 FIN 报文，表示单方面的连接释放，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器确定不再需要发送数据，才会发送 FIN 报文。之后两边才会真正的断开连接。故需要四次挥手。</p>
<h4 id="TIME-WAIT-状态"><a href="#TIME-WAIT-状态" class="headerlink" title="TIME_WAIT 状态"></a>TIME_WAIT 状态</h4><p><strong>需要 TIME_WAIT 状态的原因</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li><p>当服务器没有收到客户的 ACK 报文，保证客户端能收到服务端重传的 FIN 报文，然后客户端会重传 ACK 报文。</p>
<blockquote>
<p>MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL + 服务端 FIN 报文 1MSL」，就能够收到服务端重传的 FIN 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。</p>
</blockquote>
</li>
<li><p>防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</p>
</li>
</ul>
<p><strong>处于 TIME_WAIT 状态的 socket 过多会产生什么后果，怎么处理</strong></p>
<p>场景：</p>
<p>服务端：按照一般的四次挥手过程，TIME_WAIT 是客户端的状态，服务端一般不主动关闭连接。但在部分场景中，当服务端处理完请求会主动关闭 TCP 连接。</p>
<p>在高并发短连接的 TCP 服务器上，当服务器处理完请求后立刻主动关闭连接。这个场景下会出现服务器大量 socket 处于 TIME_WAIT 状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p>
<ul>
<li>高并发会导致服务器在短时间内被占用大量端口，而端口的范围是 0~65535（16 比特），服务器因端口资源不足会拒绝为一部分客户服务。</li>
<li>短连接表示“业务处理+传输数据的时间远远小于 TIMEWAIT 等待的时间，是一个相对时长的概念。并不是 TCP 短连接和 TCP 长连接的意思</li>
</ul>
<p>长连接业务的服务不需要考虑 TIMEWAIT 状态，因为相较于服务消耗的时间，TIMEWAIT 的时间又不算什么了。并且，在实际业务场景中，一般长连接对应的业务的并发量并不会很高。</p>
<blockquote>
<p>HTTP 首部的 Connection 字段</p>
<p>Connection: keep-alive，开启HTTP持久连接（长连接），HTTP 1.1 默认值，服务端处理完请求后不会主动关闭 TCP 连接</p>
<p>Connection: close，关闭HTTP持久连接（短连接），HTTP 1.0 默认值，服务端处理完请求后会主动关闭 TCP 连接</p>
</blockquote>
<p>解决办法：</p>
<ul>
<li>服务器可以设置 SO_REUSEADDR 套接字选项。这个套接字选项通知内核，如果端口忙，但 TCP 状态处于TIME_WAIT，可以重用端口。</li>
<li>打开系统的 TIMEWAIT 重用和快速回收。编辑内核文件 &#x2F;etc&#x2F;sysctl.conf 文件，加入以下内容<ul>
<li>net.ipv4.tcp_tw_reuse &#x3D;1 表示开启重用。允许将 TIME-WAIT sockets 重新用于新的TCP连接，默认为0，表示关闭；</li>
<li>net.ipv4.tcp_tw_recycle &#x3D;1 表示开启TCP连接中 TIME-WAIT sockets 的快速回收，默认为0，表示关闭。</li>
</ul>
</li>
</ul>
<p><strong>TIME_WAIT 状态能够保证 TCP 传输的可靠性，当服务器大量 socket 处于 TIME_WAIT 状态，首先考虑的应该是分布式服务器，对抗高并发，而不是让一台服务器用自己的方法关闭处于 TIME_WAIT 状态的 socket</strong></p>
<h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>流量控制：控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而控制发送方的发送速率。</p>
<h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。</p>
<p>流量控制：接收方接收能力有限，不考虑整个网络；</p>
<p>拥塞控制：网络已经拥塞，要降低接入网络的发送方的传输速率，减少丢包</p>
<p><img src="/2022/04/07/transport-layer/1646125033652-f2cee9eb-09ce-43b9-87d1-2068cb65824d.jpeg" alt="拥塞控制比较"></p>
<h4 id="TCP-拥塞控制算法"><a href="#TCP-拥塞控制算法" class="headerlink" title="TCP 拥塞控制算法"></a>TCP 拥塞控制算法</h4><p>发送方维护变量：拥塞窗口 cwnd（congestion window），以 cwnd 作为发送窗口大小。一开始，使用慢开始算法，当 cwnd 达到 ssthresh 时，改用拥塞避免算法</p>
<ul>
<li><p>慢开始 （slow-start）：拥塞窗口按<strong>指数</strong>规律缓慢增长。即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加倍</p>
</li>
<li><p>拥塞避免 （congestion avoidance）：拥塞窗口按<strong>线性</strong>规律缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加1。</p>
</li>
<li><p>快重传 （fast retransmit）：我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。</p>
<p>  比如接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。</p>
<blockquote>
<p>流水线可靠数据传输协议是这样做的，但是由于 TCP 是全双工的，因此接收端可以同时传输数据分组（数据和序号）和 ACK 分组（ACK 和确认号）。于是接收端可以选择是否要等上层数据来才反馈数据和ACK</p>
</blockquote>
<p>  发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
</li>
<li><p>快速恢复 （fast recovery）：主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 减半，但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。<br>  <img src="/2022/04/07/transport-layer/1648560147086-bf65391a-049e-44a9-b2bb-ccb08f80e83e.png" alt="cwnd 随传输轮次的变化过程。">图中，传输轮次变化 1 表示经过一个往返时间 RTT（1 轮即1报文段的一个来回，例如发送方发分组到接收方，接收方发 ACK 到发送方</p>
</li>
</ul>
<h3 id="TCP-可靠数据传输"><a href="#TCP-可靠数据传输" class="headerlink" title="TCP 可靠数据传输"></a>TCP 可靠数据传输</h3><p><strong>基本机制</strong>：</p>
<ol>
<li>检验和</li>
<li>序号和确认号：根据确认号，发送方判断是否重传，根据序号，接收方判断是否按序接收</li>
<li>滑动窗口：既用于实现可靠数据传输，又可以通过改变窗口大小实现流量控制和拥塞控制</li>
<li>超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间 RTT，如果超过了这个时间会被<br> 认为是丢包了，需要重传。最大超时时间是动态计算的。</li>
<li>流量控制：接收方接收能力有限（接收缓冲区不足）</li>
<li>拥塞控制：网络已经拥塞，要降低接入网络的发送方的传输速率，减少丢包</li>
</ol>
<p><strong>具体实现方式</strong>：GBN、SR</p>
<h1 id="可靠数据传输-x2F-rdt-协议"><a href="#可靠数据传输-x2F-rdt-协议" class="headerlink" title="可靠数据传输&#x2F;rdt 协议"></a>可靠数据传输&#x2F;rdt 协议</h1><h2 id="rdt-2-x-协议"><a href="#rdt-2-x-协议" class="headerlink" title="rdt 2.x 协议"></a>rdt 2.x 协议</h2><p><strong>信道有差错、无丢包。</strong></p>
<h3 id="rdt-2-0-协议"><a href="#rdt-2-0-协议" class="headerlink" title="rdt 2.0 协议"></a>rdt 2.0 协议</h3><img src="/2022/04/07/transport-layer/1647264249043-2355ea05-3c85-48db-831d-d71bd6f9f480-16493429072551-16493811925277.png" alt="rdt2.0 发送端" style="zoom: 80%;">

<img src="/2022/04/07/transport-layer/1647264538997-4e356760-a14c-4d0e-90ac-372dedcf20a1-16493429072612-16493812001439.png" alt="rdt2.0 接收端" style="zoom: 80%;">

<p><strong>发送端</strong>：发送数据后，处于等待 ACK&#x2F;NAK 的状态，若收到 NAK，<strong>重传报文并且继续等待</strong>；若收到 ACK，回到初始状态，等待发送数据。</p>
<p><strong>接收端</strong>：若接收到的数据有损（根据校验和判断），发送 NAK 给发送端；若接收到的数据无损，传送至上层并发送 ACK 给发送端。</p>
<p><strong>存在的问题</strong>：对于发送端，收到的 ACK&#x2F;NAK 可能是有损的，而状态图并没有考虑到这种情况。</p>
<p><strong>情况分析</strong>：当发送端收到有损的 ACK&#x2F;NAK 报文，它无法判断发送的数据是否被接收方正确接收（因为可能是 NAK 报文受损，也可能是 ACK 报文受损）。</p>
<p><strong>解决方法</strong>：当发送端收到有损的 ACK&#x2F;NAK 报文，发送端同样重传报文并且继续等待。<strong>为了让接收方知道这是一次旧报文的重传还是受损报文的重传</strong>（对应于发送端收到无损 NAK），发送端需要给报文添加<strong>序号字段</strong>。对于停等协议，序号只需要 0 和 1 —— rdt 2.1 协议</p>
<h3 id="rdt-2-1-协议"><a href="#rdt-2-1-协议" class="headerlink" title="rdt 2.1 协议"></a>rdt 2.1 协议</h3><p><strong>为了让接收方知道这是一次旧报文的重传还是受损报文的重传</strong>（对应于发送端收到无损 NAK），发送端需要给报文添加<strong>序号字段</strong></p>
<img src="/2022/04/07/transport-layer/1647265748305-e77c3ba4-856e-45a9-be13-3a1aff420614.png" alt="rdt2.1 发送端" style="zoom: 80%;">

<img src="/2022/04/07/transport-layer/1647265771972-bbae444e-4cec-4133-9431-08b7730102c3.png" alt="rdt2.1 接收端" style="zoom: 80%;">

<p><strong>发送端</strong>：</p>
<p>一开始，发送序号为 0 的报文，如果收到的 ACK&#x2F;NAK 报文受损，重发序号为 0 的报文并且等待；</p>
<p>如果收到无损 NAK 报文，重发序号为 0 的报文并且等待；如果收到无损 ACK 报文，则等待发送序号为 1 的报文。</p>
<p>发送序号为 1 的报文，……，</p>
<p><strong>接收端</strong>：</p>
<p>一开始，等待序号为 0 的报文，若接收到的数据有损，发送 NAK 给发送端；若接收到的数据无损，且序号为 0，说明正确接收，传送至上层并发送 ACK 给发送端；若接收到的数据无损，且序号为 1，说明接收到了之前上一个报文的重传（上一个报文的序号是 1），丢弃报文并发送 ACK 给发送端，并且等待序号为 0 的报文。</p>
<p>等待序号为 1 的报文，……，</p>
<h3 id="rdt-2-2-协议"><a href="#rdt-2-2-协议" class="headerlink" title="rdt 2.2 协议"></a>rdt 2.2 协议</h3><p><strong>基于 rdt 2.1 协议，只使用 ACK，不使用 NAK。</strong></p>
<p><strong>对于发送端来说，由于现在只会收到 ACK，因此，收到无损 ACK 可能对应 rdt2.1 协议中的两种情况：</strong>收到无损 ACK 报文和收到无损 NAK 报文。</p>
<p>为了让发送端知道现在应该重传序号为 0 的报文并且等待，还是等待发送序号为 1 的报文，接收端也需要为 ACK 报文添加序号，该序号表示 <strong>确认号</strong>，即<strong>接收端已经正确接收到的报文序号</strong>，而<strong>接收端期待接收到的报文序号</strong>应该是：(确认号+1) % N，在停等协议中，N &#x3D; 2。发送端知道了接收端期待接收的报文序号，也就知道了要重传还是要发新报文。</p>
<img src="/2022/04/07/transport-layer/1647267039580-ffcd28d7-2f6e-4612-92e2-d64d24c10057-16493429072623.png" alt="rdt2.2 接收端" style="zoom:80%;">

<h3 id="rdt-3-0-协议"><a href="#rdt-3-0-协议" class="headerlink" title="rdt 3.0 协议"></a>rdt 3.0 协议</h3><p><strong>信道有差错和丢包。</strong>丢包的应对就是重传，仅仅只是让状态图内容更多了。</p>
<p><strong>丢包的解决方法</strong>：在<strong>发送方</strong>使用 <strong>基于时间的重传机制</strong>，<strong>每次发送一个分组就启动一个定时器</strong>，经过一定时间后若还未接收到回传的分组，则定时器响应中断，重传分组。</p>
<p>基于 rdt 2.2 协议，并加入定时检测丢包然后重传的功能，得到如下 rdt 3.0 协议的状态图。其接收端状态图与 rdt 2.2 协议相同。</p>
<img src="/2022/04/07/transport-layer/1647267415807-5656ac65-9ab6-495a-ad99-43d7d2e60e16.png" alt="rdt3.0 发送端" style="zoom:80%;">

<img src="/2022/04/07/transport-layer/1647267039580-ffcd28d7-2f6e-4612-92e2-d64d24c10057.png" alt="rdt3.0 接收端" style="zoom:80%;">

<h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><h3 id="回退-N-步（Go-Back-N，GBN）"><a href="#回退-N-步（Go-Back-N，GBN）" class="headerlink" title="回退 N 步（Go Back N，GBN）"></a>回退 N 步（Go Back N，GBN）</h3><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><p><strong>发送方要响应三种事件</strong>：</p>
<ol>
<li>上层的调用。当上层调用 rdt_send() 要发送数据时，发送方首先检查发送窗口是否已满，即是否有 N 个「已发送但未确认的分组」，如果窗口未满，则产生一个分组并发送，如果窗口已满，则告知上层窗口已满。（实际使用中，可以缓存这些分组，分组缓存的位置在发送窗口后面；也可以通过同步机制，如信号量，让上层只在窗口未满时才调用 rdt_send()）</li>
<li>收到 ACK。接收方所发送 ACK 分组的序号 x 表示接收方已经正确接收序号 &lt;&#x3D; x 的分组</li>
</ol>
<p>根据 ACK 分组的序号更新 base &#x3D; x + 1（窗口移动 1 单位），由于接收方采用累计确认，因此 x 和 base 是不断加 1 递增的。如果窗口移动了并且有在窗口内的未发送分组（之前缓存的分组），发送它们。</p>
<ol>
<li>超时事件。发送方维护一个定时器，它是最早的已发送但未被确认的分组的定时器。若超时，重传所有「已发送但未确认的分组」。</li>
</ol>
<p>定时器的维护方式：</p>
<ol>
<li><ol>
<li>当发送方收到 ACK，仍有「已发送但未确认的分组」，重启定时器</li>
<li>当发送方收到 ACK，没有「已发送但未确认的分组」，关闭定时器</li>
<li>超时，重启定时器</li>
</ol>
</li>
</ol>
<p><strong>发送窗口</strong>：</p>
<ul>
<li>[base, nextseqnum-1] 已发送未被确认</li>
<li>[nextseqnum, base+N-1] 可用还未发送</li>
</ul>
<p>nextseqnum 表示发送方下一个可发的分组的序号</p>
<h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><p>如果一个序号为 n 的分组被正确接收，且按序（即上一次交付给上层的分组序号是 n-1），则接收方交付数据到上层，并发送 ACK</p>
<p>其他情况，接收方丢弃分组，并为最近按序接收的分组重新发送 ACK</p>
<p><strong>下一个按序接收的分组的序号</strong>：</p>
<p>expectedseqnum 表示下一个按序接收的分组的序号，表明接收方已正确接收到序号 &lt; expectedseqnum 的所有分组</p>
<p>当接收到序号为 n 的分组，只需要判断 n 是否等于 expectedseqnum 即可。</p>
<p>按序接收，ACK 分组的序号&#x3D; expectedseqnum，然后更新++expectedseqnum</p>
<p>不按序接收，发送上一个ACK 分组，其序号为expectedseqnum-1</p>
<p>发送方的 base 与 接收方的 expectedseqnum 同步变化。</p>
<h3 id="选择重传（SR）"><a href="#选择重传（SR）" class="headerlink" title="选择重传（SR）"></a>选择重传（SR）</h3><p>回退 N 步的方案中，接收方不需要缓存失序分组，容易实现。但是由于不缓存失序分组，会导致更多的重传。</p>
<p>选择重传通过让发送方仅重传那些它怀疑在接收方出错的分组而避免不必要的重传。这种个别的、按需的重传方式要求<strong>逐个地确认</strong>正确接收的分组。（回退 N 步是累计确认）</p>
<h4 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h4><p><strong>发送方要响应三种事件</strong>：</p>
<ol>
<li><p>上层的调用。当从上层收到数据后，发送方检查下一个可用序号，如果序号位于发送窗口内，将数据打包发送，否则，类似地，要么将数据缓存，要么用同步机制控制上层调用的时机。</p>
</li>
<li><p>收到 ACK</p>
</li>
<li><ol>
<li>ACK 分组的序号在发送窗口内，将这个序号的分组标记为已接收。</li>
<li>如果该序号为 send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。</li>
<li>如果窗口移动了，并且有在窗口内的未发送分组（之前缓存的分组），发送它们</li>
</ol>
</li>
<li><p>超时事件。发送方为<strong>每个分组</strong>维护一个逻辑定时器，对应分组的定时器超时只需要重传该分组。可以使用单个硬件定时器模拟多个逻辑定时器</p>
</li>
</ol>
<h4 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h4><p><strong>接收方要响应三种事件</strong>：</p>
<ol>
<li><p>序号在接收窗口内的分组被正确接收</p>
</li>
<li><ol>
<li>如果该分组以前没收到过，则缓存该分组。</li>
<li>如果该分组的序号为 rcv_base，则该分组以及 rcv_base 往后缓存的连续分组被交付上层，并移动 rcv_base 和接收窗口。</li>
<li>发送 ACK，ACK 的序号是接收到的分组的序号</li>
</ol>
</li>
<li><p>序号在 [rcv_base-N, rcv_base-1] 内的分组被正确接收，发送 ACK，即使这个分组之前已经被接收方正确接收</p>
</li>
<li><p>其他情况，丢弃分组</p>
</li>
</ol>
<h5 id="发送窗口和接收窗口不同步的问题，即-send-base-x3D-rcv-base"><a href="#发送窗口和接收窗口不同步的问题，即-send-base-x3D-rcv-base" class="headerlink" title="发送窗口和接收窗口不同步的问题，即 send_base !&#x3D; rcv_base"></a>发送窗口和接收窗口不同步的问题，即 send_base !&#x3D; rcv_base</h5><p><strong>原因</strong></p>
<p>接收方根据 数据分组 序号信息移动接收窗口，并发送 ACK 分组。发送方根据 ACK 分组的序号移动发送窗口，如果 ACK 分组错误或者丢失，则发送发送窗口无法正确被标记。</p>
<p><strong>发送窗口的滞后</strong></p>
<p>接收窗口先移动，发送窗口只能与接收窗口同步，或者滞后。</p>
<p>至多滞后 N 个序号，这是因为接收窗口最多一次移动 N 步，而发送窗口可能由于序号为 rcv_base 的 ACK 分组丢失或者出错，连一步都移动不了</p>
<p><strong>示例</strong></p>
<p>发送方发送 0 到 4 号分组，传输到接收方</p>
<p><img src="/2022/04/07/transport-layer/1648559215136-0532653f-1536-43e4-8f9a-a65e32c8b7dd-16493429072624.png" alt="(a)"></p>
<p>接收方接收，并返回 0 到 4 号 ACK，接收窗口向前滑动5个位置</p>
<p><img src="/2022/04/07/transport-layer/1648559215290-9e8dccff-ae82-435b-9ef7-a01ce588bee0-16493429072625.png" alt="(b)"></p>
<p>0 到 4 号 ACK 传输到达发送方，但是 0 号ACK丢失，发送方接收 1 到 4 号 ACK，并记录 1 到 4 号 分组已收到确认，但是发送窗口不能向前移动。</p>
<p>一段时间后，0 号分组计时器超时，重传 0 号分组，传输到达接收方，接收方接收该分组并反馈 0 号 ACK，若发送方能正确接收该 ACK，则发送窗口也移动到 send_base &#x3D; 5</p>
<p>有限序号范围问题：</p>
<p>当窗口长度为N，实际上是这样的，[0,N-1][N,2N-1]…长度为N的窗口滑动，但是索引值却并非在0~N-1取值，索引值%N&#x3D;序号。如果窗口长度过大，接收方可能无法判断分组是新分组还是旧分组的重传。</p>
<img src="/2022/04/07/transport-layer/1641715373288-1bffa27c-c45d-44ee-a971-9f57bb9aa4c4-16493429072626.png" alt="img" style="zoom: 67%;">

<p><img src="/2022/04/07/transport-layer/1641715247816-3e91619a-488b-4b8e-89e1-d512dd2fcaea-16493429072627.png" alt="img"></p>
<p>此时接收方窗口的序号是3、0、1，而接收到序号0的分组，无法判断是应该在新的 0 序号对应的分组还是上个窗口的0重传</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/07/app-layer/" rel="prev" title="应用层">
      <i class="fa fa-chevron-left"></i> 应用层
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">1.</span> <span class="nav-text">传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-%E5%92%8C-TCP-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">UDP 和 TCP 的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-%E5%92%8C-TCP-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.</span> <span class="nav-text">UDP 和 TCP 的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">UDP 首部格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP"><span class="nav-number">1.4.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">TCP 首部格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.4.2.</span> <span class="nav-text">TCP 的三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">进行三次握手的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SYN-%E6%B4%AA%E8%8C%83%E6%94%BB%E5%87%BB"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">SYN 洪范攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%AD%E7%9A%84%E4%B8%A2%E5%8C%85%E5%A4%84%E7%90%86"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">三次握手中的丢包处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">TCP 的四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">为什么是四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TIME-WAIT-%E7%8A%B6%E6%80%81"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">TIME_WAIT 状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.4.</span> <span class="nav-text">TCP 流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.5.</span> <span class="nav-text">TCP 拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">TCP 拥塞控制算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">1.4.6.</span> <span class="nav-text">TCP 可靠数据传输</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-x2F-rdt-%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.</span> <span class="nav-text">可靠数据传输&#x2F;rdt 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#rdt-2-x-%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.</span> <span class="nav-text">rdt 2.x 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rdt-2-0-%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.1.</span> <span class="nav-text">rdt 2.0 协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdt-2-1-%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.2.</span> <span class="nav-text">rdt 2.1 协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdt-2-2-%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.3.</span> <span class="nav-text">rdt 2.2 协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdt-3-0-%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.4.</span> <span class="nav-text">rdt 3.0 协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.2.</span> <span class="nav-text">流水线可靠数据传输协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E9%80%80-N-%E6%AD%A5%EF%BC%88Go-Back-N%EF%BC%8CGBN%EF%BC%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">回退 N 步（Go Back N，GBN）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%96%B9"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">发送方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">接收方</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%EF%BC%88SR%EF%BC%89"><span class="nav-number">2.2.2.</span> <span class="nav-text">选择重传（SR）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%96%B9-1"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">发送方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9-1"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">接收方</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E5%92%8C%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E4%B8%8D%E5%90%8C%E6%AD%A5%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8D%B3-send-base-x3D-rcv-base"><span class="nav-number">2.2.2.2.1.</span> <span class="nav-text">发送窗口和接收窗口不同步的问题，即 send_base !&#x3D; rcv_base</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cyl"
      src="/images/icon1.jpg">
  <p class="site-author-name" itemprop="name">Cyl</p>
  <div class="site-description" itemprop="description">顽童大了别那么笨</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cyl</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>

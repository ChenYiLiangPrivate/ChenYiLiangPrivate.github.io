<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.1/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="图的存储方式、搜索遍历方式，图的各种算法">
<meta property="og:type" content="article">
<meta property="og:title" content="图算法">
<meta property="og:url" content="http://example.com/2022/04/27/graph-alg/index.html">
<meta property="og:site_name" content="缘溪行">
<meta property="og:description" content="图的存储方式、搜索遍历方式，图的各种算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425093330113.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425101943684.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425101954477.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425112400943.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425141808805.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425142531677.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425142833640.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425143022405.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425143420328.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425143447559.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425111027552.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425112047920.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425143754658.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425150859709.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425150821799.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425201219394.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425201253982.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425201330041.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425154846888.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220425154926083.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220426164546025.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220426165344733.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220426171511348.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220426192722448.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220426195639361.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220509155207223.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220503210522310.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220513203457788.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220513210039959.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220511144236814.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220520204358385.png">
<meta property="og:image" content="http://example.com/2022/04/27/graph-alg/image-20220511165156848.png">
<meta property="article:published_time" content="2022-04-27T06:30:41.000Z">
<meta property="article:modified_time" content="2022-05-20T13:21:56.849Z">
<meta property="article:author" content="Cyl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/27/graph-alg/image-20220425093330113.png">

<link rel="canonical" href="http://example.com/2022/04/27/graph-alg/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>图算法 | 缘溪行</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">缘溪行</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">27</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/27/graph-alg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          图算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-27 14:30:41" itemprop="dateCreated datePublished" datetime="2022-04-27T14:30:41+08:00">2022-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-20 21:21:56" itemprop="dateModified" datetime="2022-05-20T21:21:56+08:00">2022-05-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/27/graph-alg/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/27/graph-alg/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>图的存储方式、搜索遍历方式，图的各种算法</p>
<span id="more"></span>
<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><p>图的存储方法主要有两种：邻接链表和邻接矩阵。两种方式都可以表示无向图和有向图。</p>
<ul>
<li>邻接链表适合存储稀疏图（边的条数 |E| 远小于节点个数的平方 |V^2^|）</li>
<li>邻接矩阵适合存储稠密图，以及需要快速判断两个节点是否存在边的场景。需要注意到，对于无向图，邻接矩阵是一个对称矩阵，因此，我们实际上只需要 |V^2^|/2 的空间来存储邻接矩阵</li>
</ul>
<p>在图的规模较小的情况下（节点数较少），邻接矩阵通常是不错的选择。</p>
<p><img src="/2022/04/27/graph-alg/image-20220425093330113.png" alt="image-20220425093330113"></p>
<p>对邻接链表/邻接矩阵稍加修改，即可存储权重图。</p>
<ul>
<li>邻接链表，令存储元素为边的权值</li>
<li>邻接矩阵，对于存在的边，令存储元素为边的权值，对于不存在的边，根据场景，选择 0 或无穷值</li>
</ul>
<p>需要注意到，邻接链表和邻接矩阵存储的是边的信息，可以拓展到边的权重等各种信息，而非存储节点的信息。</p>
<p>通常推荐使用邻接表存储图，主要原因是，<strong>不需要约定用哪一个值来表示两个节点没有边</strong>。</p>
<h1 id="图的搜索遍历方式"><a href="#图的搜索遍历方式" class="headerlink" title="图的搜索遍历方式"></a>图的搜索遍历方式</h1><p>为了便于对图进行遍历，首先定义节点属性：每个节点具有的属性，例如<strong>节点编号、节点状态和节点对应的某个特定输出</strong>（当图的节点作为函数的状态节点时）</p>
<p>对于图中的任意一个节点，它在搜索的过程中有<strong>三种状态</strong>，即：</p>
<p><strong>「未搜索」</strong>：我们还没有搜索到这个节点；</p>
<p><strong>「搜索中」</strong>：我们搜索过这个节点，但还没有从该节点<strong>回溯</strong>；防止往回走重复路径</p>
<p><strong>「已完成」</strong>：我们搜索过并且从这个节点回溯过。这说明我们已经搜索了从该节点出发能到达的所有节点。对于「已完成」的节点，后续不会再访问它。</p>
<p>通常，我们用一个与节点数量相同的数据结构，命名为 visited，存储节点的搜索状态。</p>
<ul>
<li>不需要回溯时，节点是否被访问只取决于两种搜索状态：未搜索（false）和已搜索（true），已搜索对应「搜索中」和「已完成」这两种状态</li>
<li><strong>需要回溯时，才区分为三种状态</strong></li>
</ul>
<p><strong>以下探讨从图 G 的一个结点 s 出发进行搜索的方式，注意不一定能将整张图搜索完。</strong>要将整张图搜索完，需要以每个节点为源结点调用一次 bfs 或者 dfs</p>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>从图 G 的源结点 s 出发进行广度优先搜索。注意，</p>
<ul>
<li>一次 bfs 不一定能将整张图搜索完</li>
<li><strong>bfs 没有回溯的概念</strong></li>
</ul>
<p>在以下 bfs 的实现中：</p>
<ul>
<li>为了形象化 bfs 层序遍历的本质，令每个节点拥有属性 d，表示层数，也可以表示从源结点 s 到当前节点的最短路径（<strong>路径无权值情况下</strong>）</li>
<li><p>为了形象化图的连接关系，令每个节点拥有属性 p，表示其父结点</p>
</li>
<li><p>之所以在访问到的时候才初始化节点，是为了适配节点作为函数状态的场景，这种场景下，无法在一开始就初始化全部节点。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(G, s)</span>&#123;</span><br><span class="line">    Queue&lt;node&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 队列元素为节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// visited 初始化</span></span><br><span class="line">    <span class="keyword">for</span> v in G.v</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化起始节点的属性 s.init(); </span></span><br><span class="line">    s.d = <span class="number">0</span>;</span><br><span class="line">    s.p = NULL;</span><br><span class="line">    q.offer(s);</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="type">node</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> v in G.Adj[n]&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="comment">// v.init();</span></span><br><span class="line">                v.d = u.d + <span class="number">1</span>;</span><br><span class="line">                v.p = u;</span><br><span class="line">                visited[v] = <span class="literal">true</span>;</span><br><span class="line">                q.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历过程中访问-NULL-节点"><a href="#遍历过程中访问-NULL-节点" class="headerlink" title="遍历过程中访问 NULL 节点"></a>遍历过程中访问 NULL 节点</h3><p>在以上实现方式中，每次访问的是非空节点。在某些场景下，需要访问并且记录空节点。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/">二叉树的完全性检验</a></li>
</ul>
<p>通常来说，当图为树形结构的时候才需要这么处理，这是因为访问 NULL 节点可以维护树的一些基本性质（<strong>例如二叉性质，空的子节点也应该访问</strong>），便于对树进行分析。</p>
<p>假设图是一颗二叉树，bfs 并且访问空节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">q.offer(root);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">    <span class="type">node</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 版本1，只遍历非空节点</span></span><br><span class="line">    <span class="keyword">if</span>(n.left != <span class="literal">null</span>) q.offer(n.left);</span><br><span class="line">    <span class="keyword">if</span>(n.right != <span class="literal">null</span>) q.offer(n.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 版本2，空节点也遍历</span></span><br><span class="line">    <span class="keyword">if</span>(n != <span class="literal">null</span>)&#123;</span><br><span class="line">        q.offer(n.left);</span><br><span class="line">        q.offer(n.right);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本 1 搜索到的节点：     </p>
<p><img src="/2022/04/27/graph-alg/image-20220425101943684.png" alt="image-20220425101943684"></p>
<p> 版本 2 搜索到的节点：</p>
<p><img src="/2022/04/27/graph-alg/image-20220425101954477.png" alt="image-20220425101954477"></p>
<p>关于版本2，假设将层序遍历结果写成线性形式 arr=[1,2,null,3,4,null,null,null,null]，则可以根据元素的位置得到 它的左节点位置、右节点位置。对于元素 arr[i] != null，设 m 是 [0,i] 中 null 节点的个数，且设索引从 0 开始。则：</p>
<ul>
<li>左节点索引为：2(i-m)+1</li>
<li>右节点索引为：2(i-m)+2</li>
</ul>
<p>版本 1 没有类似结论的原因是：对于一个非空节点，它的子节点不一定在遍历结果中。换句话说，null 作为额外信息，能够帮助我们恢复二叉树结构。</p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>修改循环体的结构即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">layerSize</span> <span class="operator">=</span> q.size(); <span class="comment">// 需要提前记录，而不能写为 for i in q.size()，因为循环过程 q.size() 会改变</span></span><br><span class="line">    <span class="keyword">for</span> i in layerSize&#123;</span><br><span class="line">        <span class="type">node</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> v in G.Adj[n]&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="comment">// v.init();</span></span><br><span class="line">                v.d = u.d + <span class="number">1</span>;</span><br><span class="line">                v.p = u;</span><br><span class="line">                visited[v] = <span class="literal">true</span>;</span><br><span class="line">                q.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>从图 G 的源结点 s 出发进行深度优先搜索。注意，</p>
<ul>
<li>一次 dfs 不一定能将整张图搜索完</li>
<li><strong>dfs 有回溯的概念</strong></li>
</ul>
<p>在以下 dfs 的实现中：</p>
<ul>
<li><p>为了形象化 dfs 深度优先遍历的本质，令每个<strong>节点</strong>拥有：</p>
<ul>
<li>属性 d，表示<strong>发现时间</strong>，刚访问到本节点，也可以表示从源结点 s 到当前节点的最短路径（<strong>路径无权值情况下</strong>）</li>
<li><p>属性 f，表示<strong>完成时间</strong>，已经访问完本节点能到达的所有结点。</p>
<p>并且，令节点的<strong>状态为三种</strong>而非两种，visited 是三值的</p>
</li>
</ul>
</li>
<li><p>为了形象化图的连接关系，令每个节点拥有属性 p，表示其父结点</p>
</li>
<li><p>之所以在访问到的时候才初始化节点，是为了适配节点作为函数状态的场景，这种场景下，无法在一开始就初始化全部节点。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">dfs(G, s)&#123;</span><br><span class="line">    <span class="comment">// time 是外部变量，整个 dfs 过程对应唯一一个 time 变量</span></span><br><span class="line">    <span class="comment">// 之所以 ++time，是因为调用 dfs(G, s) 的代码处没有加时间</span></span><br><span class="line">    ++time; </span><br><span class="line">    s.d = time;</span><br><span class="line">	visited[s] = gray;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> v in G.Adj[s]&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[v] == white)&#123;</span><br><span class="line">            v.p = s;</span><br><span class="line">            dfs(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经访问完本节点能到达的所有结点</span></span><br><span class="line">    visited[s] = black;</span><br><span class="line">    ++time;</span><br><span class="line">    s.f = time;</span><br><span class="line">&#125;</span><br><span class="line">Dfs(G)&#123;</span><br><span class="line">    <span class="comment">// visited 初始化</span></span><br><span class="line">    <span class="keyword">for</span> v in G.v</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> v in G.V&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[v] == white)</span><br><span class="line">            dfs(G, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>无回溯版本的写法</strong>，不维护 d 和 f 属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dfs(G, s)&#123;</span><br><span class="line">	visited[s] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> v in G.Adj[s]&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[v] == <span class="literal">false</span>)&#123;</span><br><span class="line">            v.p = s;</span><br><span class="line">            dfs(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>先来看深度优先搜索在一个有向图上的运行过程。</p>
<ul>
<li><p>图中节点只记录 d 和 f 属性，发现时间/完成时间</p>
</li>
<li><p>边则分为树边和非树边（后向（back）边、横向（cross）边、前向（forward）边），其中树边用阴影标记，非树边用虚线标记，非树边中的三种边又各自标记为 B、C、F</p>
</li>
</ul>
<p>对边进行分类的意义将在后面提到。</p>
<p><img src="/2022/04/27/graph-alg/image-20220425112400943.png" alt="深度优先搜索在有向图上的运行过程"></p>
<p>深度优先搜索的一个重要性质是：</p>
<p>节点的发现时间和完成时间具有<strong>括号化结构</strong>。如果以左括号表示发现节点，右括号表示完成节点，根据搜索过程画出来的括号会是一个有效的括号字符串。</p>
<p><img src="/2022/04/27/graph-alg/image-20220425141808805.png" alt="深度优先搜索的性质"></p>
<p>(a) 表示有向图的深度优先搜索过程，(b) 表示深搜过程每个节点的发现时间和完成时间得到的括号化结构</p>
<p>定理</p>
<p><img src="/2022/04/27/graph-alg/image-20220425142531677.png" alt></p>
<p><img src="/2022/04/27/graph-alg/image-20220425142833640.png" alt="image-20220425142833640"></p>
<p><img src="/2022/04/27/graph-alg/image-20220425143022405.png" alt="image-20220425143022405"></p>
<p>第一种情况，符合树边的定义。第二种情况，第一次探索边 (u, v) 说明 u 此时一定是灰色，而 v 也为灰色，说明它们此前已经处于一个深度优先树中，对于第三种情况</p>
<p><img src="/2022/04/27/graph-alg/image-20220425143420328.png" alt="image-20220425143420328"></p>
<p><img src="/2022/04/27/graph-alg/image-20220425143447559.png" alt="image-20220425143447559"></p>
<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>需要注意的是，这里的图，节点经常是可以多次访问的。我们需要修改dfs ，状态不应该有 black。上面是搜索，每个结点访问一次即可，这里是回溯，节点经常是可以多次访问的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dfs(G, s)&#123;</span><br><span class="line">	visited[s] = gray;</span><br><span class="line">    </span><br><span class="line">    for v in G.Adj[s]&#123;</span><br><span class="line">        if(visited[v] == white)&#123;</span><br><span class="line">            v.p = s;</span><br><span class="line">            dfs(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 已经访问完本节点能到达的所有结点</span><br><span class="line">    visited[s] = white;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从某个节点搜索完它能到达的所有结点之后，回溯到它的父结点，子路径visited被重置。唯一区别，每个节点的visited不同（即能访问的目标节点不同），搜索过程中，所有节点并不共享同一个visited。<br>注意添加元素和回溯元素的代码位置</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></p>
<p><img src="/2022/04/27/graph-alg/image-20220425111027552.png" alt="image-20220425111027552"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多源的搜索图，用算法导论的写法更工整明白</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Dfs</span><span class="params">(List&lt;Integer&gt; preList, <span class="type">int</span>[] visited)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        dfs(preList, visited, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上一个节点的 排列、visited 需要作为参数传入，实际上这也就是结点的属性！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; preList, <span class="type">int</span>[] visited, <span class="type">int</span> cur)</span>&#123; </span><br><span class="line">    visited[cur] = <span class="number">1</span>;</span><br><span class="line">    preList.add(nums[cur]);</span><br><span class="line">    <span class="comment">// 找到一个结果，这种情况下，下一步没得走，for 内部不会调用 dfs 了</span></span><br><span class="line">    <span class="keyword">if</span> (preList.size() == n) </span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(preList));  <span class="comment">// 需要res.add(preList的拷贝)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)</span><br><span class="line">            dfs(preList, visited, i);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    visited[cur] = <span class="number">0</span>;</span><br><span class="line">    preList.remove(preList.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个节点对应一个（前缀）排列，每个节点根据当前的visited数组情况产生分支。树深度为n=3</p>
<p>因此，树角度，每个节点应该包含两个属性：当前排列、当前visited数组。当树深度为n，停止生长。</p>
<p>从搜索角度，每个节点接收上一个节点的属性作为输入（自上而下的搜索思路，而非自下而上），根据visited数组产生分支进入下一个节点，当节点的属性：当前排列长度为n时，停止搜索并返回。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></p>
<p>每次用 剩余元素 凑成全排列。对于剩余元素集合，如果第一个拿出来的数相同，那么剩余的数也相同，则这两套全排列也相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多源的搜索图，用算法导论的写法更工整明白</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Dfs</span><span class="params">(List&lt;Integer&gt; preList, <span class="type">int</span>[] visited)</span>&#123;</span><br><span class="line">    <span class="comment">// 记录当前层（root）访问过的节点，用于剪枝（去掉重复排列）</span></span><br><span class="line">    <span class="comment">// 对于已访问过的结点，其满足题意的全排列一定已经搜索完了</span></span><br><span class="line">    Set&lt;Integer&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="number">0</span> &amp;&amp; !hs.contains(nums[i]))&#123;</span><br><span class="line">            hs.add(nums[i]);</span><br><span class="line">            dfs(preList, visited, i);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上一个节点的 排列、visited 需要作为参数传入，实际上这也就是结点的属性！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; preList, <span class="type">int</span>[] visited, <span class="type">int</span> cur)</span>&#123; </span><br><span class="line">    visited[cur] = <span class="number">1</span>;</span><br><span class="line">    preList.add(nums[cur]);</span><br><span class="line">    <span class="comment">// 找到一个结果，这种情况下，下一步没得走，for 内部不会调用 dfs 了</span></span><br><span class="line">    <span class="keyword">if</span> (preList.size() == n) </span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(preList));  <span class="comment">// 需要res.add(preList的拷贝)</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 记录当前结点已经访问过的子节点，用于剪枝（去掉重复排列）。注意，如果把整个 dfs 图画出来，hs 只会记录某个结点的分支子节点，而不是这个分支所属层的所有结点</span></span><br><span class="line">    <span class="comment">// 对于已访问过的子结点，其满足题意的全排列一定已经搜索完了</span></span><br><span class="line">    Set&lt;Integer&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="number">0</span> &amp;&amp; !hs.contains(nums[i]))&#123;</span><br><span class="line">            hs.add(nums[i]);</span><br><span class="line">            dfs(preList, visited, i);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    visited[cur] = <span class="number">0</span>;</span><br><span class="line">    preList.remove(preList.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></p>
<p>背包问题求组合，会浪费大量空间。因此，搜索求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Dfs</span><span class="params">(<span class="type">int</span> target, List&lt;Integer&gt; pre)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;candidates.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates[i] &gt; target)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        dfs(i, target-candidates[i], pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> target, List&lt;Integer&gt; pre)</span>&#123;</span><br><span class="line">    pre.add(candidates[begin]);</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>)</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(pre)); <span class="comment">// 复制一份</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历下一个可以走的结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;candidates.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates[i] &gt; target) <span class="comment">// 若先将 candidates 排序，这里可以直接break</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        dfs(i, target-candidates[i], pre);</span><br><span class="line">    &#125;</span><br><span class="line">    pre.remove(pre.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></p>
<p>设 candidates = [2, 1, 2, 2, 5], target = 5。为了去重以及第一个break，先将它排序 </p>
<p><img src="/2022/04/27/graph-alg/image-20220425112047920.png" alt="image-20220425112047920"></p>
<p> 实际上这是全排列 II，只不过条件变为和为 target</p>
<blockquote>
<p>相关题目</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p>
</blockquote>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>许多实际应用都用有向无环图来指明事件的优先次序、顺序逻辑。例如穿衣服可以这么穿：</p>
<p><img src="/2022/04/27/graph-alg/image-20220425143754658.png" alt></p>
<p>上图描述的是经过拓扑排序后的节点次序，这个<strong>次序与节点的完成时间正好相反</strong></p>
<p>可以将图的拓扑排序看做是将图的 <strong>所有</strong> 结点在一条水平线上展开，图的所有边都由左指向右。如果存在多个入度为 0 的节点，能构成多个线性排序的子图，仍旧可以把它们放到一条水平线上，虽然存在断点。</p>
<p>需要注意的是，有向边为：（前提节点，完成后可以到达的节点）。</p>
<p>拓扑排序的实现方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">topoLogicalSort</span><span class="params">(G)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    Dfs(G); <span class="comment">// 每个节点为 black 时，将其插入到链表头部</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对 Dfs(G) 进行修改，只需要修改 dfs(G, s)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(G, s)</span>&#123;</span><br><span class="line">    <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">	visited[s] = gray;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">    <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">    <span class="keyword">for</span> v in G.Adj[s]&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[v] == white)&#123;</span><br><span class="line">            dfs(G, v);</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == gray) &#123;</span><br><span class="line">            valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经访问完本节点能到达的所有结点</span></span><br><span class="line">    visited[s] = black;</span><br><span class="line">    <span class="comment">// 创建链表节点，添加到链表头部</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(s.val);</span><br><span class="line">    x.next = head;</span><br><span class="line">    head = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p><strong>图能够得到拓扑排序</strong>的<strong>充要</strong>条件：有向无环图</p>
<p><strong>有向图无环</strong>的<strong>充要</strong>条件：对其进行深度优先搜索不产生后向边</p>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a>：得到一种拓扑排序结果</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">课程表</a>：判断是否存在拓扑排序，本质上等价于判断有向图是否有环。</p>
<h1 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h1><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>在一给定的连通无向图 G = (V, E) 中，用 (u, v) 代表连接顶点 u 与顶点 v 的边，用 w(u, v) 代表此边的权重。V 表示结点的集合，E 表示边的集合。</p>
<p>对于一个有着 n 个结点的连通无向图，我们希望找到一个无环子集 T⊆E，将所有结点连接起来，且 T 的边权重总和最小，即令：$w(T)=\sum_{(u,v)\epsilon T}^{}w(u,v)$最小。</p>
<p>由于 T 是无环的，并且连通所有的结点，因此，T 是一颗树，称其为图 G 的生成树；又由于 T 的边权重总和是所有生成树中最小，所以称 T 为图 G 的最小生成树。</p>
<p><img src="/2022/04/27/graph-alg/image-20220425150859709.png" alt></p>
<p>解决最小生成树的两个算法：Kruskal 算法和 Prim 算法。两种算法都是贪心算法。</p>
<h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>Kruskal 算法使用并查集，每个集合代表当前当前森林中的一棵树。MST 表示获得最小生成树，获得最小生成树的算法中，将维护一颗树 A（用边的集合表示），保证每次对 A 进行操作时，A 是最终获得的最小生成树的一部分。<img src="/2022/04/27/graph-alg/image-20220425150821799.png" alt="image-20220425150821799"></p>
<ul>
<li>算法的 1~3 行将集合 A 初始化为一个空集，并创建 |V| 颗树，每棵树仅包含一个节点。</li>
<li>算法第 4 行将所有的边按照升序排序，排序的元素是节点对，排序的规则是按照边的权重。便于 for 循环进行检查</li>
<li>算法的 5~8 行的 for 循环按照权重从低到高的次序对每条边逐一进行检查，对于边 (u, v) 来说，检查端点 u 和端点 v 是否属于同一棵集合，如果是，该条边不能加入到森林里（否则将形成环路），如果不是，则两个端点分别属于不同的树，把这条边加入到集合 A 中，然后把两棵树进行合并。</li>
</ul>
<p><strong>时间复杂度分析</strong>：O(ElogV)，依赖于并查集的维护算法、</p>
<p><img src="/2022/04/27/graph-alg/image-20220425201219394.png" alt></p>
<p><img src="/2022/04/27/graph-alg/image-20220425201253982.png" alt></p>
<p><img src="/2022/04/27/graph-alg/image-20220425201330041.png" alt></p>
<h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>在 Prim 算法的执行过程中，所有不在树 A 中的节点都存放在一个基于 key 属性的最小优先队列 Q 中。对于每个节点 v，属性 v.key 保存的是连接 v 和树 A 中节点的所有边中最小边的权重。</p>
<p><strong>每次，检查从树 A 中的节点能到达的属于队列 Q 的节点，选择其中权重最小的边加入树 A</strong></p>
<p><img src="/2022/04/27/graph-alg/image-20220425154846888.png" alt></p>
<p><img src="/2022/04/27/graph-alg/image-20220425154926083.png" alt></p>
<p>Prim 算法的关键在于维护最小优先队列，队列存放的是节点，维护的规则为：</p>
<p>对于所有属于队列的节点，队头节点具有一条连接到树 A 的最小权值的边。实际上也就是<strong>根据节点的属性 key 来维护最小优先队列</strong>。</p>
<p>在下面的伪代码中，由于我们保持了上述规则，因此在将队头节点 u 加入树 A 后，可以更新其子节点 v 到树 A 的 key 属性，每次从队列中选出一个节点加入到树 A，都会导致队列中部分元素的属性 key 变化，而<strong>这在上面的 Prim 算法示意图中并没有体现出来</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码描述</span><br><span class="line">MST-PRIM(G, w, r):</span><br><span class="line">	for u in G.V:</span><br><span class="line">		u.key = INF // 无穷大，一开始节点只在 Q 中</span><br><span class="line">		u.p = NULL</span><br><span class="line">    r.key = 0</span><br><span class="line">    </span><br><span class="line">    Q = G.V</span><br><span class="line">    while(!Q.isEmpty()):</span><br><span class="line">    	u = EXTRACT-MIN(Q) // 一开始，会把节点 r 选出</span><br><span class="line">    	for v in G.Adj[u]:</span><br><span class="line">    		if v belongsto Q and w(u,v) &lt; v.key:</span><br><span class="line">    			v.p = u</span><br><span class="line">    			v.key = w(u,v)</span><br><span class="line">    			// 维护队列性质不变</span><br><span class="line">    			Q.update()</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析</strong>：</p>
<ul>
<li>使用二叉堆实现最小优先队列。O(V+VlogV+ElogV) = O(VlogV+ElogV)<ul>
<li>初始化队列：BUILD-MIN-HEAP，O(V)</li>
<li>while 语句的执行次数是 V 次，每次EXTRACT-MIN(Q) 操作实际上包括：弹出队头元素，MAX-HEAPIFY，因此 O(logV)，while 总共的EXTRACT-MIN(Q) 时间复杂度 O(VlogV)</li>
<li>while 总共的 for 次数是 E 次，每次需要 MAX-HEAPIFY 维护队列，while 总共的 for 时间复杂度 O(ElogV)</li>
</ul>
</li>
<li>使用斐波那契堆实现最小优先队列。O(E+VlogV)</li>
</ul>
<p>常见的一些实现方式中，并没有维护最小优先队列，而是遍历剩余未添加到树 A 的节点，并查看其 key 属性，找到符合条件的节点。</p>
<p><strong>Prim 算法的 Java 实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> parent; <span class="comment">// 标记本节点的父结点，-1 表示不存在</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 标记本节点</span></span><br><span class="line">    <span class="type">boolean</span> inQueue; <span class="comment">// true 表示该节点在队列中，false 表示该节点在最小生成树中</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> k, <span class="type">int</span> p, <span class="type">int</span> v, <span class="type">boolean</span> iQ)&#123;</span><br><span class="line">        <span class="built_in">this</span>.key = k;</span><br><span class="line">        <span class="built_in">this</span>.parent = p;</span><br><span class="line">        <span class="built_in">this</span>.val = v;</span><br><span class="line">        <span class="built_in">this</span>.inQueue = iQ;</span><br><span class="line">    &#125;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵存储图，0 表示无连接</span></span><br><span class="line"><span class="comment">// 最小生成树不限制边的权重，建议使用邻接表，否则每次都用 0 表示无连接很可能出错</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Node&gt; <span class="title function_">mstPrim</span><span class="params">(<span class="type">int</span>[][] graph)</span>&#123;</span><br><span class="line">    <span class="comment">// 节点存放到优先队列中，会乱序，因此需要知道每个节点自身的标记，即 val 属性</span></span><br><span class="line">    PriorityQueue&lt;Node&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Node&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Node e1, Node e2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> e1.key - e2.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> graph.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MAX_VALUE, -<span class="number">1</span>, i, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            n.key = <span class="number">0</span>; <span class="comment">// 保证一开始的队头元素符合要求</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传递引用</span></span><br><span class="line">        q.offer(n); </span><br><span class="line">        nodes.add(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">u</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        u.inQueue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[u.val][i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">v</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(v.inQueue &amp;&amp; graph[u.val][i] &lt; v.key)&#123;</span><br><span class="line">                    v.parent = u.val;</span><br><span class="line">                    v.key = graph[u.val][i];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 删除再加入，维护队列性质</span></span><br><span class="line">                    q.remove(v);</span><br><span class="line">                    q.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nodes; <span class="comment">// 通过节点的 parent 属性得到树结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><p><strong>单源最短路径问题</strong>：给定一个图 G=(V, E)，我们希望找到从给定源结点 s 到每个节点的最短路径。</p>
<p><strong>最短路径的表示</strong>：在通常情况下，我们不但希望计算出最短路径的权重，还希望知道路径上的结点。因此，对于每个节点，维护属性 p，它并不表示在有向图中的父结点，而用于存储从源结点到本节点的最短路径中，自己的父结点。在一开始，所有节点的属性 p 为 NULL</p>
<h2 id="松弛操作"><a href="#松弛操作" class="headerlink" title="松弛操作"></a>松弛操作</h2><p>对每个结点 v 来说，我们维持一个属性 v.d，v.d 为源结点 s 到结点 v 的<strong>最短路径估计</strong>，使用以下初始化算法对各个结点的最短路径估计和前驱结点进行初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">	for v in G.V:</span><br><span class="line">		v.d = INF</span><br><span class="line">		v.p = NULL</span><br><span class="line">	s.d = 0 // 覆盖上面对 s.d = INF 的修改</span><br></pre></td></tr></table></figure>
<p>对边 (u, v) 的<strong>松弛</strong>操作就是根据源结点 s 到结点 u 的最短路径估计来更新：</p>
<ul>
<li>源结点 s 到结点 v 的最短路径估计 <strong>v.d</strong></li>
<li>节点 v 的最短路径估计的前驱节点 <strong>v.p</strong></li>
</ul>
<p>对边 (u, v) 的松弛过程可用如下伪代码描述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RELAX(u, v)</span><br><span class="line">	if v.d &gt; u.d+w(u, v)</span><br><span class="line">		v.d = u.d+w(u, v)</span><br><span class="line">		v.p = u</span><br></pre></td></tr></table></figure>
<h2 id="最短路径具有的性质"><a href="#最短路径具有的性质" class="headerlink" title="最短路径具有的性质"></a>最短路径具有的性质</h2><p>1、<strong>最优子结构性质</strong>：最短路径的子路径也是最短路径</p>
<p>2、<strong>无环路</strong>：首先要明确一点，环路是可以一直走的。对于某条路径，如果加入一条路径后成为环路：</p>
<ul>
<li>当<strong>环路的</strong>权重为负数时（环路所有边的权重之和），只要沿着这条环路不停地走，路径的权重值就能一直减小，趋于负无穷，<strong>不存在最短路径</strong></li>
<li>当环路的权重非负时，<strong>有最短路径</strong>，最短路径一定不是环路。例如，对于下图的 cd 环路，环路的权重非负，c 到 d 的最短路径是 6，这是因为 c 到 d 之后，多次走 d-&gt;c-&gt;d 这条环路，权重会不断增大。</li>
</ul>
<p><img src="/2022/04/27/graph-alg/image-20220426164546025.png" alt></p>
<blockquote>
<p><strong>单源最短路径存在的充要条件</strong>：源结点 s 没有可以到达的权重为负数的环路</p>
</blockquote>
<p>3、最短路径可能有多条</p>
<p><strong>以下几条性质与最短路径算法有关</strong>。</p>
<p>4、<strong>三角不等式性质</strong>：假定源结点 s 到结点 v 的最短路径为 p，则 p 的权重一定比任何从 s 到 v 的其他路径的权重小。这是非常自然地，因为这就是最短路径的定义。</p>
<script type="math/tex; mode=display">
δ(s,v)≤δ(s,u)+w(u,v)</script><p>这条性质提出的目的是为了将最短路径进行抽象化简单描述。简单地作图时，可以把最短路径画成直接连接 s 和 v 的线段，结点 u 的位置只能在这线段上或者线段外，形如三角形，因此叫做三角不等式性质。</p>
<p>5、<strong>收敛性质</strong>：设 s -&gt; u -&gt; … -&gt; v 是图 G 中源 s 到 节点 v 的一条最短路径。假定图 G 由 INITIALIZE—SINGLE—SOURCE(G, s) 算法进行初始化，并在之后进行了一系列的松弛操作。如果在对边 (u, v) 进行松弛之前的任意时刻有 u.d=δ(s, u)，即已经找到源结点 s 到结点 u 的最短路径，则在对边 (u, v) 进行松弛操作后，有 v.d=δ(s, v)，也就是说，找到了源结点 s 到结点 v 的最短路径</p>
<p><img src="/2022/04/27/graph-alg/image-20220426165344733.png" alt></p>
<h2 id="单源最短路径的变体问题"><a href="#单源最短路径的变体问题" class="headerlink" title="单源最短路径的变体问题"></a>单源最短路径的变体问题</h2><p><strong>单源最短路径问题</strong>：给定一个图 G=(V, E)，我们希望找到从给定源结点 s <strong>到每个节点的</strong>最短路径。</p>
<blockquote>
<p>注意是到每个节点的最短路径，因此，对于以下各种最短路径算法，如果是单源且单目的地，则当对目的节点进行松弛操作后，即可结束计算。</p>
</blockquote>
<p><strong>单目的地最短路径问题</strong>：<strong>将源结点设为目的结点，将图的每条边的方向翻转</strong>，该问题即成为了单源最短路径问题。</p>
<p>所有结点对最短路径问题：要求得到所有结点对的最短路径。虽然可以对所有节点对运行一遍单源最短路径算法，但存在更快的解决方法。</p>
<h2 id="单源最短路径算法"><a href="#单源最短路径算法" class="headerlink" title="单源最短路径算法"></a>单源最短路径算法</h2><p><strong>Bellman-Ford 算法</strong>解决的是一般情况下的单源最短路径问题。在这里，边的权值可以为负数。Bellman-Ford 算法返回一个布尔值，用来表明是否存在一个从源结点可以到达的权重为负值的环路。</p>
<p><strong>Dag-Shortest-Paths 算法</strong>要求<strong>图没有环路，允许负权值的边</strong>。在有向无环图中，即使存在权重为负值的边，但因为没有权重为负值的环路，满足最短路径的存在性充要条件。</p>
<p><strong>Dijkstra 算法</strong>要求<strong>所有边的权重不为负数</strong>，因此一定不存在权重为负值的环路。</p>
<p>广度优先搜索：只能用于求解<strong>无权重</strong>的图的单源最短路径问题。路径的长度为访问过的节点个数。结点同样具有属性 d 和属性 p，但是结点的属性 d 不再是用权值衡量</p>
<p>深度优先搜索：本质上应该是 Dag-Shortest-Paths 算法？dfs 的参数即为结点的两个属性。</p>
<h3 id="BELLMAN-FORD-算法"><a href="#BELLMAN-FORD-算法" class="headerlink" title="BELLMAN-FORD 算法"></a>BELLMAN-FORD 算法</h3><p>Bellman-Ford 算法实现如下：</p>
<p><img src="/2022/04/27/graph-alg/image-20220426171511348.png" alt></p>
<p>首先对所有节点的 d 值和 p 值进行初始化，然后对图的每条边进行 |V|-1 次松弛操作。执行完松弛操作后，算法第 5~8 行检查图中是否存在权重为负值的环路。</p>
<p>Bellman-Ford 算法基于路径松弛性质运行。正确性的证明见算法导论。</p>
<h3 id="Shortest-Path-Faster-算法"><a href="#Shortest-Path-Faster-算法" class="headerlink" title="Shortest Path Faster 算法"></a>Shortest Path Faster 算法</h3><p>SPFA</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ProcedureSPFA;</span><br><span class="line">Begin</span><br><span class="line">    initialize-single-source(G,s);</span><br><span class="line">    initialize-queue(Q);</span><br><span class="line">    enqueue(Q,s);</span><br><span class="line">    while not empty(Q) do begin</span><br><span class="line">        u:=dequeue(Q);</span><br><span class="line">        for each v∈adj[u] do begin</span><br><span class="line">            tmp:=d[v];</span><br><span class="line">            relax(u,v);</span><br><span class="line">            if(tmp&lt;&gt;d[v])and(not v in Q)then enqueue(Q,v); // 如果 v 在 Q 中，v 的 d已经被松弛操作影响，不需要再入队</span><br><span class="line">        end;</span><br><span class="line">    end;</span><br><span class="line">End; </span><br></pre></td></tr></table></figure>
<p>设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止</p>
<p> 对SPFA的一个很直观的理解就是由无权图的BFS转化而来。在无权图中，BFS首先到达的顶点所经历的路径一定是最短路(也就是经过的最少顶点数)，所以此时利用数组记录节点访问可以使每个顶点只进队一次，但在带权图中，最先到达的顶点所计算出来的路径不一定是最短路。一个解决方法是放弃数组，此时所需时间自然就是指数级的，所以我们不能放弃数组，而是在处理一个已经在队列中且当前所得的路径比原来更好的顶点时，直接更新最优解。</p>
<p>与 dijkstra 的区别：dijkstra 不能负权，非 Q 的节点（S中的节点）已经找到最短路径；SPFA 可以负权，非 Q 的节点可能还没找到最短路径。实际上，如果有负权，dijkstra 无法保证非 Q 的节点（S中的节点）已经找到最短路径）</p>
<h3 id="Dag-Shortest-Paths-算法"><a href="#Dag-Shortest-Paths-算法" class="headerlink" title="Dag-Shortest-Paths 算法"></a>Dag-Shortest-Paths 算法</h3><p>Dag-Shortest-Paths 算法实现如下：</p>
<p><img src="/2022/04/27/graph-alg/image-20220426192722448.png" alt></p>
<p>首先对有向无环图进行拓扑排序，根据节点的拓扑排序次序访问每个节点，对于任意一个节点，对从该节点出发的所有边进行松弛操作</p>
<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p>Dijkstra 算法实现如下：</p>
<p><img src="/2022/04/27/graph-alg/image-20220426195639361.png" alt></p>
<p>Dijkstra 算法的关键在于维持循环不变量：节点集合 S，从源结点 s 到该集合中每个节点的最短路径已被找到。</p>
<p>算法不断从节点集合 Q=V-S 中选择最短路径估计最小的结点 u，将 u 加入到集合 s，然后对所有从 u 出发的边进行松弛。并且，上述伪代码中没有体现的是，由于节点集合 S 表示从源结点 s 到该集合中每个节点的最短路径已被找到，因此松弛操作不需要包含 S 中的节点。</p>
<p><img src="/2022/04/27/graph-alg/image-20220509155207223.png" alt></p>
<p>在一开始，Q 中只有源结点 s 的 s.d = 0，它将被选出。使用最小优先队列保存 Q，Q 的每个元素是一个结点，包含 d 和 p 属性，按照结点的 d 属性进行排序。</p>
<p>算法结构与 Prim 算法十分相似，类似 Prim 算法，将伪代码进行转化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis;</span><br><span class="line">    <span class="type">int</span> parent; <span class="comment">// 标记本节点的父结点，-1 表示不存在</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 标记本节点</span></span><br><span class="line">    <span class="type">boolean</span> inQueue; <span class="comment">// true 表示该节点在队列 Q 中。类似 prim 算法，用来区分处于伪代码中的 S 还是 Q</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> p, <span class="type">int</span> v, <span class="type">boolean</span> iQ)</span>&#123;</span><br><span class="line">    	<span class="built_in">this</span>.dis = d;</span><br><span class="line">        <span class="built_in">this</span>.parent = p;</span><br><span class="line">        <span class="built_in">this</span>.val = v;</span><br><span class="line">        <span class="built_in">this</span>.inQueue = iQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵存储图</span></span><br><span class="line"><span class="comment">// 由于 dijkstra 算法适用于无负权值的图，因此用 -1 表示无连接，不能用 0</span></span><br><span class="line">List&lt;Node&gt; <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> s)</span>&#123;</span><br><span class="line">    PriorityQueue&lt;Node&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Node&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Node e1, Node e2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> e1.dis - e2.dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// INITIALIZE-SINGLE-SOURCE(G, s)</span></span><br><span class="line">    List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> graph.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MAX_VALUE, -<span class="number">1</span>, i, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(i == s)</span><br><span class="line">            n.dis = <span class="number">0</span>; <span class="comment">// 源结点 s，初始化后它会处于队头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传递引用</span></span><br><span class="line">        q.offer(n); </span><br><span class="line">        nodes.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">u</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        u.inQueue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[u.val][i] != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">v</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// relax(u, v)</span></span><br><span class="line">				<span class="keyword">if</span>(v.inQueue &amp;&amp; v.dis &gt; u.dis + graph[u.val][i])&#123;</span><br><span class="line">                    v.dis = u.dis + graph[u.val][i];</span><br><span class="line">                    v.parent = u.val;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 删除再加入，维护队列性质</span></span><br><span class="line">                    q.remove(v);</span><br><span class="line">                    q.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nodes; <span class="comment">// 通过节点的 parent 属性得到路径结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Dijkstra 算法是一种贪心算法，在《算法导论》中证明了它的正确性。</p>
</blockquote>
<h4 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/4gGyon/">单源最短路题目总结 - 力扣（LeetCode）</a></p>
<p>基于上面三种经典的权重图最短路径算法，某些问题的最短路径或是有所限制，或是更加抽象。无论是什么题目，我们只需要关注一个东西，即<strong>我们为每个节点维护的最短路径估计是什么</strong>？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">787. K 站中转内最便宜的航班</a></p>
<p>最短路径应该考虑两个方面：经过的节点个数、价格。</p>
<ul>
<li><p>经过的节点个数相同的情况下，保留价格更小的路径。</p>
</li>
<li><p>在相同价格的情况下，保留节点数更少的路径。</p>
</li>
</ul>
<p>我们可以按这两条规则对源结点到当前节点的路径代价进行排序。设源结点到当前节点有 n=6 条路径，它们可能有如下排序：</p>
<p><img src="/2022/04/27/graph-alg/image-20220503210522310.png" alt></p>
<p>进一步地，我们只需要记录 (1, 1)、 (2, 1) 和 (3, 1)，不需要记录 (1, 2)、(1, 3) 和 (2, 2)。</p>
<p>如果节点个数为 1 时，花费的时间没有 1 这一项，那么对于 (1, 2) 和 (2, 1)，哪一条是最短路径就很难说了，因为有可能走节点个数为 2 这一条不会超过上限，而花费的时间又少，那么它是最短路径，也有可能节点个数超过上限，那就不行了。</p>
<p>更进一步地，可以对 (1, 1)、 (2, 1) 和 (3, 1)，如果第二维度相同，其实只需要留下 (1, 1)。相当于又建了一个先按第二列排序再第一列排序，与上面的反过来了。复杂不好理解，算了</p>
<p>实际上也就是说，路径不满足最优子结构性质。</p>
<p>关于这点，可以进一步从动态规划那里理解。动态规划告诉我们，假设 k 为 2，其实上面的图我们只需要记录：</p>
<p>(1, 1) 和 (2, 1)</p>
<p>这称为：<strong>分层图最短路。层：节点个数来度量，最短路：仍旧是权值度量</strong>。<strong>实际上就是把动态规划的二维数组画成了图</strong>，然后用图的最短路径算法优化数组的递推过程。（spfa 算法、dijkstra 算法）</p>
<p>本质上，经典的松弛操作中最短路径估计只有一个值是因为它满足最优子结构性质，这也是 dijkstra 算法得以提出的原因，而值得注意的是，另外两种算法并非贪心的，它们需要看所有的边，但是它们需要维护的最短路径估计仍旧只有一个值。</p>
<p>对于另外两个算法，实际上遍历了源结点到当前节点所有路径，然后维护最小值为最短路径，容易修改为<strong>记录所有路径，而不是只记录最小值。</strong></p>
<p>P1144 最短路计数 ，类似上面，从遍历所有路径的角度入手，而不是只记录一条最短路径，先构造递推图，对递推图看能否用最短路径算法</p>
<p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30136932/">算法竞赛进阶指南 (豆瓣) (douban.com)</a></p>
<h4 id="1489-找到最小生成树里的关键边和伪关键边"><a href="#1489-找到最小生成树里的关键边和伪关键边" class="headerlink" title="1489. 找到最小生成树里的关键边和伪关键边"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/">1489. 找到最小生成树里的关键边和伪关键边</a></h4><p>最短路拆点问题（注意 点权、边权 的概念）</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tweetuzki/p/10422496.html">拆点和拆边 - Tweetuzki - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/graph/node/">拆点 - OI Wiki (oi-wiki.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/acm_cxq/article/details/52704823">(5条消息) CSU 1808 地铁（拆点最短路）_acm_cxq的博客-CSDN博客</a></p>
<p>公交路线问题</p>
<p><a target="_blank" rel="noopener" href="https://www.codeleading.com/article/17523484706/">AcWing 383. 观光 ( dijkstra拆点求最短路数) - 代码先锋网 (codeleading.com)</a></p>
<h4 id="LCP-35-电动车游城市"><a href="#LCP-35-电动车游城市" class="headerlink" title="LCP 35. 电动车游城市"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/DFPeFJ/">LCP 35. 电动车游城市</a></h4><h3 id="广度优先搜索-1"><a href="#广度优先搜索-1" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><h4 id="相关题目-2"><a href="#相关题目-2" class="headerlink" title="相关题目"></a>相关题目</h4><h4 id="847-访问所有节点的最短路径"><a href="#847-访问所有节点的最短路径" class="headerlink" title="847. 访问所有节点的最短路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/">847. 访问所有节点的最短路径</a></h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/snakes-and-ladders/">909. 蛇梯棋</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247487179&amp;idx=1&amp;sn=e30a662c03fba3861254dbcf3fb9d6f2&amp;chksm=fd9ca5d4caeb2cc205804fd17a2ce86b25d0408adc3417e73154f59d37e7cb17e02374f5122c&amp;scene=178&amp;cur_album_id=1917113998693449732#rd">1162. 地图分析</a> </p>
<p>对于本题，如果用「单源最短路径」的方法，我们需要对每个「海洋」位置做一次 BFS：求得每个「海洋」的最近陆地距离，然后在所有的距离中取最大值作为答案。</p>
<p>以本题为例，题面要我们求每个「海洋」区域到最近的「陆地」区域的最大值。</p>
<ul>
<li>首先，我们可以想象存在一个「虚拟源点」，其与所有「真实源点」（陆地）存在等权的边，那么任意「海洋」区域与「最近的陆地」区域的最短路等价于与「虚拟源点」的最短路径，</li>
<li>于是，问题转化为：所有「海洋」位置到「虚拟源点」的最短路径权值的最大值，这是一个<strong>单目的地最短路径问题</strong></li>
<li>于是，可以根据单目的地最短路径问题的思路进行解决，把「虚拟源点」当作源节点，所有海洋位置当作目的节点。</li>
</ul>
<p>值得注意的是，实现上，我们并不需要真的将这个「虚拟源点」建立出来，因为，从该节点出发能够等距地到达所有陆地节点，因为我们可以略去「源结点入队列」这步初始操作，而直接到下一步操作「源结点能到达的子节点入队列」，也就是，在一开始让所有的「陆地」节点入队列。</p>
<h3 id="深度优先搜索-1"><a href="#深度优先搜索-1" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h1 id="所有节点对的最短路径"><a href="#所有节点对的最短路径" class="headerlink" title="所有节点对的最短路径"></a>所有节点对的最短路径</h1><p>|V|次单源最短路径，每次选择新的源点。</p>
<p>值得注意的是，如果是无向图，设一开始源点为 a，a 到 b 的最短路径都已找到，则 b 到 a 的最短路径是相同的，因此，以 b 为源点时，不需要再求 b 到 a 的最短路径</p>
<p><strong>以下两种算法本质上是基于动态规划的算法</strong>。</p>
<p>第一节讨论如何用基于矩阵乘法的动态规划算法进行求解，如果使用二分优化，时间复杂度为 O(V^3^logV)；第二节给出另外一种动态规划算法 Floyd-Warshall 算法，其时间复杂度为 O(V^3^)，同时还讨论如何在有向图中找出传递闭包的问题。</p>
<blockquote>
<p>这里的 V 表示节点个数</p>
<p>Johnson 算法的时间复杂度为 O(V^2^logV+VE)，适用于大型稀疏图，见《算法导论》</p>
</blockquote>
<p>本章的图仍旧用邻接矩阵表示。在开始前，给出邻接矩阵表示的一些约定。设图 G=(V, E)，记节点个数 n=|V|。其次，用带有括号的上标表示递推关系。</p>
<h2 id="最短路径和矩阵乘法"><a href="#最短路径和矩阵乘法" class="headerlink" title="最短路径和矩阵乘法"></a>最短路径和矩阵乘法</h2><h3 id="递推式分析"><a href="#递推式分析" class="headerlink" title="递推式分析"></a>递推式分析</h3><p>设 $l_{ij}^{(m)}$ 为从节点 i 到节点 j 的<strong>至多</strong>包含 m 条边的任意路径中的最小权重。也就是说，比较这几个权重：包含 0 条边的最短路径权重、包含 1 条边的最短路径权重、…、包含 m 条边的最短路径权重.</p>
<p>易知，当 m=0 时，</p>
<script type="math/tex; mode=display">
l_{ij}^{(0)}=\left\{\begin{matrix}
0 & if \ i==j\\ 
INF & else
\end{matrix}\right.</script><p>对于 m&gt;=1，我们需要计算的是 $l_{ij}^{(m-1)}$，即从 i 到 j 最多由 m-1 条边组成的任意路径中的最小权重；和从 i 到 j 最多由 m 条边组成的任意路径的最小权重</p>
<script type="math/tex; mode=display">
l_{ij}^{(m)}=\left \{l_{ij}^{(m-1)},\ \underset{1<=k<=n}{min}\left \{l_{ik}^{(m-1)}+w_{kj}  \right \}\right \}=\underset{1<=k<=n}{min}\left \{l_{ik}^{(m-1)}+w_{kj}  \right \}</script><p>可以这样理解这个式子，我们已经有了 $l<em>{ij}^{(m-1)}$，即已经比较了这几个权重：包含 0 条边的最短路径权重、包含 1 条边的最短路径权重、…、包含 m-1 条边的最短路径权重，因此我们实际上只需要从节点 i 到节点 j 包含 m 条边的最短路径权重，这个值包含在第二项中，即包含在这一项 $\underset{1&lt;=k&lt;=n}{min}\left {l</em>{ik}^{(m-1)}+w<em>{kj}  \right }$ 当中，不仅如此，这一项也包含了 $l</em>{ij}^{(m-1)}$。</p>
<h3 id="最短路径分析"><a href="#最短路径分析" class="headerlink" title="最短路径分析"></a>最短路径分析</h3><p>当图 G 不包含权重为负值的环路，满足</p>
<script type="math/tex; mode=display">
\begin{align*}
\delta (i,j)&=l_{ij}^{n-1} \\
l_{ij}^{n-1}&=l_{ij}^{n}=l_{ij}^{n+1}=...
\end{align*}</script><p>式1，最短路径是简单路径，即对于图 G 中任意一条最短路径，其包含的边最多为 n-1 条</p>
<p>式2，当包含 n 条边以上时，一定不是最短路径。易知，$l<em>{ij}^{n}$ 比 $l</em>{ij}^{n-1}$ 多出来的项都比 $l_{ij}^{n-1}$ 大</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="递推式效率优化"><a href="#递推式效率优化" class="headerlink" title="递推式效率优化"></a>递推式效率优化</h4><p>由单个元素的递推式 $l<em>{ij}^{(m)}=\underset{1&lt;=k&lt;=n}{min}\left {l</em>{ik}^{(m-1)}+w<em>{kj}  \right }$ 容易推广到矩阵的递推式。设节点编号从 1 开始，一共 n 个节点，可以用  $L^{(m-1)}==(l</em>{ij}^{(m-1)})$ 得到 $L^{(m)}=(l_{ij}^{(m)})$，其中 $i,j\epsilon [1,n]$</p>
<p><img src="/2022/04/27/graph-alg/image-20220513203457788.png" alt></p>
<p>代码中，输入参数 L 即表示 $L^{(m-1)}$，返回值 L^’^ 即表示 $L^{(m)}$</p>
<p>现在来观察单个元素的递推式，我们将它与矩阵乘法的递推式进行比较，矩阵乘法递推式为：</p>
<script type="math/tex; mode=display">
c_{ij}=\sum_{k=1}^{n}a_{ik}\cdot b_{kj}</script><p>可以从向量的角度来描述，设矩阵 A 是行向量集合 ${α<em>{1},α</em>{2},…,α<em>{n}}$，矩阵 B 是列向量集合 ${β</em>{1},β<em>{2},…,β</em>{n}}$，则 $c<em>{ij}=α</em>{i}β_{j}$</p>
<p>容易发现，为了得到下标为 ij 的元素，两个递推式需要遍历的情况是一样的，即 (ik, kj)，于是，可以令向量乘法表示一个新的计算，即</p>
<script type="math/tex; mode=display">
c_{ij}=α_{i}β_{j}=\underset{1<=k<=n}{min}\left \{a_{ik}+b_{kj}  \right \}</script><p>式中，把上标 m 和 m-1 略去，不影响。或者可以定义一个新的符号，用来表示两个向量的这种计算。</p>
<p>于是，可以用矩阵乘法来等效对 $L^{(m)}$ 的计算，即定义：</p>
<script type="math/tex; mode=display">
L^{(m)}=L^{(m-1)}\cdot W</script><p>于是可以用 dot 作为运算符，等效表示 EXTEND-SHORTEST-PATHS(L, W) 函数。并且有：</p>
<script type="math/tex; mode=display">
\begin{align*}
L^{(1)}&=L^{(0)}\cdot W=W \\
L^{(2)}&=L^{(1)}\cdot W=W^{2} \\
...\\
L^{(n-1)}&=L^{(n-2)}\cdot W=W^{n-1}

\end{align*}</script><h4 id="最短路径权重矩阵求解"><a href="#最短路径权重矩阵求解" class="headerlink" title="最短路径权重矩阵求解"></a>最短路径权重矩阵求解</h4><p>本节中，用 dot 作为运算符，等效表示 EXTEND-SHORTEST-PATHS(L, W) 函数。</p>
<p>实际上，我们需要求的只有 $L^{(n-1)}=W^{n-1}$，因此可以二分递归求解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求解 W^&#123;k&#125;</span></span><br><span class="line"><span class="type">int</span>[][] getL(W, k)&#123;</span><br><span class="line">	<span class="keyword">if</span>(k%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span>[][] tmp = getL(W, k/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp dot tmp; <span class="comment">// 矩阵乘法，注意这里的 dot 运算是等效运算，而非原本的矩阵乘法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getL(W, k-<span class="number">1</span>) dot W; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考对快速幂算法的优化，容易将上述递归过程转化为递推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求解 W^&#123;k&#125;</span></span><br><span class="line"><span class="type">int</span>[][] quickGetL(W, k)&#123;</span><br><span class="line">    <span class="type">int</span>[][] ans = ..; <span class="comment">// ans 初始值满足 ans dot W = W</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[][] W_contribute = W;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;<span class="comment">// 遍历二进制位，递推 W_contribute</span></span><br><span class="line">        <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            ans = ans dot W;</span><br><span class="line">        </span><br><span class="line">        W_contribute = W_contribute dot W_contribute;</span><br><span class="line">        k &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据最短路径分析一节中的式 2，实际上不需要特定地求出 $L^{(n-1)}=W^{n-1}$，求出任意的 $L^{(k)}=W^{k},k&gt;=n-1$ 都是可以的，这也是算法导论的二分方法。以下只给出递推版本。</p>
<p><img src="/2022/04/27/graph-alg/image-20220513210039959.png" alt></p>
<p><img src="/2022/04/27/graph-alg/image-20220511144236814.png" alt="image-20220511144236814"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a></p>
<h4 id="最短路径树"><a href="#最短路径树" class="headerlink" title="最短路径树"></a>最短路径树</h4><h2 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h2><p>假定图 G 的结点索引从 1 到 n，考虑一个节点的子集 {1, 2, …, k}，这里的 k 是某个小于 n 的整数。</p>
<h3 id="递推式分析-1"><a href="#递推式分析-1" class="headerlink" title="递推式分析"></a>递推式分析</h3><p>对于任意结点对 (i, j)，考虑从结点 i 到结点 j 的所有⌊中间结点均取自集合 {1, 2, …, k} 的路径⌉，并且设 p 为其中权重最小的路径（易知路径p 是简单路径）</p>
<ul>
<li><p>如果结点 k 不是路径 p 上的中间结点，则路径 p 上的所有中间结点都属于集合 {1, 2, …, k-1}。因此，从结点 i 到结点 j 的⌊中间结点均取自集合 {1, 2, …, k} 的<strong>一条最短</strong>路径⌉也是从结点 i 到结点 j 的⌊中间结点均取自集合 {1, 2, …, k-1} 的一条<strong>最短</strong>路径⌉</p>
<blockquote>
<p>注意到是 一条 最短路径，因为这里我们只关心最短路径的权重，不关心路径结构</p>
</blockquote>
</li>
<li><p>如果结点 k 是路径 p 上的中间结点，则将路径 p 分解为 $i\overset{p1}{\rightarrow}k\overset{p2}{\rightarrow}j$，其中，</p>
<ul>
<li>p1 表示从结点 i 到结点 k 的⌊中间结点均取自集合 {1, 2, …, k} 的一条<strong>最短</strong>路径⌉</li>
<li><p>p2 表示从结点 k  到结点 j 的⌊中间结点均取自集合 {1, 2, …, k} 的一条<strong>最短</strong>路径⌉</p>
<p>事实上，可以进一步得出结论。因为结点 k 不是路径 p1 上的中间结点，即路径 p1 上所有中间结点属于集合 {1, 2, …, k-1}，因此，</p>
</li>
<li><p>p1 是从结点 i 到结点 k 的⌊中间结点均取自集合 {1, 2, …, k-1} 的一条<strong>最短</strong>路径⌉。</p>
</li>
<li>同理有，p2 是从结点 k 到结点 j 的⌊中间结点均取自集合 {1, 2, …, k-1} 的一条<strong>最短</strong>路径⌉</li>
</ul>
<p><img src="/2022/04/27/graph-alg/image-20220520204358385.png" alt></p>
</li>
</ul>
<p>综上，我们可以给出最短路径估计的递归公式。设 $d_{ij}^{(k)}$ 为从结点 i 到结点 j 的 ⌊中间结点均取自集合 {1, 2, …, k} 的一条<strong>最短</strong>路径⌉ 的权重，则：</p>
<script type="math/tex; mode=display">
d_{ij}^{(k)}=\left\{\begin{matrix}
w_{ij} & if\ k==0\\ 
min(d_{ij}^{(k-1)},\ d_{ik}^{(k-1)}+d_{kj}^{(k-1)}) & if\ k\geq 1 
\end{matrix}\right.</script><blockquote>
<p>这里说递归而非递推，因为公式的输入上标是 k-1，输出上标是 k</p>
</blockquote>
<p>对于任何路径来说，所有的中间结点都属于集合 {1, 2, …, n}，因此，矩阵 $D^{(n)}=(d<em>{ij}^{(n)})$ 就是最终的答案，对于所有的结点 i，j，$d</em>{ij}^{(n)}$ 就是结点 i 和结点 j 的最短路径权重 $\delta (i,j)$</p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="最短路径权重矩阵求解-1"><a href="#最短路径权重矩阵求解-1" class="headerlink" title="最短路径权重矩阵求解"></a>最短路径权重矩阵求解</h4><p>将上述递归公式用递推的方式实现，伪代码如下，算法返回的是最短路径权重矩阵 $D^{(n)}$</p>
<p><img src="/2022/04/27/graph-alg/image-20220511165156848.png" alt></p>
<p>算法的时间复杂度为 O(N^3)</p>
<h4 id="最短路径树-1"><a href="#最短路径树-1" class="headerlink" title="最短路径树"></a>最短路径树</h4><p>某些值得注意的点</p>
<p>由最短路径权重构造最短路径树的方法</p>
<p>导论中构造最短路径的方法似乎对于两个结点只能求得一条最短路径，而不能求出所有最短路径</p>
<p>上述两种方法如何稍作修改求出所有最短路径</p>
<h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/25/DSU/" rel="prev" title="并查集 DSU">
      <i class="fa fa-chevron-left"></i> 并查集 DSU
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/29/%E9%80%92%E5%BD%92%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="next" title="递归处理字符串">
      递归处理字符串 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">1.</span> <span class="nav-text">图的存储</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">图的搜索遍历方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">2.1.</span> <span class="nav-text">广度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%AE%BF%E9%97%AE-NULL-%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.1.</span> <span class="nav-text">遍历过程中访问 NULL 节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.1.2.</span> <span class="nav-text">层序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">2.2.</span> <span class="nav-text">深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">回溯算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8-1"><span class="nav-number">3.1.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="nav-number">3.2.</span> <span class="nav-text">相关题目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">强连通分量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kruskal-%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">Kruskal 算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prim-%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">Prim 算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">6.</span> <span class="nav-text">单源最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%BE%E5%BC%9B%E6%93%8D%E4%BD%9C"><span class="nav-number">6.1.</span> <span class="nav-text">松弛操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%85%B7%E6%9C%89%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">6.2.</span> <span class="nav-text">最短路径具有的性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%8F%98%E4%BD%93%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.</span> <span class="nav-text">单源最短路径的变体问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.</span> <span class="nav-text">单源最短路径算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BELLMAN-FORD-%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.1.</span> <span class="nav-text">BELLMAN-FORD 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shortest-Path-Faster-%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.2.</span> <span class="nav-text">Shortest Path Faster 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dag-Shortest-Paths-%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.3.</span> <span class="nav-text">Dag-Shortest-Paths 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra-%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.4.</span> <span class="nav-text">Dijkstra 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-1"><span class="nav-number">6.4.4.1.</span> <span class="nav-text">相关题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1489-%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%87%8C%E7%9A%84%E5%85%B3%E9%94%AE%E8%BE%B9%E5%92%8C%E4%BC%AA%E5%85%B3%E9%94%AE%E8%BE%B9"><span class="nav-number">6.4.4.2.</span> <span class="nav-text">1489. 找到最小生成树里的关键边和伪关键边</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCP-35-%E7%94%B5%E5%8A%A8%E8%BD%A6%E6%B8%B8%E5%9F%8E%E5%B8%82"><span class="nav-number">6.4.4.3.</span> <span class="nav-text">LCP 35. 电动车游城市</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-1"><span class="nav-number">6.4.5.</span> <span class="nav-text">广度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-2"><span class="nav-number">6.4.5.1.</span> <span class="nav-text">相关题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">6.4.5.2.</span> <span class="nav-text">847. 访问所有节点的最短路径</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-1"><span class="nav-number">6.4.6.</span> <span class="nav-text">深度优先搜索</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">7.</span> <span class="nav-text">所有节点对的最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">最短路径和矩阵乘法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E6%8E%A8%E5%BC%8F%E5%88%86%E6%9E%90"><span class="nav-number">7.1.1.</span> <span class="nav-text">递推式分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90"><span class="nav-number">7.1.2.</span> <span class="nav-text">最短路径分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.1.3.</span> <span class="nav-text">算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E6%8E%A8%E5%BC%8F%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96"><span class="nav-number">7.1.3.1.</span> <span class="nav-text">递推式效率优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%9D%83%E9%87%8D%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3"><span class="nav-number">7.1.3.2.</span> <span class="nav-text">最短路径权重矩阵求解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91"><span class="nav-number">7.1.3.3.</span> <span class="nav-text">最短路径树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Floyd-Warshall"><span class="nav-number">7.2.</span> <span class="nav-text">Floyd-Warshall</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E6%8E%A8%E5%BC%8F%E5%88%86%E6%9E%90-1"><span class="nav-number">7.2.1.</span> <span class="nav-text">递推式分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">7.2.2.</span> <span class="nav-text">算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%9D%83%E9%87%8D%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3-1"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">最短路径权重矩阵求解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91-1"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">最短路径树</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="nav-number">8.</span> <span class="nav-text">最大流</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cyl"
      src="/images/icon1.jpg">
  <p class="site-author-name" itemprop="name">Cyl</p>
  <div class="site-description" itemprop="description">顽童大了别那么笨</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cyl</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.1/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'bj1pUPUVv7CB9DzNJpPiyH5u-gzGzoHsz',
      appKey     : 'RQWkhgEzgN0MjSY1E3rSiuJc',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '9' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>

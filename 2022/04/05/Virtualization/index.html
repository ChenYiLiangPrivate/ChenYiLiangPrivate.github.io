<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="操作系统的虚拟化技术包括虚拟地址空间、虚拟 CPU 虚拟地址空间主要是为了提供一个易用的物理内存抽象，实现内核与用户、进程与进程空间的隔离；虚拟化 CPU 包括 CPU 模式和中断切换，主要是为了实现对系统的安全访问和多进程的并行">
<meta property="og:type" content="article">
<meta property="og:title" content="虚拟化">
<meta property="og:url" content="http://example.com/2022/04/05/Virtualization/index.html">
<meta property="og:site_name" content="缘溪行">
<meta property="og:description" content="操作系统的虚拟化技术包括虚拟地址空间、虚拟 CPU 虚拟地址空间主要是为了提供一个易用的物理内存抽象，实现内核与用户、进程与进程空间的隔离；虚拟化 CPU 包括 CPU 模式和中断切换，主要是为了实现对系统的安全访问和多进程的并行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/04/05/Virtualization/1642770176746-362621fb-2a65-447d-a7e6-d0f10f18e8f6.png">
<meta property="og:image" content="http://example.com/2022/04/05/Virtualization/1643438704868-7d431f3d-de31-497f-8400-36fd33dbc504.png">
<meta property="og:image" content="http://example.com/2022/04/05/Virtualization/1643442576051-58a6712b-62dd-4570-abec-25a272edc855.png">
<meta property="og:image" content="http://example.com/2022/04/05/Virtualization/1643691165540-3cc3a1fe-245c-4ffb-997f-90d3987f7e9c.png">
<meta property="og:image" content="http://example.com/2022/04/05/Virtualization/1643693169495-5747d18e-5424-4b59-9b6c-09bdb5590391.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/__puml/19d56db61d9fe6cdb199e9e3e11ab4e7.svg">
<meta property="og:image" content="http://example.com/2022/04/05/Virtualization/1643024036695-ef32003d-a133-42c3-9347-7c8e035b9784.png">
<meta property="og:image" content="http://example.com/2022/04/05/Virtualization/1643033924079-f75ee3ea-89da-44bb-bcfb-b1b8055447d1.png">
<meta property="article:published_time" content="2022-04-05T14:39:49.000Z">
<meta property="article:modified_time" content="2022-04-18T06:23:44.046Z">
<meta property="article:author" content="Cyl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/05/Virtualization/1642770176746-362621fb-2a65-447d-a7e6-d0f10f18e8f6.png">

<link rel="canonical" href="http://example.com/2022/04/05/Virtualization/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>虚拟化 | 缘溪行</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">缘溪行</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">26</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/Virtualization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          虚拟化
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-05 22:39:49" itemprop="dateCreated datePublished" datetime="2022-04-05T22:39:49+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-18 14:23:44" itemprop="dateModified" datetime="2022-04-18T14:23:44+08:00">2022-04-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/05/Virtualization/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/05/Virtualization/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>操作系统的虚拟化技术包括虚拟地址空间、虚拟 CPU</p>
<p>虚拟地址空间主要是为了提供一个易用的物理内存抽象，实现内核与用户、进程与进程空间的隔离；虚拟化 CPU 包括 CPU 模式和中断切换，主要是为了实现对系统的安全访问和多进程的并行</p>
<span id="more"></span>
<h1 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h1><p>以 32 位操作系统举例，它的寻址空间为 4G = 2 的 32 次方，一个字节大小的内存单元对应一个地址</p>
<p>为什么叫虚拟，因为物理内存一共就 4G，但操作系统为<strong>每一个进程都分配了4G的内存空间，这个内存空间是虚拟的</strong>。以 linux 操作系统为例，每个进程 4G 的虚拟内存，将最高的 1G 字节供内核使用，称为内核空间，而将较低的 3G 字节，供各个进程使用，称为用户空间。</p>
<blockquote>
<p>如果你在一个程序中打印出一个地址，那只是一个虚拟地址。虚拟地址只是提供地址如何在内存中分布的假象，只有操作系统（和硬件）才知道物理地址。</p>
</blockquote>
<h2 id="虚拟地址空间的构成"><a href="#虚拟地址空间的构成" class="headerlink" title="虚拟地址空间的构成"></a>虚拟地址空间的构成</h2><p>包括内核空间和用户空间，如下图所示。</p>
<p><img src="/2022/04/05/Virtualization/1642770176746-362621fb-2a65-447d-a7e6-d0f10f18e8f6.png" alt="内核空间和用户空间"></p>
<h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>与进程相关的数据结构。例如<strong>页表、进程控制块、内核栈</strong>等。</p>
<ul>
<li>不同的进程共享同一个内核空间，这表示：所有进程内核空间映射到同一个物理地址空间</li>
<li>不同的进程在内核空间中的页表、PCB 和内核栈等资源独立，而共享内核空间中的内核代码和内核数据等。<ul>
<li>每个进程的页表管理的空间包含用户空间和内核空间，页表管理的内核空间可以帮助进程找到自己在内核空间中独立的那部分资源（即 PCB、内核栈等）</li>
<li>进程 A 切换到进程 B 时把进程信息 PCBA 压入内核栈 A，进程 B 切换到进程 C 时把进程信息 PCBB 压入内核栈 B。</li>
<li>内核代码所使用的栈是进程的内核栈，并且，各个进程的内核栈是独立的，也就是说，操作系统在各个进程中锁表现的状态是不一样的。</li>
</ul>
</li>
</ul>
<h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><p>代码：编译链接生成的可执行文件是汇编指令，汇编指令以二进制形式装载到内存中，每条指令可用几个字节存储。</p>
<p>栈：存放临时变量。通过栈的推入和弹出处理临时变量</p>
<p>堆：非局部变量生命周期较长，通常很多个方法中都会用到，由程序员自主使用内存 API 函数分配回收。</p>
<p>静态区（全局区）：存储全局变量和静态变量，分为初始化和未初始化两个分区。</p>
<blockquote>
<p>图示堆栈生长方式只是一种约定，当多个线程（threads）在地址空间中共存时，就没有像这样分配空间的好办法了</p>
<p><strong>虚拟空间地址连续，会映射到不连续的物理空间</strong></p>
</blockquote>
<h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><p>操作系统是一个程序，但不能称作进程。它管理着进程，进程是有生命周期的，操作系统是永存的。<strong>操作系统的运行也同样要占用CPU</strong></p>
<p>在操作系统这个程序中，为了跟踪每个进程的状态，使用了如下数据结构</p>
<ul>
<li>进程控制块（PCB， process control block）</li>
<li>进程列表（process list）</li>
</ul>
<p>如下是一个进程控制块，进程控制块包括了上下文信息、进程状态和为进程分配的内存、文件资源等信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寄存器上下文（register context）</span></span><br><span class="line"><span class="comment">// the registers xv6 will save and restore </span></span><br><span class="line"><span class="comment">// to stop and subsequently restart a process </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span> </span><br><span class="line">  <span class="type">int</span> eip; </span><br><span class="line">  <span class="type">int</span> esp; </span><br><span class="line">  <span class="type">int</span> ebp; </span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> ebx; </span><br><span class="line">  <span class="type">int</span> ecx; </span><br><span class="line">  <span class="type">int</span> edx; </span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> esi; </span><br><span class="line">  <span class="type">int</span> edi; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 进程状态枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span> UNUSED, EMBRYO, SLEEPING, </span><br><span class="line">                  RUNNABLE, RUNNING, ZOMBIE &#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// the information xv6 tracks about each process </span></span><br><span class="line"><span class="comment">// including its register context and state </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span> </span><br><span class="line">	<span class="comment">// 内存设置</span></span><br><span class="line">  <span class="type">char</span> *mem;                   <span class="comment">// Start of process memory </span></span><br><span class="line">  uint sz;                     <span class="comment">// Size of process memory </span></span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> *kstack;                <span class="comment">// Bottom of kernel stack </span></span><br><span class="line">                               <span class="comment">// for this process </span></span><br><span class="line">                              </span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>       <span class="comment">// Process state </span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process </span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan </span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed </span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory </span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// // 上下文切换 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>        <span class="comment">// Trap frame（栈帧） for the current interrupt</span></span><br><span class="line">                               <span class="comment">// 栈帧也是一个包含多个寄存器的结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="内核空间和用户空间的切换"><a href="#内核空间和用户空间的切换" class="headerlink" title="内核空间和用户空间的切换"></a>内核空间和用户空间的切换</h3><p>发生系统调用时进行的是模式切换而非进程切换。</p>
<p><strong>模式切换</strong>：仅仅需要寄存器进栈出栈，不会导致 CPU 中的数据缓存失效、MMU 中的页表缓存失效</p>
<p><strong>进程切换</strong>：不仅需要寄存器进栈出栈，还会使 CPU 中的数据缓存失效、MMU 中的页表缓存失效（缓存失效是必须的，因为要切换到另一个进程的地址空间）</p>
<blockquote>
<p>代码里面具有各个语句和各个变量的虚拟地址，当进程切换之后，页表也会更新，根据自己进程的页表来找物理内存</p>
</blockquote>
<p>虚拟地址空间切换实际上指的是用户空间的切换，通过切换页表来实现。页表切换后 TLB 就失效了，页表缓存失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致 TLB 失效，因为线程无需切换地址空间。</p>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>调度：进程是资源管理的基本单位，线程是程序执行的基本单位。</p>
<p>系统开销：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O 设备等。创建线程：内核空间分配 TLB 等，用户空间分配栈。</p>
<p>进程切换分两步：</p>
<ol>
<li>切换页表以使用新的地址空间，这会导致 TLB 失效。</li>
<li>切换内核栈和硬件上下文（例如进程控制块和线程控制块）。</li>
</ol>
<p>对于线程切换，第 1 步是不需要做的，因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，第 2 步是进程和线程切换都要做的。</p>
<h3 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h3><p>程序中调用时发生系统调用</p>
<p>fork</p>
<ul>
<li>一个现有进程可以调用 fork() 创建一个新进程，该新进程被称为<strong>子进程</strong>（child process），调用fork的进程称为<strong>父进程</strong>。</li>
<li><p>子进程通过拷贝的方式，获得 此时的 父进程地址空间副本（包括堆、栈等资源）。</p>
</li>
<li><ul>
<li>父进程处于等待 fork 返回的状态。因此，子进程复制之后，在 fork() 被调用之前的代码不会被执行，且两个进程都停留在 fork 函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回<ul>
<li>子进程中返回 0，而父进程中返回子进程 ID。</li>
</ul>
</li>
</ul>
</li>
<li><p>作用：运行相同程序的拷贝</p>
</li>
</ul>
<p>exec</p>
<ul>
<li><p>exec指的是一个函数簇，包括execlp()、execv()和execvp()等</p>
</li>
<li><p>函数原型：</p>
<p>  int execvp(const char <em>file, char </em>const argv[]); // file为需要运行的文件名，argv[]为输入的参数列表</p>
</li>
<li><p>给定可执行程序的名称及该程序需要的参数后，exec() 会从该程序中加载代码和静态数据，并用它 <strong>覆写</strong> 自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新<strong>初始化</strong>。然后操作系统就执行该程序，将参数 argv 传递给该进程。——并没有创建新进程，而是直接将当前运行的程序替换为另一个程序</p>
</li>
<li>调用了 exec() 的程序，exec() 之后的语句不会被执行</li>
</ul>
<h2 id="虚拟地址到物理地址的映射"><a href="#虚拟地址到物理地址的映射" class="headerlink" title="虚拟地址到物理地址的映射"></a>虚拟地址到物理地址的映射</h2><p>一个基本的负责地址转换的<strong>内存管理单元</strong>（Memory Management Unit，MMU）需要包含：<strong>基址寄存器、界限寄存器</strong>。</p>
<ul>
<li>基本的映射方法：基址 + 偏移</li>
<li>每个进程分配的空间有限，并且不能访问别人的空间，因此需要<strong>界限寄存器</strong></li>
</ul>
<p>如果只使用基址和界限，为进程分配一块连续的物理内存，容易产生<strong>内部碎片</strong>（internal fragmentation），指的是<strong>已经分配的内存单元内部有未使用的空间</strong>（即碎片），造成了浪费。主要是堆栈空间冗余。</p>
<p>进程需要把用到的基址和界限寄存器中的内容保存在内存中，放在某种每个进程都有的结构中，例如进程控制块（Process Control Block，PCB）中。类似地，当操作系统恢复执行某个进程时（或第一次执行），也必须给基址和界限寄存器设置正确的值。</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>为了减少内部碎片，可以采用<strong>分段</strong>（segmentation）的方法为进程分配内存。分段法将用户空间看成几个段的组合，每个段具有自己的基址和界限，不同段分配的空间可以不连续。</p>
<p><img src="/2022/04/05/Virtualization/1643438704868-7d431f3d-de31-497f-8400-36fd33dbc504.png" alt="段寄存器"></p>
<p>注意到栈向低地址生长，地址范围 28 KB ~ 26 KB。其他段向高地址生长。如果试图访问的虚拟地址不在段内，会发生段异常（segmentation violation）或段错误（segmentation fault）</p>
<p>分段只能减少内部碎片，而不能完全避免内部碎片，总得多分配一点保证程序运行。</p>
<p>分段的问题</p>
<ul>
<li><p>分段操作相关的寄存器在每次 cpu 模式切换时需要存储和恢复</p>
</li>
<li><p>段不连续且不均匀分配，导致物理内存在各个位置充满大小不一致的碎片，因而很难将物理内存分配给新的段，或扩大已有的段。这种问题被称为<strong>外部碎片</strong>。</p>
<blockquote>
<p>解决方法：紧凑、空闲列表管理</p>
</blockquote>
</li>
</ul>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>为虚拟空间分配物理内存时以页（page）为单位分配。即将虚拟空间分成多个页，每个页对应一个物理帧。</p>
<p>页表（page table）保存了<strong>页</strong>（<strong>虚拟</strong>地址空间）和物理帧（<strong>物理内存</strong>空间）的映射关系。</p>
<blockquote>
<p>物理帧不是硬盘空间/外存的单元 </p>
</blockquote>
<p>虚拟页面号（virtual page number，VPN）和页内的偏移量（offset）组成一个虚拟地址。假设进程的虚拟地址空间是 64 字节，每页大小 16 字节，共 4 个页。那么虚拟地址需要用 6 位描述，前两位是虚拟页号（VPN），用来区分不同的页，后四位区分一个页中的不同字节。例如，虚拟地址 = 010101，VPN=1，offset=5，表示第 1 页第5 个字节。</p>
<p>操作系统会将物理内存分成多个物理帧，物理帧和帧内的偏移量组成一个物理地址。假设第 1 页对应的物理帧号是 7，如图所示。则虚拟地址 010101 对应的物理地址是 112+5 = 117 = 1110101（图中物理帧 0~15，16~31，…）</p>
<p><img src="/2022/04/05/Virtualization/1643442576051-58a6712b-62dd-4570-abec-25a272edc855.png" alt="虚拟页与物理帧的对应关系"></p>
<p>页表是一个数据表，进程创建时由操作系统为其生成对应页表（分配物理内存空间）。页表由页表项（<strong>PTE</strong>）组成，第 i 个页表项存储了 VPN = i 的虚拟页的信息，包括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>物理帧号 PFN</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>有效位</td>
<td>是否为该虚拟页分配物理帧</td>
</tr>
<tr>
<td>存在位（present bit）</td>
<td>表示该页是否被调入内存中（有可能暂存硬盘），=1表示被调入内存</td>
</tr>
<tr>
<td>脏位（dirty bit）</td>
<td>表示页面在调入内存后是否被修改过，供时钟置换算法及调出页面时是否要回写到外存后是否被</td>
</tr>
<tr>
<td>参考位（reference bit，也被称为访问位，accessed bit）</td>
<td>记录本页一段时间内的访问次数，或记录本页多久未被访问</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>如果有效位是1，该PTE中就会存储物理内存中相应的物理页的起始地址。如果有效位是0，且PTE中的地址为null，这表示这个虚拟页还未被分配，而如果有效位是0且PTE中有地址，那么这个地址指向该虚拟页在磁盘上的起始位置</p>
<p>用有效位和存在位一起判断？</p>
</blockquote>
<p><strong>页表在内核空间中</strong>。如果页表在用户空间，那么用户就可能自己修改页表，从而访问任何内存（其他进程专用的、操作系统专用的）</p>
<p>页式访问机制会产生两个问题</p>
<ul>
<li><p>内存访问性能：访问一个内存单元需要2次内存访问，第一次访问页表，确定数据的物理地址，第二次访问数据。访问页表的步骤可以加速。</p>
</li>
<li><p>页表大小：页表可能很大，占据大量内存，导致内存利用效率降低。</p>
</li>
</ul>
<p><strong>快表</strong></p>
<p>为了改善内存访问性能，利用局部性原理加速访问页表的步骤——将常访问的页面保存至 CPU 缓存，该缓存称为<strong>地址变换高速缓存</strong>（Translation Look-aside Buffer，TLB），又可称为快表。配置快表后，CPU 访问页面会先去查看快表内是否存在，然后再去查看主存的页表。</p>
<p>例：某一页式系统，其页表存放在主存中：</p>
<p>(1) 如果对主存的一次存取需要 1.5μs，试问实现一次页面访问时存取时间是多少？</p>
<p>答：页式访问需要访存两次，一次页表，一次数据，所以需要 1.5∗2=3μs。</p>
<p>(2)如果系统有快表且其平均命中率为 85%，而页标项在快表查询的时间可忽略不计，试问此时的存取时间为多少？</p>
<p>答：快表命中时访存一次，未命中时访存两次，所以需要 0.85∗1.5+0.15∗3=1.725μs。（0.85概率找到页表项，0.15概率没有找到页表项，此时需要到主存的页表再去找）</p>
<p><strong>多级页表</strong></p>
<p>页表大小问题可以通过多级页表的方法优化。</p>
<p>分割：将庞大的页表分成多张较小的页表，并设置一张页目录表。逻辑地址的虚页号进一步划分为页目录号和虚页号，页目录号用于查询页表，虚页号用于查询物理帧号。</p>
<p>按需调入：进程执行开始时只需要将页目录表调入内存，然后次级页表和页面可以在后面执行需要时再调入。同时，</p>
<p>假设有 256 个虚拟页，可以拆分为 16*16 个部分，以 16 个页表项为一页（这里是页表页，而不是之前的虚拟页）。虚页号此时是 相对虚页号，即 16 个页 0~15，而非绝对虚页号，即 256 个页 0~255</p>
<h4 id="页面置换算法-cache淘汰算法"><a href="#页面置换算法-cache淘汰算法" class="headerlink" title="页面置换算法/cache淘汰算法"></a>页面置换算法/cache淘汰算法</h4><p>什么是交换空间？</p>
<p>用于与内存换入换出的硬盘空间。操作系统把物理内存进行分页。当内存资源不足时，把某些页的内容转移至硬盘上的一块空间上，以释放内存空间。硬盘上的那块空间叫做交换空间（swap space）,而这一过程被称为交换。物理内存和交换空间的总容量就是虚拟内存的可用容量</p>
<p>在程序运行过程中，如果要访问的页面不在内存中（根据页表项的存在位判断），就发生缺页中断从而将该页调入内存中。此时</p>
<ul>
<li><strong>如果内存已无空闲空间</strong>，CPU通知操作系统将暂时不用的页面 <strong>换出</strong> 到外存，将腾出的内存分配给要访问的页面，要访问的页面在外存，需要将其重新 <strong>换入</strong> 内存。</li>
<li>如果内存有空闲物理页帧，操作系统将页面装入内存，并页表项填入页帧号，存在位修改为1</li>
</ul>
<blockquote>
<p>生成进程时，就要为所有页面分配物理帧，也会发生缺页中断。因此，要访问的页面不在内存中必定在外存，不会临时再生成</p>
</blockquote>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）</p>
<p><strong>局部页面置换</strong>：置换页面的选择范围仅限于 当前进程 占用的物理页面内（进程内）</p>
<p><strong>最佳置换</strong>（OPT, Optimal replacement algorithm）</p>
<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<p>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1 </p>
<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长</p>
<p><strong>最近最少使用</strong>（LRU, Least Recently Used）</p>
<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最少使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时</p>
<ul>
<li>页面在链表中存在，将这个页面移到链表表头。</li>
<li>页面在链表中不存在，将其插入到表头</li>
</ul>
<p>这样就能保<strong>证链表表尾的页面是最近最久未访问的</strong>。</p>
<p>实现方式：LinkedHashMap（JAVA）,使用哈希表作为缓存，对应的实际上是硬件 TLB</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<p>4，7，0，7，1，0，1，2，1，2，6</p>
<p>上方是表头，设页数上限为5。链表变化过程如图</p>
<p><img src="/2022/04/05/Virtualization/1643691165540-3cc3a1fe-245c-4ffb-997f-90d3987f7e9c.png" alt="LRU 过程示意"></p>
<p><strong>LRU 和 LFU 的优缺点</strong></p>
<p>LRU </p>
<p>优点：实现简单，通常具有高命中率</p>
<p>缺点：如果一些不常使用的数据一次性出现过多，那么链表表头都是无用的数据，从而会导致缓存命中率低下</p>
<p>LFU 缺点</p>
<ul>
<li>需要为每个记录项维护频率信息，带来额外开销</li>
<li>对突发性的稀疏流量无力，因为前期经常访问的记录已经占用了缓存，偶然的流量不太可能会被保留下来，而且过去的一些大量被访问的记录在将来也不一定会使用上，这样就一直把“坑”占着了。</li>
</ul>
<p>LFU优点：如果数据的分布在一段时间内是固定的话，那么LFU可以达到最高的命中率</p>
<p><strong>先进先出</strong></p>
<p>使用队列，最新进入的页面放在表尾，最早进入的页面放在表头。当缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。</p>
<ul>
<li>问题 可能会把有用的页面淘汰掉。（即此时加入的页面之前已存在）</li>
<li>改进 第二次机会算法（SCR，Second Chance Replacement Policy），基于 second chance 位维护最早页面指针</li>
</ul>
<p>第二次机会算法</p>
<p>数据结构：链表、最早页面指针</p>
<p>每个页面有一个 second chance 位，也叫做引用位。上面叫做 参考位/访问位</p>
<p>当一个页面被二次引用，它的 second chance 位设置为1。这表示该页面后面还有可能会被引用到，所以下次置换先跳过这个页面，也就是再给它一次机会留在内存中。这样可以减少页面置换。</p>
<p>步骤</p>
<ul>
<li><p>引用一个界面时，先用一个 遍历指针 从头到尾查找页面在链表中是否存在</p>
</li>
<li><ul>
<li>如果到尾部、未查找到、且有剩余空间，加入页面，它的 second chance 被设置为 0，最早页面指针后移一位<ul>
<li>如果已经分配物理内存/在链表中，它的 second chance 被设置为1</li>
<li>如果到尾部、未查找到、且无剩余空间。需要替换内存中的一个页面，从 <strong>最早页面指针</strong> 往后查找可以被替换的页面：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果页面的 second chance 是1，那么置为0，最早页面指针后移一位；<ul>
<li>如果页面的 second chance 是0，那么将这个页面置换出去，最早页面指针后移一位。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意下图中 最早页面指针（蓝色箭头） 的变化</p>
<p><img src="/2022/04/05/Virtualization/1643693169495-5747d18e-5424-4b59-9b6c-09bdb5590391.png" alt="第二次机会算法"></p>
<h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p><strong>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</strong></p>
<p>虚拟地址空间首先划分为若干个段，每段都有自己的段号，然后每段分成若干个大小固定的页，相应的内存划分为和页面大小的物理帧。</p>
<p>逻辑地址结构</p>
<p>段页式的逻辑地址由段号(segment)、虚页号(virtual page number) 和页内偏移(offset) 组成</p>
<p>硬件支持</p>
<p>段页式存储管理方式的硬件支持包括段表和页表。段表项代表进程的一个段，段表项包括段号、段长，但<strong>段基址实际上是页表基址</strong>。</p>
<p>例如，段基址指向页表的第 2 个页表项，虚页号为 3，则找到第 5 个页表项。虚页号是相对虚页号，而非绝对虚页号。</p>
<h1 id="虚拟-CPU"><a href="#虚拟-CPU" class="headerlink" title="虚拟 CPU"></a>虚拟 CPU</h1><p>采用时分共享，每个进程轮流运行一段时间，进程并发执行，产生有多个 CPU 的假象</p>
<p>安全：在进程占用 CPU 时，对它的权限进行限制；</p>
<p>可控：操作系统能控制进程的运行。时分共享 CPU 方式存在的问题 —— <strong>如果一个进程在CPU 上运行，这就意味着操作系统没有运行。</strong></p>
<p>手段—— <strong>CPU 双模式</strong>（安全）、<strong>控制权转移</strong>（可控）</p>
<h2 id="CPU-双模式"><a href="#CPU-双模式" class="headerlink" title="CPU 双模式"></a>CPU 双模式</h2><p>将操作系统的运行状态分为用户态和内核态，主要是为了<strong>对访问能力进行限制</strong>，防止随意进行一些比较危险的操作导致系统的崩溃</p>
<p><strong>用户模式</strong></p>
<ul>
<li>用户空间——应用程序的代码和数据</li>
<li>可执行非特权指令</li>
</ul>
<p><strong>内核模式</strong></p>
<ul>
<li><p>内核空间——存放的是操作系统内核代码和数据（如进程控制块和进程列表等）</p>
</li>
<li><p><strong>可执行特权指令，可以访问一切内存和寄存器</strong></p>
</li>
<li><p>切换到内核模式的方式——执行系统调用</p>
<p>在用户模式执行系统调用的方式——调用操作系统提供的 API，例如读取文件、创建和销毁进程、与其他进程通信，以及分配更多内存</p>
<p>陷阱表（trap table）记录了相关处理程序的位置。</p>
<p><strong>执行系统调用将发生什么？</strong></p>
<ul>
<li>执行陷阱指令，进入内核模式</li>
<li>保存进程信息（例如进程控制块）到内核栈</li>
<li>查找陷阱表，执行对应处理程序</li>
<li>执行从陷阱返回指令，从内核栈恢复寄存器，回到用户模式</li>
</ul>
</li>
</ul>
<p>当陷入内核，执行的都属于操作系统的程序，相当于操作系统接管了 CPU</p>
<p><img src="https://cdn.nlark.com/yuque/__puml/19d56db61d9fe6cdb199e9e3e11ab4e7.svg" alt></p>
<p>Intel 的 x86 处理器 可以运行在 ring0 ~ ring3 四个不同的权限级别。不过 Linux 和 Windows 只利用了其中的两个运行级别：</p>
<p>内核模式，对应 ring0 级<br>用户模式，对应 ring3 级</p>
<h2 id="控制权转移"><a href="#控制权转移" class="headerlink" title="控制权转移"></a>控制权转移</h2><p>协作方式——程序在最后执行系统调用交还控制权</p>
<p>非协作方式——利用时钟中断重新获得控制权</p>
<p>中断的处理过程</p>
<ol>
<li>保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。</li>
<li>开中断：以便执行中断时能响应较高级别的中断请求。</li>
<li>中断处理</li>
<li>关中断：保证恢复现场时不被新中断打扰</li>
<li>恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态</li>
</ol>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度策略相关概念"><a href="#调度策略相关概念" class="headerlink" title="调度策略相关概念"></a>调度策略相关概念</h3><p><strong>抢占与非抢占</strong></p>
<p>抢占式：当有比正在运行的进程<strong>优先级</strong>更高的进程就绪时，系统可强行剥夺当前运行进程的 CPU 使用权，提供给更高优先级的进程使用。</p>
<p>非抢占式：某一进程被调度运行后，除非自身原因导致不能运行，否则一直运行下去。</p>
<p><strong>I/O 密集型和 CPU 密集型进程</strong></p>
<p>I/O 密集型：需要频繁地进行 I/O 操作的进程。 I/O 操作会阻塞进程</p>
<p>CPU 密集型：需要大量的 CPU 时间进行计算。</p>
<h3 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h3><ul>
<li><p><strong>周转时间</strong>（Turnaround Time）：每个进程从提出请求到运行完成的时间。运行完成时刻 - 任务到达时刻</p>
</li>
<li><p>加权周转时间（Turnaround Time With Weight）：周转时间与实际运行时间的比值。</p>
</li>
<li><p>等待时间：进程处于等待CPU调度的时间之和。</p>
</li>
<li><p><strong>响应时间</strong>：从提出请求到第一次回应的时间。</p>
</li>
<li><p>公平性（Fairness）：保证每个进程都能获得一定程度的CPU时间。</p>
</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>批处理系统没有太多的用户操作，在该系统中，调度算法（即以下四种算法）目标是保证吞吐量和<strong>周转时间</strong>。</p>
<p><strong>先来先服务</strong>（first-come first-serverd，FCFS）</p>
<ul>
<li><strong>非抢占式</strong>，按照请求的顺序进行调度。</li>
<li>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行</li>
</ul>
<p><strong>最短作业优先</strong>（shortest job first，SJF）</p>
<ul>
<li><strong>非抢占式</strong>，按运行时间最短（假设操作系统知道每个任务用时）的顺序进行调度。区别于 STCF</li>
<li>有利于短作业，但不利于长作业。因为如果一直有短作业到来，那么长作业永远得不到调度。</li>
</ul>
<p><strong>最短完成时间优先</strong>（Shortest Time-to-Completion First，STCF）</p>
<ul>
<li><strong>最短作业优先的抢占式版本</strong>。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，<strong>则挂起当前进程，运行新的进程</strong>。否则新的进程等待。</li>
</ul>
<p><strong>最高响应比优先</strong>（Highest Response Ratio Next, HRRN)</p>
<p>是对 FCFS 和 SJF 的综合平衡，调度时计算每个进程的响应比 R ，总是选择 R 最高的进程执行，属于<strong>非抢占式</strong>调度算法。</p>
<p><img src="/2022/04/05/Virtualization/1643024036695-ef32003d-a133-42c3-9347-7c8e035b9784.png" alt></p>
<p>当等待时间相同时，则运行时间越短响应比越高，实现短作业优先（SJF)</p>
<p>当运行时间相同时，等待时间越长响应比越高，实现先来先服务（FCFS）</p>
<p>实际上等价于将调度队列的各个任务按照 R 排序，R 大的在队头。</p>
<h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法（即以下三种算法）的目标是<strong>减少响应时间</strong>。即</p>
<p><strong>时间片轮转</strong>（Round Robin，RR）</p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，<strong>并将它送往就绪队列的末尾</strong>，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的<strong>效率</strong>和<strong>时间片的大小</strong>有很大关系：</p>
<ul>
<li>时间片太小，会导致进程频繁切换，浪费资源。</li>
<li>时间片过长，以至于所有进程都能在一个时间片内执行完毕，则 RR 算法退化成为 FCFS 算法。</li>
</ul>
<p><strong>优先级调度</strong>（Highest Priority First，HPF）</p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>多级反馈队列</strong>（Multi-Level Feedback Queue，MLFQ）</p>
<p>基本思想</p>
<ul>
<li>减少周转时间：通过先执行短工作来实现（SJF），然而，操作系统通常不知道工作要运行多久</li>
<li>减少响应时间：轮转。轮转算法虽然降低了响应时间，周转时间却很差。</li>
</ul>
<p>关键问题：没有工作长度的先验信息，不知道工作要运行多久，如何设计一个能同时减少响应时间和周转时间的调度程序——也就是，让短工作先执行，并且要加入轮转</p>
<p>MLFQ 将刚到的工作假设为短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ近似于SJF</p>
<p>多级反馈队列算法(MLFQ)是 RR 算法和 HPF 算法的综合平衡，<strong>动态调整进程的优先级和时间片大小</strong>，实现思想如下：</p>
<ol>
<li>设置多个就绪队列，并为每个队列赋予不同的优先级，第 1 级队列的优先级最高，第 2 级队列次之，其余队列的优先级逐次降低； 优先级越高的队列，每个进程的运行时间片越小（当作短任务）。即便进程被阻塞，也正常计算其占用时间</li>
<li>当一个新进程进入内存后，首先放入第 1 级队列的末尾，按 FCFS 的原则排队等待调度。当该进程执行时，如果其能在时间片内完成便撤离系统；如果它在一个时间片结束未完成，该进程进入第 2 级队列按照 FCFS 的原则等待调度，以此类推。对于最后一级队列，进程执行一个时间片结束未完成会回到该队列的队尾。（如图中的环，如果前面队列的任务过多，可能导致饥饿问题）</li>
<li>仅当第 1 级队列为空时，调度程序才调度第 2 级队列的进程进行执行，以此类推。</li>
</ol>
<p><img src="/2022/04/05/Virtualization/1643033924079-f75ee3ea-89da-44bb-bcfb-b1b8055447d1.png" alt="多级反馈队列"></p>
<p>优点：</p>
<p>短作业可以在前面的队列内完成，长作业可以得到部分执行。</p>
<p>交互型作业通常较短，系统只要能使其第1级队列所规定的时间片内完成，即可使终端用户感到满意。</p>
<p>不必人为估计进程的执行时间。</p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要切换 100 次。</p>
<p>假设多级队列从队列 1 开始分配的时间片为 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要切换 7 次。1+2+4+8+16+32+64</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/05/JavaPractice/" rel="prev" title="Java 多线程基础实践">
      <i class="fa fa-chevron-left"></i> Java 多线程基础实践
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/06/MySQL/" rel="next" title="MySQL">
      MySQL <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.</span> <span class="nav-text">虚拟地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E6%9E%84%E6%88%90"><span class="nav-number">1.1.</span> <span class="nav-text">虚拟地址空间的构成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-number">1.1.1.</span> <span class="nav-text">内核空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4"><span class="nav-number">1.1.2.</span> <span class="nav-text">用户空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">进程控制块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2"><span class="nav-number">1.1.3.</span> <span class="nav-text">内核空间和用户空间的切换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">进程切换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-API"><span class="nav-number">1.1.4.</span> <span class="nav-text">进程 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">1.2.</span> <span class="nav-text">虚拟地址到物理地址的映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5"><span class="nav-number">1.2.1.</span> <span class="nav-text">分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5"><span class="nav-number">1.2.2.</span> <span class="nav-text">分页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-cache%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">页面置换算法&#x2F;cache淘汰算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F"><span class="nav-number">1.2.3.</span> <span class="nav-text">段页式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F-CPU"><span class="nav-number">2.</span> <span class="nav-text">虚拟 CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU-%E5%8F%8C%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">CPU 双模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%9D%83%E8%BD%AC%E7%A7%BB"><span class="nav-number">2.2.</span> <span class="nav-text">控制权转移</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">2.3.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">2.3.1.</span> <span class="nav-text">调度策略相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E6%8C%87%E6%A0%87"><span class="nav-number">2.3.2.</span> <span class="nav-text">调度指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.3.</span> <span class="nav-text">进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">批处理系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">交互式系统</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cyl"
      src="/images/icon1.jpg">
  <p class="site-author-name" itemprop="name">Cyl</p>
  <div class="site-description" itemprop="description">顽童大了别那么笨</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cyl</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'bj1pUPUVv7CB9DzNJpPiyH5u-gzGzoHsz',
      appKey     : 'RQWkhgEzgN0MjSY1E3rSiuJc',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '9' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>

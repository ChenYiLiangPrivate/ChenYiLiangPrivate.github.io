<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="如果没有特殊说明，都是针对的是 HotSpot 虚拟机。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2022/04/04/JVM/index.html">
<meta property="og:site_name" content="缘溪行">
<meta property="og:description" content="如果没有特殊说明，都是针对的是 HotSpot 虚拟机。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/1647436365919-9cd662d0-1aa3-4501-902e-59dcd6095c3d.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/webp.webp">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/method-area-1.6.291acb6f.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/method-area-jdk1.7.d852e1fb.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/method-area-jdk1.8.f83a79be.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/331425-20160621125941772-1913742708.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/1647438628208-03b39124-9351-4ff0-ab47-61df7698891e.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/1647436415158-62c57e47-e0c6-43d3-ae19-f7bb65c339dc.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/1647439292918-98859438-8a5f-47bc-93c6-eddb1d4717dc.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/1647439292769-26b729bb-dc2c-4607-9dc9-bbf390dd0bc2.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/1647431576601-544027ae-f696-4da9-abf5-29f0138a8663.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/1647431631421-c33e7513-6f19-41bc-8bfc-4ffd941070cd.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/1647430687276-153ea241-823f-4b57-a212-9f137ba30be8.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/1647431959692-a9b1b24b-b425-4746-b5c9-566932bb41bf.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/1647432020975-d07110a4-443c-44a4-b3b1-be12ac618e08.png">
<meta property="og:image" content="http://example.com/2022/04/04/JVM/1647432336054-17d3daab-8419-4f7e-9a18-0968c1ad7cb8.png">
<meta property="article:published_time" content="2022-04-04T02:58:42.000Z">
<meta property="article:modified_time" content="2022-04-11T02:19:08.942Z">
<meta property="article:author" content="Cyl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/04/JVM/1647436365919-9cd662d0-1aa3-4501-902e-59dcd6095c3d.png">

<link rel="canonical" href="http://example.com/2022/04/04/JVM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM | 缘溪行</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">缘溪行</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">16</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/04/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-04 10:58:42" itemprop="dateCreated datePublished" datetime="2022-04-04T10:58:42+08:00">2022-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-11 10:19:08" itemprop="dateModified" datetime="2022-04-11T10:19:08+08:00">2022-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/04/JVM/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/04/JVM/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p>
<span id="more"></span>

<h1 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h1><p><img src="/2022/04/04/JVM/1647436365919-9cd662d0-1aa3-4501-902e-59dcd6095c3d.png"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ul>
<blockquote>
<p>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
</blockquote>
<h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>描述的是 Java 方法执行的内存模型</p>
<p>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</p>
<p>Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。</p>
<ul>
<li>StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。可以用参数 -Xss 来调整栈的大小。</li>
<li>OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。</li>
</ul>
<blockquote>
<p>OOM：</p>
<p>栈 OOM，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生 OOM（2G 用完了）</p>
<p>堆 OOM，GC 之后无法在堆中申请足够内存创建对象；</p>
<p>方法区 OOM，经常会遇到的是动态生成大量的类等；</p>
<p>排查 OOM 的方法：</p>
<p>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;tmp&#x2F;heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；</p>
<p>jstat 查看 JVM 的内存和 GC 情况；</p>
<p>使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 </p>
</blockquote>
<h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>一个栈帧需要分配多少内存，不会受到程序运行时变量数据影响，仅仅取决于虚拟机的实现</p>
<p>如下图所示。虚拟机栈包含了两个 Java 方法的栈帧，而每个栈帧包括：局部变量表、操作数栈、动态链接、方法出口信息</p>
<p><img src="/2022/04/04/JVM/webp.webp"></p>
<h4 id="局部变量表（Local-Variable-Table）"><a href="#局部变量表（Local-Variable-Table）" class="headerlink" title="局部变量表（Local Variable Table）"></a>局部变量表（Local Variable Table）</h4><p>在编译代码的时候就可以确定栈帧需要多大的局部表量表，具体的大小可以在编译后的 Class 文件中看到。</p>
<p>局部变量表容量以变量槽（Variable Slot）为最小单位，每个变量槽长度 4 个字节</p>
<p>用于存放方法内的局部变量。虚拟机使用局部变量表完成参数值到参数变量表的传递过程，如果执行的是实例方法，那局部表量表的第 0 个槽位默认是用于传递方法所属对象的引用（this关键字）。</p>
<h4 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h4><p>在编译代码的时候就可以确定栈帧需要多大的操作数栈，具体的大小可以在编译后的 Class 文件中看到。</p>
<p>在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，然后是函数中的局部变量。注意静态变量是不入栈的。</p>
<p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p>
<h4 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h4><p>动态链接：一个指向运行时常量池中该栈帧所属方法的引用。运行时常量池中该栈帧所属方法的存在方式是一个符号引用，或者直接引用（如果之前被解析过）</p>
<h4 id="完成出口（Return-Address，也叫做返回地址-）"><a href="#完成出口（Return-Address，也叫做返回地址-）" class="headerlink" title="完成出口（Return Address，也叫做返回地址 ）"></a>完成出口（Return Address，也叫做返回地址 ）</h4><p>两种退出方式：return 返回指令，异常退出</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象<strong>实例</strong>，几乎所有的对象实例以及数组都在这里分配内存。</p>
<p>new 一个对象，对象实例存放在堆中，对象的引用存放在栈中。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>它用于存储已被虚拟机加载的类信息（Class 文件）、常量、静态变量、即时编译器（JIT compiler）编译后的代码等数据。</p>
<p>方法表、字段表被放在方法区。根据运行时常量池的符号引用解析找到方法区中的方法和字段。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<p>Class 文件中有一项信息是常量池（Constant Pool），用于存放编译期生成的符号引用，这部分内容将在类加载阶段存放到方法区中，它的存放区域也叫做运行时常量池。在类的解析阶段还会将这些符号引用翻译为直接引用，用翻译出来的直接引用替换原本的符号引用。</p>
<h3 id="方法区结构的变化"><a href="#方法区结构的变化" class="headerlink" title="方法区结构的变化"></a>方法区结构的变化</h3><p><img src="/2022/04/04/JVM/method-area-1.6.291acb6f.png" alt="方法区-jdk1.6"></p>
<p><img src="/2022/04/04/JVM/method-area-jdk1.7.d852e1fb.png" alt="方法区-jdk1.7"></p>
<p><img src="/2022/04/04/JVM/method-area-jdk1.8.f83a79be.png" alt="方法区-jdk1.8"></p>
<ol>
<li><p>JDK1.7 之前，运行时常量池包含字符串常量池，运行时常量池和静态变量存放在方法区，此时 HotSpot 虚拟机对方法区的实现为永久代。</p>
<blockquote>
<p>在堆中创建字符串常量对应的 String 实例，它的引用存储在方法区的字符串常量池</p>
<p>如果静态变量是基本类型数据，如 static int i &#x3D; 1; 1 这个值存储在方法去，如果静态变量是一个对象，在堆中创建静态变量的实例，它的引用存储在方法区</p>
</blockquote>
</li>
<li><p>JDK1.7 运行时常量池中的字符串常量池被拿到了堆中、静态变量被拿到了堆中，此时 HotSpot 虚拟机对方法区的实现为永久代 。</p>
<blockquote>
<p><strong>字符串常量池物理上存放在堆中，但逻辑上还是属于方法区</strong></p>
<p>为什么要将字符串常量池移动到堆中？</p>
<p>主要是因为永久代的 GC 回收效率太低，只有在 Full GC 的时候才会进行回收。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
</blockquote>
</li>
<li><p>JDK1.8 HotSpot 移除了永久代用元空间（Metaspace）取而代之，这时候字符串常量池和静态变量还在堆, 运行时常量池还在方法区，只不过方法区的实现从永久代变成了元空间（Metaspace）</p>
<blockquote>
<p>元空间的出现是为了解决突出的类和类加载器元数据过多导致的OOM问题。元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
</blockquote>
</li>
</ol>
<h3 id="基本类型包装类对象常量池"><a href="#基本类型包装类对象常量池" class="headerlink" title="基本类型包装类对象常量池"></a>基本类型包装类对象常量池</h3><p>java 中基本类型的包装类的大部分都实现了常量池技术，这些类是：</p>
<p>Byte、Short、Integer、Long、Character、Boolean。</p>
<p>另外上面这 5 种整型的包装类也只是在对应值小于等于 127 时才可使用对象常量池。</p>
<h1 id="JVM-调优"><a href="#JVM-调优" class="headerlink" title="JVM 调优"></a>JVM 调优</h1><h2 id="JVM-调优命令"><a href="#JVM-调优命令" class="headerlink" title="JVM 调优命令"></a>JVM 调优命令</h2><ul>
<li><p>jps：JVM Process Status Tool，显示指定系统内所有的 HotSpot 虚拟机进程。</p>
</li>
<li><p>jstat：JVM statistics Monitoring，是用于监视虚拟机运行时状态信息的命令，它可以显示出虚<br>  拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。</p>
</li>
<li><p>jmap：JVM Memory Map，用于生成 heap dump 文件，如果不使用这个命令，还可以使<br>  用 -XX:+HeapDumpOnOutOfMemoryError 参数来让虚拟机出现 OOM 的时候·自动生成dump文<br>  件。<br>  jmap不仅能生成 dump 文件，还可以查询 finalize 执行队列、Java 堆和永久代的详细信息，如当前使<br>  用率、当前使用的是哪种收集器等。</p>
</li>
<li><p>jhat：JVM Heap Analysis Tool，与 jmap 搭配使用，用来分析 jmap 生成的 dump 文件，jhat 内<br>  置了一个微型的 HTTP&#x2F;HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看。在此要注<br>  意，一般不会直接在服务器上进行分析，因为 jhat 是一个耗时并且耗费硬件资源的过程，一般把服<br>  务器生成的 dump 文件复制到本地或其他机器上进行分析。</p>
</li>
<li><p>jstack：jstack 用于生成 java 虚拟机当前时刻的线程快照。jstack 来查看各个线程的调用堆栈，就可<br>  以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果 java 程序崩溃生成 core 文<br>  件，jstack 工具可以用来获得 core 文件的 java stack 和 native stack 的信息，从而可以轻松地知道<br>  java 程序是如何崩溃和在程序何处发生问题。</p>
</li>
</ul>
<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>考虑这样一个 Java 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    bar();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class 文件，后缀名是 .class，也可以叫做 .class 文件，这两个称呼区别于 Class 对象。用 javac 编译器编译出来的 Class 文件的文本形式（存储时为二进制形式）如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Classfile /private/tmp/X.class</span><br><span class="line">  Last modified Jun 13, 2015; size 372 bytes</span><br><span class="line">  MD5 checksum 8abb9cbb66266e8bc3f5eeb35c3cc4dd</span><br><span class="line">  Compiled from &quot;X.java&quot;</span><br><span class="line">public class X</span><br><span class="line">  SourceFile: &quot;X.java&quot;</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 51</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#16         //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Methodref          #3.#17         //  X.bar:()V</span><br><span class="line">   #3 = Class              #18            //  X</span><br><span class="line">   #4 = Class              #19            //  java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Utf8               Code</span><br><span class="line">   #8 = Utf8               LineNumberTable</span><br><span class="line">   #9 = Utf8               LocalVariableTable</span><br><span class="line">  #10 = Utf8               this</span><br><span class="line">  #11 = Utf8               LX;</span><br><span class="line">  #12 = Utf8               foo</span><br><span class="line">  #13 = Utf8               bar</span><br><span class="line">  #14 = Utf8               SourceFile</span><br><span class="line">  #15 = Utf8               X.java</span><br><span class="line">  #16 = NameAndType        #5:#6          //  &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #17 = NameAndType        #13:#6         //  bar:()V</span><br><span class="line">  #18 = Utf8               X</span><br><span class="line">  #19 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public X();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0       </span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return        </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">               0       5     0  this   LX;</span><br><span class="line"></span><br><span class="line">  public void foo();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0       </span><br><span class="line">         1: invokevirtual #2                  // Method bar:()V</span><br><span class="line">         4: return        </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">               0       5     0  this   LX;</span><br><span class="line"></span><br><span class="line">  public void bar();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=0, locals=1, args_size=1</span><br><span class="line">         0: return        </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">               0       1     0  this   LX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Class 文件里有一段叫做 Constant pool，也就是常量池</p>
<p>来观察 foo() 方法是如何调用 bar() 的，具体地，来考察 foo() 方法里的一条字节码指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1: invokevirtual #2  // Method bar:()V</span><br></pre></td></tr></table></figure>

<p>该字节码指令的二进制存储格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[B6] [00 02]</span><br></pre></td></tr></table></figure>

<p>其中 0xB6 是 invokevirtual 指令的操作码（opcode），后面的 0x0002 是该指令的操作数（operand），用于指定要调用的目标方法。因此，我们来看它的操作数。</p>
<p>这个参数是 Class 文件里的常量池的下标。那么去找下标为 2 的常量池项，是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#2 = Methodref          #3.#17         //  X.bar:()V</span><br></pre></td></tr></table></figure>

<p>该语句的二进制存储格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0A] [00 03] [00 11]</span><br></pre></td></tr></table></figure>

<p>其中 0x0A 是 CONSTANT_Methodref_info 的 tag，后面的 0x03 和 0x11 是常量池下标，分别表示 class_index 和 name_and_type_index。</p>
<p>顺着这条线索把能传递引用到的常量池项都找出来，会看到（按深度优先顺序排列）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> #2 = Methodref          #3.#17         //  X.bar:()V</span><br><span class="line"> </span><br><span class="line"> #3 = Class              #18            //  X</span><br><span class="line">#18 = Utf8               X</span><br><span class="line"></span><br><span class="line">#17 = NameAndType        #13:#6         //  bar:()V</span><br><span class="line">#13 = Utf8               bar</span><br><span class="line"> #6 = Utf8               ()V</span><br></pre></td></tr></table></figure>

<p>把引用关系画成一棵树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     #2 Methodref X.bar:()V</span><br><span class="line">     /                     \</span><br><span class="line">#3 Class X       #17 NameAndType bar:()V</span><br><span class="line">    |                /             \</span><br><span class="line">#18 Utf8 X    #13 Utf8 bar     #6 Utf8 ()V</span><br></pre></td></tr></table></figure>

<p>总而言之，Class 文件里的符号引用实际上是：带有类型（tag） &#x2F; 结构（符号间引用层次）的字符串。</p>
<p>将方法的符号引用解析为直接引用：</p>
<p>JVM在类加载的时候会把 Class 文件转化为<strong>方法区</strong>的运行时数据结构。例如说类的元数据记录在 ClassClass 结构体里，每个方法的元数据记录在各自的 methodblock 结构体里。</p>
<p>在刚加载好一个类的时候，Class文件里的常量池和每个方法的字节码（Code属性）会被基本原样的拷贝到内存里先放着，也就是说仍然处于使用“符号引用”的状态；直到真的要被使用到的时候才会被解析（resolve）为直接引用。</p>
<p>假定我们要第一次执行到 foo() 方法里调用 bar() 方法的那条 invokevirtual 指令了。</p>
<p>此时JVM会发现该指令尚未被解析，所以会先去解析。</p>
<p>通过其操作数所记录的常量池下标 0x0002，找到常量池项 #2，发现该常量池项也尚未被解析，于是进一步去解析该项。解析过程为：</p>
<p>通过 Methodref 所记录的 class_index 找到类名，进一步找到被调用方法的类的 ClassClass 结构体（类的符号引用是否在加载后就变成了直接引用？）；然后通过 name_and_type_index 找到方法名和方法描述符，到ClassClass 结构体上记录的方法列表里找到匹配的那个 methodblock；最终把找到的 methodblock 的指针写回到常量池项 #2 里。</p>
<p>也就是说，原本常量池项 #2 在类加载后的运行时常量池里的内容跟 Class 文件里的一致，是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[00 03] [00 11]</span><br></pre></td></tr></table></figure>

<p>小细节，tag 被放到了别的地方。而在解析后，假设找到的 methodblock 地址是 0x45762300，那么常量池项 #2的内容会变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[00 23 76 45]</span><br></pre></td></tr></table></figure>

<p>这样，以后再查询到常量池项 #2 时，里面就不再是一个符号引用，而是一个能直接找到 Java 方法元数据的直接引用了。</p>
<p>解析好常量池项 #2 之后回到 invokevirtual 指令的解析。回顾一下，在解析前那条指令的内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[B6] [00 02]</span><br></pre></td></tr></table></figure>

<p>而在解析后，这块代码被改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[D6] [06] [01]</span><br></pre></td></tr></table></figure>

<p>其中 opcode 部分从 invokevirtual 改写为 invokevirtual_quick，表示该指令已经解析完毕。原本存储操作数的 2字节空间现在分别存了 2 个 1 字节信息，第一个是虚方法表的下标（vtable index），第二个是方法的参数个数。这两项信息都由前面解析常量池项 #2 得到的 methodblock 读取而来。</p>
<p>可以看到，方法表各个方法按序排列，并且每个方法具有该方法的详细信息，包括 code，即字节码指令，后面被加载到方法区</p>
<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><ul>
<li><p>主要三步：加载 -&gt; 连接 -&gt; 初始化。连接过程又可分为三步：验证 -&gt; 准备 -&gt; 解析。</p>
</li>
<li><p>何时会执行各个加载步骤？</p>
<p>  动态加载，并不是一次性把所有程序中定义的 class 全部加载到内存，而是第一次用到 class 时才加载</p>
<p>  加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p>
<p>  解析时机：<strong>用于操作符号引用的字节码指令</strong>之前，先对它们所使用的符号引用进行解析</p>
</li>
</ul>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段，虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取此类的二进制字节流。例如，用 javac 编译得到的 .class 文件（也称做 Class 文件）</li>
<li>将这个字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构（类元数据，包括常量池、属性表、方法表和异常表等）。这个过程包含了 .class 文件中的常量池存放到运行时常量池的过程。</li>
<li>在<strong>堆</strong>中生成一个 java.lang.Class 对象，用来封装在方法区内的类型数据，并作为方法区类型数据的外部接口。（通过堆中的 Class 对象，访问方法区中的类的数据结构）</li>
</ol>
<p><img src="/2022/04/04/JVM/331425-20160621125941772-1913742708.png"></p>
<blockquote>
<p>Class 作为方法区类型数据的外部接口，Class 实例本身没有类型数据，但 Class 实例具有指向类元数据的指针，通过这个指针访问类元数据。</p>
<p>普通对象实例也具有指向类元数据的指针，但是要获取类的信息，需要通过 getClass()，得到的是 Class 对象的引用，不能直接得到对象头中指向类元数据的指针。</p>
<p>类元数据包含 Class 对象的引用。</p>
<ul>
<li>具体来说，当使用 String.class，String 即 String 类元数据的指针，.class 即获取类元数据中 Class 对象的引用</li>
<li>当使用 对象.getClass() 和 class.forName()，前者看似是得到对象头中指向类元数据的指针，后者看似是直接得到指向类元数据的指针，实际上在函数内部处理后，返回的还是 Class 对象的引用。</li>
</ul>
</blockquote>
<p>一个非数组类的加载阶段（具体地，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。</p>
<p>数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配（方法区中存放着类的数据结构）。对于该阶段有以下几点需要注意：</p>
<ol>
<li>这时候进行内存分配的仅包括类变量（ 即类的静态变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>
<li>从概念上讲，类变量所使用的内存都应当在 方法区 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。当class文件被加载到内存中时，类文件常量池中的其他常量会加载到运行时常量池，但是字符串常量不会。它会首先在堆区中创建一个字符串对象，然后再把这个对象的引用保存到全局字符串常量池中</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值，比如我们定义了 public static int value&#x3D;111，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：给 value 变量加上了 final 关键字，public static final int value&#x3D;111 ，那么准备阶段 value 的值就被赋值为 111。</li>
</ol>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。（常量池原本存储的是符号引用，被替换成了直接引用）</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p>以解析方法的符号引用为例，在执行方法时，系统需要明确知道这个方法所在的地址。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<blockquote>
<p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行 ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield 和 putstatic 这17个<strong>用于操作符号引用的字节码指令</strong>之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
</blockquote>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>&lt;clinit&gt;() 方法是编译之后自动生成的。初始化阶段是执行初始化方法 &lt;clinit&gt;() 的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码（字节码）。</p>
<p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 &lt;clinit&gt;() 方法，其他线程都需要阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。</p>
<p>需要注意的是，其他线程虽然会被阻塞，但当活动线程执行 &lt;clinit&gt;() 方法后，其他线程被唤醒之后不会再次执行&lt;clinit&gt;() 方法。同一个加载器下，一个类型只会初始化一次。（这与一般的 Synchronized 方法有显著区别）</p>
<blockquote>
<p>&lt;init&gt; 是实例构造器，对非静态变量初始化，而  &lt;clinit&gt; 是类构造器，对静态变量，静态代码块进行初始化。</p>
</blockquote>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：</p>
<ol>
<li>BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%&#x2F;lib目录下的 jar 包和类或者被 -Xbootclasspath参数指定的路径中的所有类。</li>
<li>ExtensionClassLoader(扩展类加载器) ：主要负责加载 %JRE_HOME%&#x2F;lib&#x2F;ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。</li>
<li>AppClassLoader(应用程序类加载器) ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>
</ol>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><img src="/2022/04/04/JVM/1647438628208-03b39124-9351-4ff0-ab47-61df7698891e.png" alt="类加载器"></p>
<p>全限定类名：就是类名全称，带包路径的用点隔开，例如: java.lang.String<br>非限定类名：String</p>
<p>为了防止内存中出现多个相同的字节码；因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性。</p>
<p>自己写过String类能加载吗，之前的String是什么时候加载进去的？<br>不能加载，因为双亲委派机制，JVM 出于安全性的考虑，全限定类名相同的 String 是不能被加载的。<br>java.lang.String 会被顶级类加载器 BootstrapClassloader 加载。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1 类加载检查"></a>1 类加载检查</h3><p>虚拟机遇到一条 new 指令时，首先将去检查是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2 分配内存"></a>2 分配内存</h3><p>对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有整理功能决定。</p>
<p>内存分配的两种方式</p>
<p><img src="/2022/04/04/JVM/1647436415158-62c57e47-e0c6-43d3-ae19-f7bb65c339dc.png"></p>
<p><strong>内存分配并发问题</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全。通常来讲，虚拟机采用两种方式来保证创建对象过程的线程安全：</p>
<ul>
<li>CAS</li>
<li>TLAB： 为每一个线程预先在 Eden 区分配一块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用 CAS 进行内存分配</li>
</ul>
<h3 id="3-初始化零值"><a href="#3-初始化零值" class="headerlink" title="3 初始化零值"></a>3 初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。</p>
<h3 id="4-设置对象头"><a href="#4-设置对象头" class="headerlink" title="4 设置对象头"></a>4 设置对象头</h3><p>Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<blockquote>
<p>类元数据：加载阶段生成的”<strong>方法区</strong>的运行时数据结构“</p>
<p>类型指针：不是 Class 对象的引用</p>
</blockquote>
<h3 id="5-执行-init-方法"><a href="#5-执行-init-方法" class="headerlink" title="5 执行 init 方法"></a>5 执行 init 方法</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，&lt;init&gt; 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。</p>
<p>Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p>
<p>对齐填充部分仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java 通过引用来访问对象，引用的具体实现方式有两种</p>
<ol>
<li><p>句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，句柄池用于存放多个对象的句柄。句柄中包含了对象实例数据与类型数据各自的地址，而 reference 中存储的就是对象的句柄地址；</p>
<p> <img src="/2022/04/04/JVM/1647439292918-98859438-8a5f-47bc-93c6-eddb1d4717dc.png" alt="句柄"></p>
</li>
<li><p>直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息（到对象类型数据的指针），而 reference 中存储的直接就是对象的地址。</p>
<p> <img src="/2022/04/04/JVM/1647439292769-26b729bb-dc2c-4607-9dc9-bbf390dd0bc2.png" alt="直接指针"></p>
</li>
</ol>
<p>使用句柄来访问的好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式的好处是速度快，它节省了一次指针定位的时间开销。</p>
<p><strong>在 Hotspot 虚拟机中，使用直接指针的方法来实现引用，对象类型数据的指针被存放在对象头中。</strong></p>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
<ol>
<li>效率问题（遍历整个内存空间进行回收）</li>
<li>空间问题（标记清除后会产生大量不连续的碎片）</li>
</ol>
<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<img src="/2022/04/04/JVM/1647431576601-544027ae-f696-4da9-abf5-29f0138a8663.png" alt="标记-复制算法" style="zoom: 67%;">

<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="/2022/04/04/JVM/1647431631421-c33e7513-6f19-41bc-8bfc-4ffd941070cd.png" alt="标记-整理算法"></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>一般将 java 堆分为新生代和老年代，这样我们就可以<strong>根据各个年代的特点选择合适的垃圾收集算法</strong>。</p>
<ul>
<li>在新生代中，每次收集都会有大量对象死去，所以可以选择“标记-复制”算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集（只有少量存活对象需要复制）</li>
<li>老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</li>
</ul>
<h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h1><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。</p>
<p><img src="/2022/04/04/JVM/1647430687276-153ea241-823f-4b57-a212-9f137ba30be8.png" alt="GC 堆划分"></p>
<h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><p>垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>
<p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 两个对象互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。<br>哪些对象可以作为 GC Roots 呢？</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>本地方法栈（Native 方法）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<blockquote>
<p>对象已经死亡，就代表马上（不是最终）会被回收吗？</p>
<p>先进入回收队列，JVM 会开一个线程进行回收，除非在被回收之前，这个对象与引用链上的任何一个对象建立关联才不会被回收。</p>
</blockquote>
<h3 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h3><p>强引用，就是普通的对象引用关系</p>
<p>软引用，在内存不足时，系统会强制回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，会抛出内存溢出异常。</p>
<p>弱引用，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。</p>
<p>虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来跟踪对象被垃圾回收的活动。</p>
<h2 id="判断一个类是无用的类"><a href="#判断一个类是无用的类" class="headerlink" title="判断一个类是无用的类"></a>判断一个类是无用的类</h2><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p>
<p>类需要同时满足下面 3 个条件才能算是 “无用的类” ：</p>
<ul>
<li>该类所有的实例都已经被回收。</li>
<li>该类的类加载器实例已经被回收。（所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。）</li>
<li>该类的 Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="JVM-垃圾回收过程"><a href="#JVM-垃圾回收过程" class="headerlink" title="JVM 垃圾回收过程"></a>JVM 垃圾回收过程</h2><p>新生代 ( Young )、老年代 ( Old )，新生代默认占总空间的1&#x2F;3，老年代默认占 2&#x2F;3。</p>
<p>新生代有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。</p>
<p>新生代的垃圾回收（Minor GC）选用复制算法。老年代的垃圾回收（Major GC）通常使用“标记-清理”或“标记-整理”算法。</p>
<p>Survivor 分区：空的 Survivor 分区被称为 Survivor To 分区，存在对象的分区称为 Survivor From 分区</p>
<p>Minor GC触发条件：当 Eden 区没有足够空间进行分配时，触发Minor GC。</p>
<p>垃圾回收过程：</p>
<ul>
<li>对象优先在 Eden 分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区；</li>
<li>Eden 区没有足够空间进行分配，再次 Minor GC，这时会采用复制算法，将 Eden 和 From 区一起清理，存活的对象会被复制到 To 区；</li>
<li>每移动一次，对象年龄加 1，对象年龄大于一定阀值会直接移动到老年代。<ul>
<li>固定阈值。通过参数 -XX:MaxTenuringThreshold 设置，默认为 15</li>
<li>动态阈值：Survivor 区相同年龄所有对象大小的总和 &gt; (Survivor 区内存大小 * TargetSurvivorRatio)时，大于或等于该年龄的对象直接进入老年代。<ul>
<li>-XX:TargetSurvivorRatio 指定，默认为 50%；</li>
<li>新的阈值为 min(该年龄，固定阈值）</li>
<li>计算方法：用数组记录各个年龄中所有对象的大小之和</li>
</ul>
</li>
</ul>
</li>
<li>Survivor 区内存不足会发生担保分配，超过指定大小的对象直接进入老年代。</li>
<li>老年代空间不足，进行Full GC，Full GC 清理整个内存堆，包括年轻代和老年代。</li>
</ul>
<h3 id="空间担保分配"><a href="#空间担保分配" class="headerlink" title="空间担保分配"></a>空间担保分配</h3><p>是因为新生代采用复制收集算法，假如大量对象在 Minor GC 后仍然存活，而 Survivor To 空间是比较小的，不足以实现复制，这时就需要老年代进行分配担保，把 Survivor 无法容纳的对象放到老年代。</p>
<p>JVM 使用空间分配担保机制来用来让对象进入老年代。</p>
<p>JDK 6 Update 24 之前，在<strong>发生 Minor GC 之前</strong>，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。</p>
<p>如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数，该参数表示是否允许担保失败。如果允许，继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许担保失败，那这时就要改为进行一次 Full GC。</p>
<p>在允许担保失败并尝试进行 Minor GC 后，可能会出现三种情况：</p>
<ul>
<li>Minor GC 后，存活对象小于 survivor to 大小，此时存活对象进入 survivor to 区中</li>
<li>Minor GC 后，存活对象大于 survivor to 大小，但是小于老年代可用空间大小，此时直接进入老年代。</li>
<li>Minor GC 后，存活对象大于 survivor to 大小，也大于老年代可用空间大小，发生“Handle Promotion Failure”，担保分配失败，会触发 Full GC。如果 Full GC 后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。</li>
</ul>
<p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p>
<h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><p>Minor GC：新生代的 GC。触发条件：当 Eden 区满时，触发 Minor GC。</p>
<p>Full GC: 整个堆的 GC，包括新生代、老年代<strong>和永久代</strong>（注意 Full GC 会清理方法区。在 JDK 1.8及以后，永久代被移除，换为 metaspace 元空间）。触发条件：</p>
<p>在<strong>发生 Minor GC 之前</strong>，虚拟机检查发现老年代最大可用的连续空间 &lt; 新生代所有对象总空间：</p>
<ul>
<li>允许担保分配失败并且老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小：在 Minor GC 后，存活对象大于 survivor to 大小，也大于老年代可用空间大小，触发 Full GC</li>
<li>不允许担保分配失败，触发 Full GC</li>
</ul>
<p>Full GC 清理堆和方法区，需要 stop the world 的时间更长</p>
<p>老年代空间不够分配新的内存（或永久代空间不足，但只是JDK1.7有的，这也是用元空间来取代永<br>久代的原因，可以减少Full GC的频率，减少GC负担，提升其效率）</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>Serial、ParNew：新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
<p>CMS：标记-清除算法</p>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p>
<p><img src="/2022/04/04/JVM/1647431959692-a9b1b24b-b425-4746-b5c9-566932bb41bf.png"></p>
<p>优点：单线程收集效率高，</p>
<p>缺点：单线程收集，stop the world 造成停顿，实时性差</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本。仍然要暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p>
<p><img src="/2022/04/04/JVM/1647432020975-d07110a4-443c-44a4-b3b1-be12ac618e08.png"></p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS（Concurrent Mark Sweep）收集器设计目的是为了实现低停顿。</p>
<p>它的运作过程分为四个步骤：</p>
<ul>
<li><strong>初始标记</strong>： 暂停所有的其他线程，进行可达性分析 ；</li>
<li>并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记</strong>：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除</strong>： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p><img src="/2022/04/04/JVM/1647432336054-17d3daab-8419-4f7e-9a18-0968c1ad7cb8.png"></p>
<p>优点：并发收集、低停顿。（初始标记和重新标记阶段仍然需要 stop the world，暂停其他所有工作线程，造成停顿。</p>
<p>缺点：</p>
<ul>
<li>对 CPU 资源敏感；(并发，需要多 cpu，让用户线程和 GC 线程运行在不同 cpu 上）</li>
<li>无法处理浮动垃圾；</li>
<li>“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/02/deadlock/" rel="prev" title="死锁">
      <i class="fa fa-chevron-left"></i> 死锁
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/05/Redis/" rel="next" title="Redis">
      Redis <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.</span> <span class="nav-text">Java 内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">1.2.</span> <span class="nav-text">Java 虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7"><span class="nav-number">1.2.1.</span> <span class="nav-text">栈帧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%EF%BC%88Local-Variable-Table%EF%BC%89"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">局部变量表（Local Variable Table）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%EF%BC%88Operand-Stack%EF%BC%89"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">操作数栈（Operand Stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88Dynamic-Linking%EF%BC%89"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">动态链接（Dynamic Linking）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%88%90%E5%87%BA%E5%8F%A3%EF%BC%88Return-Address%EF%BC%8C%E4%B9%9F%E5%8F%AB%E5%81%9A%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80-%EF%BC%89"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">完成出口（Return Address，也叫做返回地址 ）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.4.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.5.1.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">1.5.2.</span> <span class="nav-text">方法区结构的变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.5.3.</span> <span class="nav-text">基本类型包装类对象常量池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-%E8%B0%83%E4%BC%98"><span class="nav-number">2.</span> <span class="nav-text">JVM 调优</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E8%B0%83%E4%BC%98%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.</span> <span class="nav-text">JVM 调优命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">类文件结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">4.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">4.2.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-number">4.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">4.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">6.1.</span> <span class="nav-text">对象的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="nav-number">6.1.1.</span> <span class="nav-text">1 类加载检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">6.1.2.</span> <span class="nav-text">2 分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC"><span class="nav-number">6.1.3.</span> <span class="nav-text">3 初始化零值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">6.1.4.</span> <span class="nav-text">4 设置对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%89%A7%E8%A1%8C-init-%E6%96%B9%E6%B3%95"><span class="nav-number">6.1.5.</span> <span class="nav-text">5 执行 init 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">6.2.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">6.3.</span> <span class="nav-text">对象的访问定位</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">标记-复制算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">标记-整理算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">8.</span> <span class="nav-text">JVM 垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB"><span class="nav-number">8.1.</span> <span class="nav-text">判断对象是否存活</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">8.1.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">8.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8"><span class="nav-number">8.1.3.</span> <span class="nav-text">强引用、软引用、弱引用、虚引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="nav-number">8.2.</span> <span class="nav-text">判断一个类是无用的类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">8.3.</span> <span class="nav-text">JVM 垃圾回收过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E6%8B%85%E4%BF%9D%E5%88%86%E9%85%8D"><span class="nav-number">8.3.1.</span> <span class="nav-text">空间担保分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Minor-GC-%E5%92%8C-Full-GC"><span class="nav-number">8.3.2.</span> <span class="nav-text">Minor GC 和 Full GC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.4.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.4.1.</span> <span class="nav-text">Serial 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.4.2.</span> <span class="nav-text">ParNew 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.4.3.</span> <span class="nav-text">CMS 收集器</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cyl"
      src="/images/icon1.jpg">
  <p class="site-author-name" itemprop="name">Cyl</p>
  <div class="site-description" itemprop="description">顽童大了别那么笨</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cyl</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'bj1pUPUVv7CB9DzNJpPiyH5u-gzGzoHsz',
      appKey     : 'RQWkhgEzgN0MjSY1E3rSiuJc',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '9' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>

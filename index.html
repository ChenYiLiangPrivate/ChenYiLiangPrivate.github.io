<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="顽童大了别那么笨">
<meta property="og:type" content="website">
<meta property="og:title" content="缘溪行">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="缘溪行">
<meta property="og:description" content="顽童大了别那么笨">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cyl">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>缘溪行</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">缘溪行</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">13</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/07/transport-layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/07/transport-layer/" class="post-title-link" itemprop="url">传输层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-07 22:45:28" itemprop="dateCreated datePublished" datetime="2022-04-07T22:45:28+08:00">2022-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-08 16:12:35" itemprop="dateModified" datetime="2022-04-08T16:12:35+08:00">2022-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层提供了进程间的逻辑通信</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/04/07/transport-layer/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/07/app-layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/07/app-layer/" class="post-title-link" itemprop="url">应用层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-07 22:44:48" itemprop="dateCreated datePublished" datetime="2022-04-07T22:44:48+08:00">2022-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-08 16:42:28" itemprop="dateModified" datetime="2022-04-08T16:42:28+08:00">2022-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络分层结构"><a href="#网络分层结构" class="headerlink" title="网络分层结构"></a>网络分层结构</h1><p><strong>TCP&#x2F;IP 五层模型：应用层、传输层、网络层、数据链路层、物理层</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/04/07/app-layer/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/07/I-O-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/07/I-O-model/" class="post-title-link" itemprop="url">I/O 模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-07 22:27:20" itemprop="dateCreated datePublished" datetime="2022-04-07T22:27:20+08:00">2022-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-08 16:42:43" itemprop="dateModified" datetime="2022-04-08T16:42:43+08:00">2022-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<p> select、poll 和 epoll 之间的区别</p>
<p>（1）select：时间复杂度 O(n)<br>select 仅仅知道有 I&#x2F;O 事件发生，但并不知道是哪几个流，所以只能无差别轮询所有流，找出能读出数<br>据或者写入数据的流，并对其进行操作。所以 select 具有 O(n) 的无差别轮询复杂度，同时处理的流越<br>多，无差别轮询时间就越长。<br>（2）poll：时间复杂度 O(n)<br>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状<br>态，但是它没有最大连接数的限制，原因是它是基于链表来存储的。<br>（3）epoll：时间复杂度 O(1)<br>epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的 I&#x2F;O 事件通<br>知我们。所以说 epoll 实际上是事件驱动（每个事件关联上 fd）的（触发式）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/07/Concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/07/Concurrency/" class="post-title-link" itemprop="url">Concurrency</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-07 10:56:41" itemprop="dateCreated datePublished" datetime="2022-04-07T10:56:41+08:00">2022-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-08 16:40:20" itemprop="dateModified" datetime="2022-04-08T16:40:20+08:00">2022-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>同步、锁机制</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/04/07/Concurrency/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/07/Java-Concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/07/Java-Concurrency/" class="post-title-link" itemprop="url">Java 并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-07 10:51:25" itemprop="dateCreated datePublished" datetime="2022-04-07T10:51:25+08:00">2022-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-08 16:41:05" itemprop="dateModified" datetime="2022-04-08T16:41:05+08:00">2022-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>创建线程实例一般有两种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//继承 Thread 类并重写 run()</span><br><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">@Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;MyThread running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread myThread = newMyThread();</span><br><span class="line">myThread.start();</span><br><span class="line"></span><br><span class="line">// 实现 Runnable 接口并重写 run()</span><br><span class="line">public class MyRunnable implements Runnable&#123;</span><br><span class="line">@Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;MyRunnable running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在 Thread  类的构造函数中传入 MyRunnable  的实例对象</span><br><span class="line">Thread thread = newThread(new MyRunnable());</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h2 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h2><p>继承 Thread 类</p>
<p>优点：如果要访问当前线程，无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</p>
<p>缺点：线程类已经继承了Thread类，所以不能再继承其他父类。</p>
<p>实现 Runnable 或 Callable 接口。</p>
<p>优点：线程类可以继承其他类。</p>
<p>缺点：如果要访问当前线程，则必须使用 Thread.currentThread() 方法。</p>
<h2 id="Runnable-和-Callable-的区别"><a href="#Runnable-和-Callable-的区别" class="headerlink" title="Runnable 和 Callable 的区别"></a>Runnable 和 Callable 的区别</h2><p>Callable 重写的方法是 call()，Runnable 重写的方法是 run()</p>
<ul>
<li><p>Call 方法可以抛出异常，run 方法不可以。</p>
</li>
<li><p>Call 方法可异步返回一个Future对象，run 方法没有返回值。</p>
<p>  Future 对象，表示异步计算的结果。通过这个对象可以判断任务是否执行成功，并且可以通过 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，get() 也可以设置阻塞时间，在一定时间后立即返回，这时候有可能任务没有执行完。</p>
</li>
</ul>
<h1 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h1><p>New、Runnable、Running、（Blocked、Waiting、Timed_Waiting）、Dead</p>
<ul>
<li><p>调用 start 方法方可启动线程并使线程进入就绪状态</p>
</li>
<li><p>Blocked、Waiting、Timed_Waiting：在满足条件后进入 Runnable，等待调度</p>
</li>
<li><p>Synchronized 方法执行完后回到就绪状态</p>
</li>
<li><p>线程死亡分为正常结束（run()  或者 call()  方法执行完成）和异常结束（线程抛出一个未捕获的 Exception  或 Error）</p>
</li>
</ul>
<p><img src="/2022/04/07/Java-Concurrency/1647567554292-06cfc90a-5237-4910-9b51-823c1d7f20aa.png" alt="线程状态转移图"></p>
<blockquote>
<p>订正：原图中 wait 到 runnable 状态的转换中，join实际上是Thread类的方法，但这里写成了Object。</p>
</blockquote>
<p>Thread.yield 方法有什么作用？</p>
<p>可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用 CPU，执行 yield() 的线程有可能在进入到暂停状态后马上又被执行。</p>
<h2 id="sleep-方法和-wait-方法比较"><a href="#sleep-方法和-wait-方法比较" class="headerlink" title="sleep() 方法和 wait() 方法比较"></a>sleep() 方法和 wait() 方法比较</h2><p>相同点：都可以暂停线程的执行</p>
<p>区别：</p>
<ul>
<li>sleep() 方法没有释放锁，而 wait() 方法释放了锁</li>
<li>sleep() 通常被用于暂停执行，wait() 通常被用于线程间交互&#x2F;通信</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。</li>
</ul>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="使用-synchronized-关键字"><a href="#使用-synchronized-关键字" class="headerlink" title="使用 synchronized 关键字"></a>使用 synchronized 关键字</h2><p><strong>修饰实例方法</strong>：作用于当前对象实例加锁。synchronized void method()</p>
<p><strong>修饰静态方法</strong>：也就是给当前类加锁。synchronized static void method()</p>
<p><strong>修饰代码块</strong>：synchronized(…){}</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在 Java 早期版本中，synchronized 属于 <strong>重量级锁</strong>，效率低下。</p>
<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p>monitor 对象存在于每个 Java 对象的对象头中，具体来说，对象头中存储着指向该对象的 monitor 的指针。</p>
<p>monitor 对象内部包含一个计数器。</p>
<p>当一个线程尝试获取 monitor 的所有权，即执行 monitorenter 指令</p>
<ul>
<li>如果计数器为 0 则可以成功获取，获取后将计数器加1。</li>
<li>如果该线程已经占有该 monitor，计数器加1；（synchronized 的可重入性）</li>
<li>如果 monitor 被其他线程所占有，那么该线程会被阻塞，直到该 monitor 的计数器变为 0，此时该线程会再次尝试获取该 monitor。</li>
</ul>
<p>对于已经获取 monitor 的线程，执行 monitorexit 指令后，不断将锁计数器减 1 直到为 0，表明锁被释放。</p>
<blockquote>
<p>monitor 的性能</p>
<p>监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，这导致从用户模式转换到内核模式。</p>
<p>CPU 模式转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”</p>
</blockquote>
<h3 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h3><p>修饰代码块：通过 monitorenter 和 monitorexit 指令，指明同步代码块的开始和结束位置。当线程执行该方法时，线程需要先获取monitor，获取成功后才能调用方法，方法执行完后再释放monitor。</p>
<p>修饰方法：用 ACC_SYNCHRONIZED 标识指明该方法是一个同步方法。当线程执行该方法时，线程需要先获取monitor，获取成功后才能调用方法，方法执行完后再释放monitor。用一种隐式的方式来实现，而不是显式地通过字节码指令 monitorenter 和 monitorexit。</p>
<h2 id="Synchronized-的作用"><a href="#Synchronized-的作用" class="headerlink" title="Synchronized 的作用"></a>Synchronized 的作用</h2><ol>
<li>原子性：确保线程互斥的访问同步代码；</li>
<li>可见性：保证共享变量的修改能够及时可见，Synchronized 块内部的共享变量或者 Synchronized 方法内部用到的共享变量都会保证可见性；</li>
<li>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”</li>
</ol>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>Java 6 之后官方从 JVM 层面（体现在对象头）对 synchronized 进行优化。如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。（锁膨胀）</p>
<p>无锁：实现方式是 CAS</p>
<p>偏向锁</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p><strong>轻量级锁</strong></p>
<p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。（两个线程？）</p>
<p>重量级锁<br>重量级锁是由轻量级锁升级而来，当同一时间有<strong>多个线程</strong>竞争锁时，锁就会被升级成重量级锁，此时其<br>申请锁带来的开销也就变大。</p>
<h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p>
<p><img src="/2022/04/07/Java-Concurrency/1647570341727-faad309d-e71b-4729-88ff-de337d9a0cc2.jpeg"></p>
<p>无锁：实现方式是 CAS</p>
<p>偏向锁</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p><strong>轻量级锁</strong></p>
<p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<h2 id="synchronized-和-ReentrantLock-的对比"><a href="#synchronized-和-ReentrantLock-的对比" class="headerlink" title="synchronized 和 ReentrantLock 的对比"></a>synchronized 和 ReentrantLock 的对比</h2><p>相同：两者都是可重入锁</p>
<p>区别：</p>
<ul>
<li><p>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</p>
</li>
<li><p>synchronized 是依赖于 JVM 实现的，ReentrantLock 是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成</p>
<blockquote>
<p>ReetrantLock 实现依赖于 AQS(AbstractQueuedSynchronizer)。ReetrantLock 主要依靠 AQS 维护一个阻塞队列，多个线程对加锁时，失败则会进入阻塞队列。等待唤醒，重新尝试加锁。</p>
</blockquote>
</li>
<li><p>synchronized 不需要手动获取锁和释放锁，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果没有正确释放锁会造成死锁。</p>
</li>
<li><p>ReentrantLock 比 synchronized 增加了一些高级功能。</p>
<ul>
<li>等待可中断：可以设置线程等待锁的时间，超时可以放弃等待处理其他事情</li>
<li>synchronized 是非公平锁，ReentrantLock 可以指定是公平锁还是非公平锁。所谓的公平锁就是先等待的线程先获得锁。默认情况是非公平的，可以通过类的构造方法来设置。</li>
<li><strong>可实现选择性通知</strong>: 一个锁可以绑定多个 Condition 对象，对特定的 Condition 对象调用 .signal()，可以指定唤醒等待在该  Condition 对象上的线程。而 synchronized，只能对锁对象，如 this，调用 this.notifyAll()，唤醒绑定该锁的所有线程，无法选择具体唤醒的线程。</li>
</ul>
<p>  ReentrantLock 在获得锁的时候用到了 CAS（公平或者非公平方式），但是这只是为了获得锁的时候同步，并不是为了对用到ReentrantLock的代码块同步。ReentrantLock 用 CAS 方式获得锁之后，其他线程不能获取锁，所以是悲观锁。</p>
</li>
</ul>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile 保证可见性和有序性。</p>
<p>可见性：每次更新到主存，从主存读取</p>
<p>有序性</p>
<p>涉及到 volatile 的代码才能防止重排列（代码等价于多条指令，从指令的角度防止）</p>
<p>这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS 全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent 包中的原子类就是通过 CAS 来实现了乐观锁。</p>
<p>它是一条 CPU 同步原语。是一种硬件对并发的支持（<strong>通过硬件来实现执行的原子性</strong>）</p>
<p>CAS 算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值 V。</li>
<li>进行比较的值 A。</li>
<li>要写入的新值 B。</li>
</ul>
<p>当且仅当 V 的值等于 A 时，用新值 B 来更新 V 的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作（自旋）。</p>
<h2 id="CAS-存在的问题"><a href="#CAS-存在的问题" class="headerlink" title="CAS 存在的问题"></a>CAS 存在的问题</h2><p>CAS虽然很高效，但是它也存在三大问题：</p>
<ul>
<li><p>ABA 问题。CAS 需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是 A，后来变成了 B，然后又变成了 A，那么CAS 进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA 问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p>
<blockquote>
<p>JDK 从 1.5 开始提供了 AtomicStampedReference 类来解决 ABA 问题，具体操作封装在compareAndSet() 中。compareAndSet() 首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</p>
</blockquote>
</li>
<li><p><strong>循环时间长开销大</strong>。CAS 操作如果长时间不成功，会导致其一直自旋，给 CPU 带来非常大的开销。 可以采用适应性自旋，控制自旋时间。</p>
</li>
<li><p>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p>
<blockquote>
<p> Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>
</blockquote>
</li>
</ul>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal，即线程本地变量。如果你创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题（不再是共享变量）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//创建一个ThreadLocal变量</span><br><span class="line">// 注意用 static 修饰，但是使用的时候却不是共享变量</span><br><span class="line">static ThreadLocal&lt;T&gt;localVariable=new ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p>每个线程都有一个 Thread.ThreadLocalMap 类的成员变量，该变量内部维护了 Entry 数组，key 是 ThreadLocal对象的引用，value是 ThreadLocal 对象的值。</p>
<p>每个线程在访问 ThreadLocal 的时候，都是访问自己的 ThreadLocalMap 里的键值对。也就是，根据 ThreadLocal 对象的引用，以此作为 key，查找自己的 Entry 数组那个键值对。</p>
<p><img src="/2022/04/07/Java-Concurrency/1647934439309-8240096e-733c-4245-a388-d25be535f9e2.png" alt="ThreadLocal 原理"></p>
<h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用</p>
<blockquote>
<p>弱引用：只要垃圾回收机制一运行，不管 JVM 的内存空间是否充足，都会回收该对象占用的内存。</p>
</blockquote>
<p>弱引用比较容易被回收。因此，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是因为ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：</p>
<p>ThreadLocalMap的key没了，value还在，这就会「造成了内存泄漏问题」。</p>
<p>如何「解决内存泄漏问题」？使用完ThreadLocal后，及时调用remove()方法释放内存空间</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>使用线程池的好处</strong></p>
<ul>
<li><p>降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
</ul>
<h2 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h2><p><strong>corePoolSize</strong>：最小可以同时运行的线程数量。</p>
<p><strong>workQueue</strong>：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。工作队列即阻塞队列。</p>
<p><strong>maximumPoolSize</strong>：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</p>
<p><strong>defaultHandler</strong>：饱和策略。如果阻塞队列已满，且当前线程数&gt;&#x3D;maximumPoolSize，执行饱和策略</p>
<ul>
<li>AbortPolicy ： 线程任务丢弃并报错。默认饱和策略。</li>
<li>DiscardPolicy ： 线程任务直接丢弃不报错。</li>
<li>DiscardOldestPolicy ： 将 workQueue 队首任务丢弃，将最新线程任务重新加入队列执行。</li>
<li>CallerRunsPolicy ：线程池之外的线程直接调用 run 方法执行。</li>
</ul>
<h2 id="线程池大小如何设置"><a href="#线程池大小如何设置" class="headerlink" title="线程池大小如何设置"></a>线程池大小如何设置</h2><p>CPU密集型任务（N+1）：这种任务消耗的主要是CPU资源，可以将线程数设置为 N（CPU核心数）+1，多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU的空闲时间。</p>
<p>I&#x2F;O密集型任务（2N）：线程进行 I&#x2F;O 时需要等待 IO 结果，等待的时间内无法做其他事情，这时就可以将 CPU 交出给其它线程使用。</p>
<h2 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h2><ul>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO,LIFO,优先级）执行。</li>
</ul>
<h2 id="execute-和-sub-mit-比较"><a href="#execute-和-sub-mit-比较" class="headerlink" title="execute() 和 sub mit() 比较"></a>execute() 和 sub mit() 比较</h2><p>execute() 用于提交不需要返回值的任务，所以无法判断任务是否被线程池成功执行；</p>
<p>submit() 用于提交需要返回值的任务。线程池会返回一个Future 对象，表示异步计算的结果。通过这个对象可以判断任务是否执行成功，并且可以通过 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，get() 也可以设置阻塞时间，在一定时间后立即返回，这时候有可能任务没有执行完。</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS 底层是由同步队列 + 条件队列联手组成，同步队列管理着获取不到锁的线程的排队和释放，<br>条件队列是在一定场景下，对同步队列的补充，比如获得锁的线程从空队列中拿数据，肯定是拿不<br>到数据的，这时候条件队列就会管理该线程，使该线程阻塞</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-06 14:39:51" itemprop="dateCreated datePublished" datetime="2022-04-06T14:39:51+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-08 16:41:22" itemprop="dateModified" datetime="2022-04-08T16:41:22+08:00">2022-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构，便于对数据进行定位。</p>
<p>例如，对于students表，如果要经常根据score列进行查询，就可以对score列创建索引：</p>
<p>ALTER TABLE students</p>
<p>ADD INDEX idx_score (score);</p>
<p>使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。</p>
<h2 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h2><p>优点：提高了查询效率</p>
<p>缺点：</p>
<ul>
<li><p>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增删改的时候，索引也要更新；</p>
</li>
<li><p>空间方面：索引需要占物理空间。</p>
</li>
</ul>
<h2 id="MySQL-的索引类型"><a href="#MySQL-的索引类型" class="headerlink" title="MySQL 的索引类型"></a>MySQL 的索引类型</h2><ol>
<li><p>从数据结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引</p>
</li>
<li><p>从应用层次来分：普通索引，唯一索引，复合索引。</p>
<p> 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引<br> 唯一索引：索引列的值必须唯一，但允许有空值<br> 复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</p>
</li>
<li><p>根据中数据的物理顺序与键值的逻辑（索引）顺序关系： 聚集索引，非聚集索引</p>
</li>
</ol>
<h2 id="索引数据结构选择-B-树的原因"><a href="#索引数据结构选择-B-树的原因" class="headerlink" title="索引数据结构选择 B+ 树的原因"></a>索引数据结构选择 B+ 树的原因</h2><p>B+ 树与 B 树相比：</p>
<ul>
<li><p>B+ 树的磁盘读写代价更低：B+ 树的内部节点没有关键字对应的数据信息，因此其内部节点相对 B 树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多（相当于分叉数可以更多），一次性读入内存中可以查找的关键字也就越多，相对 IO 读写次数就降低了。</p>
<blockquote>
<p>读写磁盘会阻塞线程，因为耗时较长。而读写内存不会阻塞。</p>
<p>MySQL 使用磁盘存储数据，需要考虑磁盘读写性能，而 Redis 不需要</p>
<p>IO 读写次数：每次根据孩子指针来查找磁盘元素都是一次对磁盘的读取操作。因此，实际上，树的高度越小，IO 读写次数也越小</p>
</blockquote>
<blockquote>
<p>结点存储数据信息的方式：</p>
<p>假设表：</p>
<p>name score</p>
<p>A         99</p>
<p>B         84</p>
<p>如果建立 score 列的索引，则结点的值为 score 字段的值，叶子结点存放数据信息，可以存放 score 对应的记录，也可以存放指向对应记录的指针</p>
</blockquote>
</li>
<li><p>B+ 树的数据存储在叶子结点中，并且叶子节点构成了双向链表，适合区间查询。而 B 树若要查找区间数据，对于区间内的每个数据，都要二分搜索一次 B 树。</p>
</li>
</ul>
<p>B+ 树与红黑树相比：</p>
<ul>
<li>虽然查找复杂度都是 O(h&#x3D;logN)，但是B+ 树是多叉树，相同结点个数情况下，B+ 树的高度比红黑树小。从O(h) 来看，B+ 树的查找效率更高。从 O(logN) 来看，实际上底数不同</li>
<li>红黑树不适合区间查询</li>
</ul>
<p>B+ 树与 Hash 相比：</p>
<p>Hash 的优点：适合等值查询，没有哈希冲突时，等值查询的速度很快</p>
<p>Hash 的缺点：</p>
<ul>
<li><p>Hash 是无序的数据结构，不支持区间查询，也无法利用索引进行排序</p>
</li>
<li><p>不支持多列联合索引。对于联合索引，从哈希的角度来说，多个键值统一映射到一个 hash 值，并不会有层次。Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，不会针对每个索引单独计算 Hash 值。因此不支持部分索引列的匹配查找；</p>
</li>
<li><p>如果有大量重复键值，存在哈希碰撞问题 。</p>
</li>
</ul>
<p>跳表</p>
<p><img src="/2022/04/06/MySQL/v2-d679e616dd3312da3d002d555e3c0b7c_720w.jpg" alt="跳表内部存储结构"></p>
<p>跳表空间复杂度：O(N)，各层的结点个数可以看成等比数列，最底层存放了所有结点</p>
<p>支持区间查询：O(logN) 找到起点或终点然后遍历即可</p>
<p>Redis 作者的话：跳表更容易实现，代码可读性好</p>
<p>跳表的出现时间比 mysql innodb 晚</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>可以使用多个字段同时建立一个索引，叫做联合索引。</p>
<p>ALTER TABLE students</p>
<p>ADD INDEX idx_name_score (name, score);</p>
<p>这里表示两个单独的索引列name和score。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>最左前缀原则的意思是：</p>
<ul>
<li>在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用才能命中索引。</li>
<li>注意范围查询和等值查询的影响。mysql 会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如 a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立 (a,b,c,d) 顺序的索引，d &#x3D; 4 是用不到索引的，如果建立 (a,b,d,c) 的索引则可以用到。</li>
</ul>
<p>具体原因为：</p>
<ul>
<li><p>假设现在建立了”name，age，school”的联合索引，那么索引的排序为：先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>
<p>  当进行查询时，此时索引仅仅按照 name 严格有序，因此必须首先使用 name 字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。</p>
</li>
<li><p>当走到 c &gt; 3，实际上取出的行仅在 c 相等的行，d有序，而 c 不相等的行，d 不保证有序。也就是说，此时的索引按照 d 列是无序的，无法使用索引。</p>
</li>
</ul>
<blockquote>
<p>总结：mysql 的查询优化器会对等值查询（查询 &#x3D; ）进行分析，使用正确的顺序进行查询</p>
<p>假设对 student 表建立了 (name, cid) 的联合索引，</p>
<p>执行查询语句为</p>
<p>SELECT * FROM student WHERE cid&#x3D;1 AND name&#x3D;‘小红’;</p>
<p>虽然查询顺序并不按照 (name, cid)，但是由于对 name 字段进行的是等值查询，因此 mysql 查询优化器会判断在 name 字段进行等值查询时，对于相同的 name，表已经按照 cid 有序排列，可以命中索引。因此，该语句能正确返回结果。</p>
<p>执行查询语句为</p>
<p>SELECT * FROM student WHERE cid&#x3D;1;</p>
<p>无法返回结果。单纯的 cid 是无序的。</p>
</blockquote>
<h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p>在 InnoDB 里，索引 B+ 树的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。</p>
<p>聚簇索引与非聚簇索引的区别：</p>
<p>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的<br>主键（行号） </p>
<p>对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集<br>索引查找数据的过程，我们称为回表。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回</p>
<p>表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。<br>通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询<br>多次。当然，如果是覆盖索引的话，查一次即可<br>注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二<br>级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。</p>
<h2 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h2><p>基本：</p>
<ul>
<li><p>非空字段：<strong>应该指定列为NOT NULL，除非你想存储NULL</strong>。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p>
</li>
<li><p>字段取值差异大的列放到联合索引的前面：可以通过 count() 函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。</p>
</li>
<li><p>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p>
</li>
<li><p>避免索引失效的发生。</p>
</li>
</ul>
<p>对于联合索引，将查询需求频繁或者字段取值差异大的列放在前面。</p>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>索引失效，即查询语句用到了索引列，但是无法用到已经建立的索引。</p>
<ul>
<li><p>计算导致索引失效。包括使用函数、运算符。以使用运算符为例</p>
<p>  例如对 score 列建立了索引，想要查询 score*2 &lt; 100 的记录，不能写：</p>
<p>  SELECT * FROM student WHERE score*2 &lt;  100; 会导致遍历整个表计算并且判断</p>
<p>  而应该写</p>
<p>  SELECT * FROM student WHERE score &lt;  50; 这种写法才能用到索引</p>
</li>
<li><p>类型不一致导致索引失效。</p>
<p>  SELECT * FROM student  WHERE name &#x3D; ABC，ABC 不是字符串</p>
</li>
<li><p>OR引起的索引失效 </p>
<p>  如果 OR 连接的是同一个字段，那么索引不会失效，反之索引失效。</p>
<p>  SELECT * FROM <code>user</code> WHERE <code>name</code> &#x3D; ‘张三’ OR height &#x3D; ‘175’;</p>
</li>
</ul>
<h1 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h1><h2 id="数据库的三范式"><a href="#数据库的三范式" class="headerlink" title="数据库的三范式"></a>数据库的三范式</h2><p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</p>
<p>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</p>
<p>第三范式：任何非主属性不依赖于其它非主属性。</p>
<h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><p>与 MyISAM 相比，InnoDB</p>
<ul>
<li>支持行级锁（默认），加锁粒度小，并发度高。但加锁的开销也最大，加锁慢</li>
<li>支持事务</li>
<li>支持崩溃恢复，恢复的过程依赖于 redo log 。</li>
<li>采用聚簇索引，叶子结点存储行记录，可直接获得数据（非聚簇索引要跳转）。</li>
</ul>
<p>InnoDB 支持外键，而 MyISAM 不支持</p>
<p>Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；<br>InnoDB 不保存表的具体行数，MyISAM 用一个变量保存了整个表的行数。</p>
<h2 id="超键、候选键、主键、外键"><a href="#超键、候选键、主键、外键" class="headerlink" title="超键、候选键、主键、外键"></a>超键、候选键、主键、外键</h2><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
<p>候选键：是最小超键，即没有冗余元素的超键。</p>
<p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值。</p>
<p>外键：在一个表中存在的另一个表的主键称此表的外键。</p>
<h2 id="SQL-约束"><a href="#SQL-约束" class="headerlink" title="SQL 约束"></a>SQL 约束</h2><p>NOT NULL: 字段内容不能为空（NULL）。</p>
<p>UNIQUE: 字段内容不能重复，一个表允许有多个 Unique 约束。</p>
<p>PRIMARY KEY: 字段内容不能重复，但它在一个表只允许出现一个。</p>
<p>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p>
<p>CHECK: 用于控制字段的值范围。</p>
<p>MySQL中 in 和 exists 区别<br>MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对<br>内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环<br>境的。<br>如果查询的两个表大小相当，那么用in和exists差别不大。<br>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。<br>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not<br>extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p>
<p>drop、delete与truncate的区别<br>三者都表示删除，但是三者有一些差别：</p>
<p><img src="/2022/04/06/MySQL/image-20220407103015269.png"></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>何为事务？一言蔽之，事务是逻辑上的一组操作，要么都执行，要么都不执行。<br>假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p>
<ol>
<li>将小明的余额减少 1000 元</li>
<li>将小红的余额增加 1000 元。</li>
</ol>
<p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p>
<h2 id="ACID-特性"><a href="#ACID-特性" class="headerlink" title="ACID 特性"></a>ACID 特性</h2><p>关系型数据库事务都有 ACID 特性：</p>
<ol>
<li>原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部不完成；</li>
<li>一致性（Consistency）： 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h2 id="事务的实现原理-x2F-如何保证-ACID"><a href="#事务的实现原理-x2F-如何保证-ACID" class="headerlink" title="事务的实现原理&#x2F;如何保证 ACID"></a>事务的实现原理&#x2F;如何保证 ACID</h2><p>以 MySQL 的 InnoDB 引擎为例。</p>
<ul>
<li><p>MySQL InnoDB 引擎使用 redo log（重做日志） 保证事务的持久性，使用 undo log（回滚日志） 来保证事务的原子性。redo log 记录的是修改了缓存池数据页的所有命令，undo log 记录的是某个事务中所更新记录的历史版本</p>
</li>
<li><p>MySQL InnoDB 引擎通过锁机制、MVCC（多版本并发控制） 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。</p>
</li>
<li><p>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p>
</li>
</ul>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>redo log 能保证事务的持久性。</p>
<p>MySQL 中数据是以页为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。</p>
<p>后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。</p>
<p>更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。</p>
<p><img src="/2022/04/06/MySQL/1646831502098-89c9da04-564f-4e6e-85aa-6664203a0b20.png" alt="redo log 生成过程"></p>
<p>redo log 记录了数据的修改，因此可以根据日志内容恢复数据。通过刷盘，将缓存中的 redo log buffer 更新到硬盘中的 redo log 文件，这样即使数据库出现故障，redo log 也不会丢失，从而实现了持久化。</p>
<p>数据在硬盘的 paga cache 中，这个过程称之为<strong>write</strong>，数据真正持久化到磁盘这个过程称之为<strong>fsync</strong>。</p>
<blockquote>
<p>在MySQL中，为了提高数据库的性能，MySQL采用了WAL（Write-Ahead Logging）机制，即在实际写数据前，先把修改的数据记到日志文件中。MySQL的写数据是写硬盘数据，与 redis 不同，redis的写数据指的是写内存。</p>
<p>这样做的原因在于，磁盘读写速度慢。磁盘定位数据的过程可能会是磁盘的随机读，随机读的过程是非常慢的。</p>
<p>WAL机制，主要的操作是先写日志，先在一个日志中记录了MySQL要对硬盘中的存储MySQL数据的数据页中的数据进行什么样的更改，等到Mysql空闲的时候再进行同步操作到硬盘中。</p>
<p>同样是操作磁盘，为什么写日志比直接改数据会更加高效？</p>
<p>答案在于写日志是顺序写，直接改磁盘是随机写。所以同样是写，它们写的速度有着天壤之别。这也是WAL的另外一个好处。</p>
</blockquote>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log 能保证事务的原子性，和实现 MVCC（多版本并发控制）</p>
<p>对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：</p>
<ul>
<li>ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。</li>
<li>事务 ID：记录最后一次修改该记录的事务 ID。</li>
<li>回滚指针：指向这条记录的上一个版本。</li>
</ul>
<p>假设执行如下两个事务。如图，首先 insert 语句向空表 t1 中插入了一条数据，a &#x3D; 1，b &#x3D; 1， 隐式生成的 ROW ID &#x3D; 1 ，事务 ID &#x3D; 1，回滚指针&#x3D; null。当执行 update t1 set b&#x3D;666 where a&#x3D;1 时，大致步骤如下：</p>
<ul>
<li>数据库会先对满足 a&#x3D;1 的行加排他锁（对该行的隐藏字段并不加排他锁）；</li>
<li>然后将原记录复制到 undo log空间中；</li>
<li>修改 b 字段的值为 666；</li>
<li>修改事务 ID 为 2，并通过隐藏的回滚指针指向 undo log 中的历史记录；</li>
<li>事务提交，释放前面对满足 a&#x3D;1 的行所加的排他锁。</li>
</ul>
<p><img src="/2022/04/06/MySQL/1647872433220-f2c141c9-1a75-43a5-9db1-55abe39f6b97-164929795888010.png"></p>
<p>总的来说，每一行数据都有一个隐藏的回滚指针，用于指向该行的上一个版本，这个版本的记录存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。</p>
<p>实现回滚：对同一行记录的不断更新，undo log 中的历史记录实际上会形成一个链表。因此，遍历链表逐步回滚即可。</p>
<p>实现 MVCC：其它事务此时（即事务未提交时）若需要查询，根据回滚指针查询 undo log 中这行数据的上一个历史版本。（由于记录的隐藏字段没有加排他锁，所以可以访问回滚指针）。MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。</p>
<h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><p>MySQL的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。</p>
<p>binlog 有三种格式：</p>
<p>statement： 基于 SQL 语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程可能导致数据不一致甚至出错。</p>
<p>row： 基于行的模式，记录的是行的变化，很安全。但是 binlog 会比其他两种模式大很多，在一些大表中清除大量数据时在 binlog 中会生成很多条语句，可能导致从库延迟变大。</p>
<p>mixed： 混合模式，根据语句来选用是 statement 还是 row 模式。</p>
<h4 id="bin-log-与-redo-log-的区别"><a href="#bin-log-与-redo-log-的区别" class="headerlink" title="bin log 与 redo log 的区别"></a>bin log 与 redo log 的区别</h4><ol>
<li>binlog是MySQL数据库的上层产生的，任何存储引擎对于数据库的更改都会产生二进制日志。redo log是在InnoDB存储引擎层产生</li>
<li>两种日志记录的内容形式不同。MySQL的binlog是逻辑日志，其记录是对应的SQL语句。而innodb存储引擎层面的重做日志是物理日志。</li>
<li>两种日志与记录写入磁盘的时间点不同，二进制日志只在事务提交完成后进行一次写入。而innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的。</li>
</ol>
<p>二进制日志仅在事务提交时记录，并且对于每一个事务，仅在事务提交时记录，并且对于每一个事务，仅包含对应事务的一个日志。而对于innodb存储引擎的重做日志，由于其记录是物理操作日志，因此每个事务对应多个日志条目，并且事务的重做日志写入是并发的，并非在事务提交时写入，其在文件中记录的顺序并非是事务开始的顺序。</p>
<p>第四：binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，redo log是循环使用。</p>
<h2 id="并发事务带来哪些问题？"><a href="#并发事务带来哪些问题？" class="headerlink" title="并发事务带来哪些问题？"></a>并发事务带来哪些问题？</h2><p>脏读（Dirty Read）。一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据</p>
<p>不可重复读（Unrepeatable read）：在一个事务内，多次读同一数据，读取的数据不一致。</p>
<p>幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更</p>
<p>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据</p>
<p>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改</p>
<p>SERIALIZABLE(可串行化)： 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p><strong>隔离级别与锁的关系</strong></p>
<p>修改数据都会加写锁&#x2F;排他锁</p>
<p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p>
<p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p>
<p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p>
<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="为什么要分库分表？"><a href="#为什么要分库分表？" class="headerlink" title="为什么要分库分表？"></a>为什么要分库分表？</h2><p>分表</p>
<p>单表数据量太大，会极大影响 sql执行的性能。</p>
<p>分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p>
<p>分库</p>
<p>分库就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p>
<h2 id="垂直拆分和水平拆分"><a href="#垂直拆分和水平拆分" class="headerlink" title="垂直拆分和水平拆分"></a>垂直拆分和水平拆分</h2><p>水平拆分</p>
<ul>
<li>对于表来说，就是按行拆分。对于库来说，就是对库里的每个表这么做。</li>
<li>水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。</li>
</ul>
<p>垂直拆分</p>
<ul>
<li>就是按列&#x2F;字段拆分，每个表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。</li>
<li>因为数据库是有缓存的，访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/Virtualization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/Virtualization/" class="post-title-link" itemprop="url">虚拟化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-05 22:39:49" itemprop="dateCreated datePublished" datetime="2022-04-05T22:39:49+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-08 16:41:29" itemprop="dateModified" datetime="2022-04-08T16:41:29+08:00">2022-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h1 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h1><p>以 32 位操作系统举例，它的寻址空间为 4G &#x3D; 2 的 32 次方，一个字节大小的内存单元对应一个地址</p>
<p>为什么叫虚拟，因为物理内存一共就 4G，但操作系统为<strong>每一个进程都分配了4G的内存空间，这个内存空间是虚拟的</strong>。以 linux 操作系统为例，每个进程 4G 的虚拟内存，将最高的 1G 字节供内核使用，称为内核空间，而将较低的 3G 字节，供各个进程使用，称为用户空间。</p>
<blockquote>
<p>如果你在一个程序中打印出一个地址，那只是一个虚拟地址。虚拟地址只是提供地址如何在内存中分布的假象，只有操作系统（和硬件）才知道物理地址。</p>
</blockquote>
<h2 id="虚拟地址空间的构成"><a href="#虚拟地址空间的构成" class="headerlink" title="虚拟地址空间的构成"></a>虚拟地址空间的构成</h2><p>内核空间和用户空间</p>
<p><img src="/2022/04/05/Virtualization/1642770176746-362621fb-2a65-447d-a7e6-d0f10f18e8f6.png" alt="内核空间和用户空间"></p>
<p><strong>用户空间</strong></p>
<p>代码：编译链接生成的可执行文件是汇编指令，汇编指令以二进制形式装载到内存中，每条指令可用几个字节存储。</p>
<p>栈：存放临时变量。通过栈的推入和弹出处理临时变量</p>
<p>堆：非局部变量生命周期较长，通常很多个方法中都会用到，由程序员自主使用内存 API 函数分配回收。</p>
<p>静态区（全局区）：存储全局变量和静态变量，分为初始化和未初始化两个分区。</p>
<blockquote>
<p>图示堆栈生长方式只是一种约定，当多个线程（threads）在地址空间中共存时，就没有像这样分配空间的好办法了</p>
<p><strong>虚拟空间地址连续，会映射到不连续的物理空间</strong></p>
</blockquote>
<p><strong>内核空间</strong></p>
<p>与进程相关的数据结构。例如<strong>页表、进程控制块、内核栈</strong>等</p>
<p>操作系统是一个程序，但不能称作进程。它管理着进程，进程是有生命周期的，操作系统是永存的。<strong>操作系统的运行也同样要占用CPU</strong></p>
<p>在操作系统这个程序中，为了跟踪每个进程的状态，使用了如下数据结构</p>
<ul>
<li>进程控制块（PCB， process control block）</li>
<li>进程列表（process list）</li>
</ul>
<p>如下是一个进程控制块，进程控制块包括了上下文信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 寄存器上下文（register context）</span><br><span class="line">// the registers xv6 will save and restore </span><br><span class="line">// to stop and subsequently restart a process </span><br><span class="line">struct context &#123; </span><br><span class="line">  int eip; </span><br><span class="line">  int esp; </span><br><span class="line">  int ebp; </span><br><span class="line">  </span><br><span class="line">  int ebx; </span><br><span class="line">  int ecx; </span><br><span class="line">  int edx; </span><br><span class="line">  </span><br><span class="line">  int esi; </span><br><span class="line">  int edi; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">// 进程状态枚举</span><br><span class="line">enum proc_state &#123; UNUSED, EMBRYO, SLEEPING, </span><br><span class="line">                  RUNNABLE, RUNNING, ZOMBIE &#125;; </span><br><span class="line"> </span><br><span class="line">// the information xv6 tracks about each process </span><br><span class="line">// including its register context and state </span><br><span class="line">struct proc &#123; </span><br><span class="line">	// 内存设置</span><br><span class="line">  char *mem;                   // Start of process memory </span><br><span class="line">  uint sz;                     // Size of process memory </span><br><span class="line">  </span><br><span class="line">  char *kstack;                // Bottom of kernel stack </span><br><span class="line">                               // for this process </span><br><span class="line">                              </span><br><span class="line">  enum proc_state state;       // Process state </span><br><span class="line">  int pid;                     // Process ID </span><br><span class="line">  struct proc *parent;         // Parent process </span><br><span class="line">  void *chan;                  // If non-zero, sleeping on chan </span><br><span class="line">  int killed;                  // If non-zero, have been killed </span><br><span class="line">  </span><br><span class="line">  struct file *ofile[NOFILE];  // Open files</span><br><span class="line">  struct inode *cwd;           // Current directory </span><br><span class="line">  </span><br><span class="line">  struct context context;      // // 上下文切换 </span><br><span class="line">  struct trapframe *tf;        // Trap frame（栈帧） for the current interrupt</span><br><span class="line">                               // 栈帧也是一个包含多个寄存器的结构体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="内核空间和用户空间的切换"><a href="#内核空间和用户空间的切换" class="headerlink" title="内核空间和用户空间的切换"></a>内核空间和用户空间的切换</h3><p><strong>模式切换</strong>：仅仅需要寄存器进栈出栈，不会导致CPU中的数据缓存失效、MMU中的页表缓存失效</p>
<p><strong>进程切换</strong>：不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、MMU中的页表缓存失效（缓存失效是必须的，因为要切换到另一个进程的地址空间）</p>
<blockquote>
<p>缓存失效的后果：对内存的访问变得低效</p>
<p>代码里面具有各个语句和各个变量的虚拟地址，当进程切换之后，页表也会更新，根据自己进程的页表来找物理内存</p>
</blockquote>
<p>为什么虚拟地址空间切换会比较耗时</p>
<p>当进程切换后页表也要进行切换，页表切换后 TLB 就失效了，页表缓存失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程无需切换地址空间。</p>
<p>内核和用户程序共享地址空间：发生系统调用时进行的是模式切换而非进程切换。</p>
<p>不同的进程共享内核空间：进程A切换到进程B时把进程信息PCBA压入内核栈，进程B切换到进程C时把进程信息PCBB压入内核栈，然后要恢复的时候依次从内核栈弹出PCBB、PCBA。同一个内核栈。用户空间通过页表切换（页表信息也可当作处于PCB中），而内核空间不会。</p>
<p>在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先用户空间中的栈，而是一个内核空间的栈，这个称作进程的内核栈。</p>
<p>用户空间通过异常&#x2F;中断进入内核空间的时候都需要保存现场，也就是保存发生异常&#x2F;中断时的所有通用寄存器的值到每个进程特有的进程内核栈（一块内存），然后将即将执行的进程的寄存器的值从另一块内存中恢复到相应寄存器中（区分内存和CPU寄存器）。</p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>调度：进程是资源管理的基本单位，线程是程序执行的基本单位。</p>
<p>系统开销：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I&#x2F;O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销</p>
<p>进程切换分两步：</p>
<ol>
<li>切换页表以使用新的地址空间，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。</li>
<li>切换内核栈和硬件上下文（例如进程控制块和线程控制块）。</li>
<li>对于线程切换，第1步是不需要做的（因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换），第2步是进程和线程切换都要做的。</li>
</ol>
<h3 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h3><p>程序中调用时发生系统调用</p>
<p>fork</p>
<ul>
<li><p>一个现有进程可以调用 fork() 创建一个新进程，该新进程被称为<strong>子进程</strong>（child process），调用fork的进程称为<strong>父进程</strong>。</p>
</li>
<li><p>子进程通过拷贝的方式，获得 此时的 父进程地址空间副本（包括堆、栈等资源）。</p>
</li>
<li><ul>
<li>父进程处于等待 fork 返回的状态。因此，子进程复制之后，在 fork() 被调用之前的代码不会被执行，且两个进程都停留在 fork 函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回<ul>
<li>子进程中返回 0，而父进程中返回子进程 ID。</li>
</ul>
</li>
</ul>
</li>
<li><p>作用：运行相同程序的拷贝</p>
</li>
</ul>
<p>exec</p>
<ul>
<li><p>exec指的是一个函数簇，包括execlp()、execv()和execvp()等</p>
</li>
<li><p>函数原型：</p>
<p>  int execvp(const char *file, char *const argv[]); &#x2F;&#x2F; file为需要运行的文件名，argv[]为输入的参数列表</p>
</li>
<li><p>给定可执行程序的名称及该程序需要的参数后，exec() 会从该程序中加载代码和静态数据，并用它 <strong>覆写</strong> 自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新<strong>初始化</strong>。然后操作系统就执行该程序，将参数 argv 传递给该进程。——并没有创建新进程，而是直接将当前运行的程序替换为另一个程序</p>
</li>
<li><p>调用了 exec() 的程序，exec() 之后的语句不会被执行</p>
</li>
</ul>
<h2 id="虚拟地址到物理地址的映射"><a href="#虚拟地址到物理地址的映射" class="headerlink" title="虚拟地址到物理地址的映射"></a>虚拟地址到物理地址的映射</h2><p>一个基本的负责地址转换的<strong>内存管理单元</strong>（Memory Management Unit，MMU）需要包含：<strong>基址寄存器、界限寄存器</strong>。</p>
<ul>
<li>基本的映射方法：基址 + 偏移</li>
<li>每个进程分配的空间有限，并且不能访问别人的空间，因此需要<strong>界限寄存器</strong></li>
</ul>
<p>如果只使用基址和界限，为进程分配一块连续的物理内存，容易产生<strong>内部碎片</strong>（internal fragmentation），指的是<strong>已经分配的内存单元内部有未使用的空间</strong>（即碎片），造成了浪费。主要是堆栈空间冗余。</p>
<p>进程需要把用到的基址和界限寄存器中的内容保存在内存中，放在某种每个进程都有的结构中，例如进程控制块（Process Control Block，PCB）中。类似地，当操作系统恢复执行某个进程时（或第一次执行），也必须给基址和界限寄存器设置正确的值。</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>为了减少内部碎片，可以采用<strong>分段</strong>（segmentation）的方法为进程分配内存。分段法将用户空间看成几个段的组合，每个段具有自己的基址和界限，不同段分配的空间可以不连续。</p>
<p><img src="/2022/04/05/Virtualization/1643438704868-7d431f3d-de31-497f-8400-36fd33dbc504.png" alt="段寄存器"></p>
<p>注意到栈向低地址生长，地址范围 28 KB ~ 26 KB。其他段向高地址生长。如果试图访问的虚拟地址不在段内，会发生段异常（segmentation violation）或段错误（segmentation fault）</p>
<p>分段只能减少内部碎片，而不能完全避免内部碎片，总得多分配一点保证程序运行。</p>
<p>分段的问题</p>
<ul>
<li><p>分段操作相关的寄存器在每次 cpu 模式切换时需要存储和恢复</p>
</li>
<li><p>段不连续且不均匀分配，导致物理内存在各个位置充满大小不一致的碎片，因而很难将物理内存分配给新的段，或扩大已有的段。这种问题被称为<strong>外部碎片</strong>。</p>
<blockquote>
<p>解决方法：紧凑、空闲列表管理</p>
</blockquote>
</li>
</ul>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>为虚拟空间分配物理内存时以页（page）为单位分配。即将虚拟空间分成多个页，每个页对应一个物理帧。</p>
<p>页表（page table）保存了<strong>页</strong>（<strong>虚拟</strong>地址空间）和物理帧（<strong>物理内存</strong>空间）的映射关系。</p>
<blockquote>
<p>物理帧不是硬盘空间&#x2F;外存的单元 </p>
</blockquote>
<p>虚拟页面号（virtual page number，VPN）和页内的偏移量（offset）组成一个虚拟地址。假设进程的虚拟地址空间是 64 字节，每页大小 16 字节，共 4 个页。那么虚拟地址需要用 6 位描述，前两位是虚拟页号（VPN），用来区分不同的页，后四位区分一个页中的不同字节。例如，虚拟地址 &#x3D; 010101，VPN&#x3D;1，offset&#x3D;5，表示第 1 页第5 个字节。</p>
<p>操作系统会将物理内存分成多个物理帧，物理帧和帧内的偏移量组成一个物理地址。假设第 1 页对应的物理帧号是 7，如图所示。则虚拟地址 010101 对应的物理地址是 112+5 &#x3D; 117 &#x3D; 1110101（图中物理帧 0<del>15，16</del>31，…）</p>
<p><img src="/2022/04/05/Virtualization/1643442576051-58a6712b-62dd-4570-abec-25a272edc855.png" alt="虚拟页与物理帧的对应关系"></p>
<p>页表是一个数据表，进程创建时由操作系统为其生成对应页表（分配物理内存空间）。页表由页表项（<strong>PTE</strong>）组成，第 i 个页表项存储了 VPN &#x3D; i 的虚拟页的信息，包括：</p>
<table>
<thead>
<tr>
<th>物理帧号 PFN</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>有效位</td>
<td>是否为该虚拟页分配物理帧</td>
</tr>
<tr>
<td>存在位（present bit）</td>
<td>表示该页是否被调入内存中（有可能暂存硬盘），&#x3D;1表示被调入内存</td>
</tr>
<tr>
<td>脏位（dirty bit）</td>
<td>表示页面在调入内存后是否被修改过，供时钟置换算法及调出页面时是否要回写到外存后是否被</td>
</tr>
<tr>
<td>参考位（reference bit，也被称为访问位，accessed bit）</td>
<td>记录本页一段时间内的访问次数，或记录本页多久未被访问</td>
</tr>
</tbody></table>
<blockquote>
<p>如果有效位是1，该PTE中就会存储物理内存中相应的物理页的起始地址。如果有效位是0，且PTE中的地址为null，这表示这个虚拟页还未被分配，而如果有效位是0且PTE中有地址，那么这个地址指向该虚拟页在磁盘上的起始位置</p>
</blockquote>
<p><strong>页表在内核空间中</strong>。如果页表在用户空间，那么用户就可能自己修改页表，从而访问任何内存（其他进程专用的、操作系统专用的）</p>
<p>页式访问机制会产生两个问题</p>
<ul>
<li><p>内存访问性能：访问一个内存单元需要2次内存访问，第一次访问页表，确定数据的物理地址，第二次访问数据。访问页表的步骤可以加速。</p>
</li>
<li><p>页表大小：页表可能很大，占据大量内存，导致内存利用效率降低。</p>
</li>
</ul>
<p><strong>快表</strong></p>
<p>为了改善内存访问性能，利用局部性原理加速访问页表的步骤——将常访问的页面保存至 CPU 缓存，该缓存称为<strong>地址变换高速缓存</strong>（Translation Look-aside Buffer，TLB），又可称为快表。配置快表后，CPU 访问页面会先去查看快表内是否存在，然后再去查看主存的页表。</p>
<p>例：某一页式系统，其页表存放在主存中：</p>
<p>(1) 如果对主存的一次存取需要 1.5μs，试问实现一次页面访问时存取时间是多少？</p>
<p>答：页式访问需要访存两次，一次页表，一次数据，所以需要 1.5∗2&#x3D;3μs。</p>
<p>(2)如果系统有快表且其平均命中率为 85%，而页标项在快表查询的时间可忽略不计，试问此时的存取时间为多少？</p>
<p>答：快表命中时访存一次，未命中时访存两次，所以需要 0.85∗1.5+0.15∗3&#x3D;1.725μs。（0.85概率找到页表项，0.15概率没有找到页表项，此时需要到主存的页表再去找）</p>
<p><strong>多级页表</strong></p>
<p>页表大小问题可以通过多级页表的方法优化。</p>
<p>分割：将庞大的页表分成多张较小的页表，并设置一张页目录表。逻辑地址的虚页号进一步划分为页目录号和虚页号，页目录号用于查询页表，虚页号用于查询物理帧号。</p>
<p>按需调入：进程执行开始时只需要将页目录表调入内存，然后次级页表和页面可以在后面执行需要时再调入。同时，</p>
<p>假设有 256 个虚拟页，可以拆分为 16*16 个部分，以 16 个页表项为一页（这里是页表页，而不是之前的虚拟页）。虚页号此时是 相对虚页号，即 16 个页 0<del>15，而非绝对虚页号，即 256 个页 0</del>255</p>
<h4 id="页面置换算法-x2F-cache淘汰算法"><a href="#页面置换算法-x2F-cache淘汰算法" class="headerlink" title="页面置换算法&#x2F;cache淘汰算法"></a>页面置换算法&#x2F;cache淘汰算法</h4><p>什么是交换空间？</p>
<p>用于与内存换入换出的硬盘空间。操作系统把物理内存进行分页。当内存资源不足时，把某些页的内容转移至硬盘上的一块空间上，以释放内存空间。硬盘上的那块空间叫做交换空间（swap space）,而这一过程被称为交换。物理内存和交换空间的总容量就是虚拟内存的可用容量</p>
<p>在程序运行过程中，如果要访问的页面不在内存中（根据页表项的存在位判断），就发生缺页中断从而将该页调入内存中。此时</p>
<ul>
<li><strong>如果内存已无空闲空间</strong>，CPU通知操作系统将暂时不用的页面 <strong>换出</strong> 到外存，将腾出的内存分配给要访问的页面，要访问的页面在外存，需要将其重新 <strong>换入</strong> 内存。</li>
<li>如果内存有空闲物理页帧，操作系统将页面装入内存，并页表项填入页帧号，存在位修改为1</li>
</ul>
<blockquote>
<p>生成进程时，就要为所有页面分配物理帧，也会发生缺页中断。因此，要访问的页面不在内存中必定在外存，不会临时再生成</p>
</blockquote>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）</p>
<p><strong>局部页面置换</strong>：置换页面的选择范围仅限于 当前进程 占用的物理页面内（进程内）</p>
<p><strong>最佳</strong>（OPT, Optimal replacement algorithm）</p>
<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<p>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1 </p>
<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长</p>
<p><strong>最近最少使用</strong>（LRU, Least Recently Used）</p>
<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最少使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时</p>
<ul>
<li>页面在链表中存在，将这个页面移到链表表头。</li>
<li>页面在链表中不存在，将其插入到表头</li>
</ul>
<p>这样就能保<strong>证链表表尾的页面是最近最久未访问的</strong>。</p>
<p>实现方式：LinkedHashMap（JAVA）,使用哈希表作为缓存，对应的实际上是硬件 TLB</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<p>4，7，0，7，1，0，1，2，1，2，6</p>
<p>上方是表头，设页数上限为5。链表变化过程如图</p>
<p><img src="/2022/04/05/Virtualization/1643691165540-3cc3a1fe-245c-4ffb-997f-90d3987f7e9c.png" alt="LRU 过程示意"></p>
<p><strong>LRU 和 LFU 的优缺点</strong></p>
<p>LRU </p>
<p>优点：实现简单，通常具有高命中率</p>
<p>缺点：如果一些不常使用的数据一次性出现过多，那么链表表头都是无用的数据，从而会导致缓存命中率低下</p>
<p>LFU 缺点</p>
<ul>
<li>需要为每个记录项维护频率信息，带来额外开销</li>
<li>对突发性的稀疏流量无力，因为前期经常访问的记录已经占用了缓存，偶然的流量不太可能会被保留下来，而且过去的一些大量被访问的记录在将来也不一定会使用上，这样就一直把“坑”占着了。</li>
</ul>
<p>LFU优点：如果数据的分布在一段时间内是固定的话，那么LFU可以达到最高的命中率</p>
<p><strong>先进先出</strong></p>
<p>使用队列，最新进入的页面放在表尾，最早进入的页面放在表头。当缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。</p>
<ul>
<li>问题 可能会把有用的页面淘汰掉。（即此时加入的页面之前已存在）</li>
<li>改进 第二次机会算法（SCR，Second Chance Replacement Policy），基于 second chance 位维护最早页面指针</li>
</ul>
<p>第二次机会算法</p>
<p>数据结构：链表、最早页面指针</p>
<p>每个页面有一个 second chance 位，也叫做引用位。上面叫做 参考位&#x2F;访问位</p>
<p>当一个页面被二次引用，它的 second chance 位设置为1。这表示该页面后面还有可能会被引用到，所以下次置换先跳过这个页面，也就是再给它一次机会留在内存中。这样可以减少页面置换。</p>
<p>步骤</p>
<ul>
<li><p>引用一个界面时，先用一个 遍历指针 从头到尾查找页面在链表中是否存在</p>
</li>
<li><ul>
<li>如果到尾部、未查找到、且有剩余空间，加入页面，它的 second chance 被设置为 0，最早页面指针后移一位<ul>
<li>如果已经分配物理内存&#x2F;在链表中，它的 second chance 被设置为1</li>
<li>如果到尾部、未查找到、且无剩余空间。需要替换内存中的一个页面，从 <strong>最早页面指针</strong> 往后查找可以被替换的页面：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果页面的 second chance 是1，那么置为0，最早页面指针后移一位；<ul>
<li>如果页面的 second chance 是0，那么将这个页面置换出去，最早页面指针后移一位。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意下图中 最早页面指针（蓝色箭头） 的变化</p>
<p><img src="/2022/04/05/Virtualization/1643693169495-5747d18e-5424-4b59-9b6c-09bdb5590391.png" alt="第二次机会算法"></p>
<h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p><strong>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</strong></p>
<p>虚拟地址空间首先划分为若干个段，每段都有自己的段号，然后每段分成若干个大小固定的页，相应的内存划分为和页面大小的物理帧。</p>
<p>逻辑地址结构</p>
<p>段页式的逻辑地址由段号(segment)、虚页号(virtual page number) 和页内偏移(offset) 组成</p>
<p>硬件支持</p>
<p>段页式存储管理方式的硬件支持包括段表和页表。段表项代表进程的一个段，段表项包括段号、段长，但<strong>段基址实际上是页表基址</strong>。</p>
<p>例如，段基址指向页表的第 2 个页表项，虚页号为 3，则找到第 5 个页表项。虚页号是相对虚页号，而非绝对虚页号。</p>
<h1 id="虚拟-CPU"><a href="#虚拟-CPU" class="headerlink" title="虚拟 CPU"></a>虚拟 CPU</h1><p>采用时分共享，每个进程轮流运行一段时间，进程并发执行，产生有多个 CPU 的假象</p>
<p>安全：在进程占用 CPU 时，对它的权限进行限制；</p>
<p>可控：操作系统能控制进程的运行。时分共享 CPU 方式存在的问题 —— <strong>如果一个进程在CPU 上运行，这就意味着操作系统没有运行。</strong></p>
<p>手段—— <strong>CPU 双模式</strong>（安全）、<strong>控制权转移</strong>（可控）</p>
<h2 id="CPU-双模式"><a href="#CPU-双模式" class="headerlink" title="CPU 双模式"></a>CPU 双模式</h2><p>将操作系统的运行状态分为用户态和内核态，主要是为了<strong>对访问能力进行限制</strong>，防止随意进行一些比较危险的操作导致系统的崩溃</p>
<p><strong>用户模式</strong></p>
<ul>
<li>用户空间——应用程序的代码和数据</li>
<li>可执行非特权指令</li>
</ul>
<p><strong>内核模式</strong></p>
<ul>
<li><p>内核空间——存放的是操作系统内核代码和数据（如进程控制块和进程列表等）</p>
</li>
<li><p><strong>可执行特权指令，可以访问一切内存和寄存器</strong></p>
</li>
<li><p>切换到内核模式的方式——执行系统调用</p>
<p>在用户模式执行系统调用的方式——调用操作系统提供的 API，例如读取文件、创建和销毁进程、与其他进程通信，以及分配更多内存</p>
<p>陷阱表（trap table）记录了相关处理程序的位置。</p>
<p><strong>执行系统调用将发生什么？</strong></p>
<p>执行陷阱指令，进入内核模式</p>
<p>保存进程信息（例如进程控制块）到内核栈<br>- 查找陷阱表，执行对应处理程序<br>执行从陷阱返回指令，从内核栈恢复寄存器，回到用户模式</p>
</li>
</ul>
<p>当陷入内核，执行的都属于操作系统的程序，相当于操作系统接管了 CPU</p>
<p><img src="https://cdn.nlark.com/yuque/__puml/19d56db61d9fe6cdb199e9e3e11ab4e7.svg"></p>
<p>Intel 的 x86 处理器 可以运行在 ring0 ~ ring3 四个不同的权限级别。不过 Linux 和 Windows 只利用了其中的两个运行级别：</p>
<p>内核模式，对应 ring0 级<br>用户模式，对应 ring3 级</p>
<h2 id="控制权转移"><a href="#控制权转移" class="headerlink" title="控制权转移"></a>控制权转移</h2><p>协作方式——程序在最后执行系统调用交还控制权</p>
<p>非协作方式——利用时钟中断重新获得控制权</p>
<p>中断的处理过程</p>
<ol>
<li>保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。</li>
<li>开中断：以便执行中断时能响应较高级别的中断请求。</li>
<li>中断处理</li>
<li>关中断：保证恢复现场时不被新中断打扰</li>
<li>恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态</li>
</ol>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度策略相关概念"><a href="#调度策略相关概念" class="headerlink" title="调度策略相关概念"></a>调度策略相关概念</h3><p><strong>抢占与非抢占</strong></p>
<p>抢占式：当有比正在运行的进程<strong>优先级</strong>更高的进程就绪时，系统可强行剥夺当前运行进程的 CPU 使用权，提供给更高优先级的进程使用。</p>
<p>非抢占式：某一进程被调度运行后，除非自身原因导致不能运行，否则一直运行下去。</p>
<p><strong>I&#x2F;O 密集型和 CPU 密集型进程</strong></p>
<p>I&#x2F;O 密集型：需要频繁地进行 I&#x2F;O 操作的进程。 I&#x2F;O 操作会阻塞进程</p>
<p>CPU 密集型：需要大量的 CPU 时间进行计算。</p>
<h3 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h3><ul>
<li><p><strong>周转时间</strong>（Turnaround Time）：每个进程从提出请求到运行完成的时间。运行完成时刻 - 任务到达时刻</p>
</li>
<li><p>加权周转时间（Turnaround Time With Weight）：周转时间与实际运行时间的比值。</p>
</li>
<li><p>等待时间：进程处于等待CPU调度的时间之和。</p>
</li>
<li><p><strong>响应时间</strong>：从提出请求到第一次回应的时间。</p>
</li>
<li><p>公平性（Fairness）：保证每个进程都能获得一定程度的CPU时间。</p>
</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>批处理系统没有太多的用户操作，在该系统中，调度算法（即以下四种算法）目标是保证吞吐量和<strong>周转时间</strong>。</p>
<p><strong>先来先服务</strong>（first-come first-serverd，FCFS）</p>
<ul>
<li><strong>非抢占式</strong>，按照请求的顺序进行调度。</li>
<li>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行</li>
</ul>
<p><strong>最短作业优先</strong>（shortest job first，SJF）</p>
<ul>
<li><strong>非抢占式</strong>，按运行时间最短（假设操作系统知道每个任务用时）的顺序进行调度。区别于 STCF</li>
<li>有利于短作业，但不利于长作业。因为如果一直有短作业到来，那么长作业永远得不到调度。</li>
</ul>
<p><strong>最短完成时间优先</strong>（Shortest Time-to-Completion First，STCF）</p>
<ul>
<li><strong>最短作业优先的抢占式版本</strong>。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，<strong>则挂起当前进程，运行新的进程</strong>。否则新的进程等待。</li>
</ul>
<p><strong>最高响应比优先</strong>（Highest Response Ratio Next, HRRN)</p>
<p>是对 FCFS 和 SJF 的综合平衡，调度时计算每个进程的响应比 R ，总是选择 R 最高的进程执行，属于<strong>非抢占式</strong>调度算法。</p>
<p><img src="/2022/04/05/Virtualization/1643024036695-ef32003d-a133-42c3-9347-7c8e035b9784.png"></p>
<p>当等待时间相同时，则运行时间越短响应比越高，实现短作业优先（SJF)</p>
<p>当运行时间相同时，等待时间越长响应比越高，实现先来先服务（FCFS）</p>
<p>实际上等价于将调度队列的各个任务按照 R 排序，R 大的在队头。</p>
<h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法（即以下三种算法）的目标是<strong>减少响应时间</strong>。即</p>
<p><strong>时间片轮转</strong>（Round Robin，RR）</p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，<strong>并将它送往就绪队列的末尾</strong>，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的<strong>效率</strong>和<strong>时间片的大小</strong>有很大关系：</p>
<ul>
<li><ul>
<li>时间片太小，会导致进程频繁切换，浪费资源。<ul>
<li>时间片过长，以至于所有进程都能在一个时间片内执行完毕，则 RR 算法退化成为 FCFS 算法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>优先级调度</strong>（Highest Priority First，HPF）</p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>多级反馈队列</strong>（Multi-Level Feedback Queue，MLFQ）</p>
<p>基本思想</p>
<ul>
<li>减少周转时间：通过先执行短工作来实现（SJF），然而，操作系统通常不知道工作要运行多久</li>
<li>减少响应时间：轮转。轮转算法虽然降低了响应时间，周转时间却很差。</li>
</ul>
<p>关键问题：没有工作长度的先验信息，不知道工作要运行多久，如何设计一个能同时减少响应时间和周转时间的调度程序——也就是，让短工作先执行，并且要加入轮转</p>
<p>MLFQ 将刚到的工作假设为短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ近似于SJF</p>
<p>多级反馈队列算法(MLFQ)是 RR 算法和 HPF 算法的综合平衡，<strong>动态调整进程的优先级和时间片大小</strong>，实现思想如下：</p>
<ol>
<li>设置多个就绪队列，并为每个队列赋予不同的优先级，第 1 级队列的优先级最高，第 2 级队列次之，其余队列的优先级逐次降低； 优先级越高的队列，每个进程的运行时间片越小（当作短任务）。即便进程被阻塞，也正常计算其占用时间</li>
<li>当一个新进程进入内存后，首先放入第 1 级队列的末尾，按 FCFS 的原则排队等待调度。当该进程执行时，如果其能在时间片内完成便撤离系统；如果它在一个时间片结束未完成，该进程进入第 2 级队列按照 FCFS 的原则等待调度，以此类推。对于最后一级队列，进程执行一个时间片结束未完成会回到该队列的队尾。（如图中的环，如果前面队列的任务过多，可能导致饥饿问题）</li>
<li>仅当第 1 级队列为空时，调度程序才调度第 2 级队列的进程进行执行，以此类推。</li>
</ol>
<p><img src="/2022/04/05/Virtualization/1643033924079-f75ee3ea-89da-44bb-bcfb-b1b8055447d1.png"></p>
<p>优点：</p>
<p>短作业可以在前面的队列内完成，长作业可以得到部分执行。</p>
<p>交互型作业通常较短，系统只要能使其第1级队列所规定的时间片内完成，即可使终端用户感到满意。</p>
<p>不必人为估计进程的执行时间。</p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要切换 100 次。</p>
<p>假设多级队列从队列 1 开始分配的时间片为 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要切换 7 次。1+2+4+8+16+32+64</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/JavaPractice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/JavaPractice/" class="post-title-link" itemprop="url">JavaPractice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-05 15:59:40" itemprop="dateCreated datePublished" datetime="2022-04-05T15:59:40+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-08 16:41:14" itemprop="dateModified" datetime="2022-04-08T16:41:14+08:00">2022-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h1 id="多线程共享变量"><a href="#多线程共享变量" class="headerlink" title="多线程共享变量"></a>多线程共享变量</h1><p>在多线程访问共享对象和数据时候大致可以分为两大类。</p>
<p>1：如果每个线程执行的代码相同，可以使用同一个runnable对象，这个runnable对象中有共享变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MulteThreadlShareData &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ShareData shareData = new ShareData();</span><br><span class="line">        new Thread(shareData).start();</span><br><span class="line">        new Thread(shareData).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ShareData implements Runnable&#123;</span><br><span class="line">        int count = 100;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while(count&gt;0)&#123;</span><br><span class="line">                // 这里可能有多个线程同时到达</span><br><span class="line">            	synchronized(this) &#123;</span><br><span class="line">            		if(count == 0) // 如果多个线程进入 while，保证这里的 count 一定是正数</span><br><span class="line">                    	break;</span><br><span class="line">            		count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;this count: &quot;+count); </span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果每个线程对一个共享变量执行的操作不同，这时候需要用不同的Runnable对象。</p>
<ul>
<li>将共享数据封装成一个对象，然后将这个对象传递给各个Runnable对象</li>
<li>将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。</li>
</ul>
<p> 例：银行存取款</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class Acount &#123;</span><br><span class="line"> </span><br><span class="line">	 private int money;</span><br><span class="line">	 public Acount(int money)&#123;</span><br><span class="line">	   this.money=money;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 public synchronized void getMoney(int money)&#123;</span><br><span class="line">	  while(this.money&lt;money)&#123;		  </span><br><span class="line">		   System.out.println(&quot;取款：&quot;+money+&quot; 余额：&quot;+this.money+&quot; 余额不足，正在等待存款......&quot;);</span><br><span class="line">		   try&#123; wait();&#125; catch(Exception e)&#123;&#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	  this.money=this.money-money;</span><br><span class="line">	  System.out.println(&quot;取出：&quot;+money+&quot; 还剩余：&quot;+this.money);</span><br><span class="line">	 </span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 public synchronized void setMoney(int money)&#123;</span><br><span class="line">	 </span><br><span class="line">	  try&#123; Thread.sleep(10);&#125;catch(Exception e)&#123;&#125;</span><br><span class="line">	  this.money=this.money+money;</span><br><span class="line">	  System.out.println(&quot;新存入：&quot;+money+&quot; 共计：&quot;+this.money);</span><br><span class="line">	  notify();</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 public static void main(String args[])&#123;</span><br><span class="line">		  Acount Acount=new Acount(0);</span><br><span class="line">		  Bank b=new Bank(Acount);</span><br><span class="line">		  Consumer c=new Consumer(Acount);</span><br><span class="line">		  new Thread(b).start();</span><br><span class="line">		  new Thread(c).start();</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line">//存款类</span><br><span class="line">class Bank implements Runnable &#123;</span><br><span class="line">		Acount Acount;</span><br><span class="line">		public Bank(Acount Acount)&#123;</span><br><span class="line">			this.Acount=Acount;</span><br><span class="line">		&#125;</span><br><span class="line">		public void run()&#123;</span><br><span class="line">			while(true)&#123;</span><br><span class="line">				 int temp=(int)(Math.random()*1000);</span><br><span class="line">				 Acount.setMoney(temp);	 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">//取款类</span><br><span class="line">class Consumer implements Runnable &#123;</span><br><span class="line">		Acount Acount;</span><br><span class="line">		public Consumer(Acount Acount)&#123;</span><br><span class="line">			this.Acount=Acount;</span><br><span class="line">		&#125;</span><br><span class="line">		public void run()&#123;</span><br><span class="line">		while(true)&#123;		 </span><br><span class="line">			int temp=(int)(Math.random()*1000);</span><br><span class="line">			Acount.getMoney(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="多线程打印abc"><a href="#多线程打印abc" class="headerlink" title="多线程打印abc"></a>多线程打印abc</h1><p>3个线程循环打印ABC，其中A打印3次，B打印2次，C打印1次，循环打印2轮</p>
<p>print 对象中的 num 作为条件变量，决定哪个线程被唤醒。</p>
<p>下面的count是否要改成volatile?</p>
<p>由于对print对象加锁，因此由Synchronized 和 ReentrantLock 保证了print对象，包括它的count属性的可见性</p>
<h2 id="1-Synchronized"><a href="#1-Synchronized" class="headerlink" title="1 Synchronized"></a>1 Synchronized</h2><h3 id="1-1-互斥"><a href="#1-1-互斥" class="headerlink" title="1.1 互斥"></a>1.1 互斥</h3><p>如果只执行线程A，并且改写代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void PrintA()&#123;</span><br><span class="line">        // 循环打印2轮</span><br><span class="line">		for (int j = 0; j &lt; 2; )&#123;</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">            	System.out.println(&quot;x&quot;);</span><br><span class="line">                while(num == 1)&#123;</span><br><span class="line">                	</span><br><span class="line">                //打印3次</span><br><span class="line">                for (int i = 0; i &lt; 3; i++) &#123; </span><br><span class="line">                    System.out.println(&quot;A&quot;);  </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //打印A线程执行完，设置num=2，则</span><br><span class="line">                num = 2;  </span><br><span class="line">                </span><br><span class="line">                ++j; // 注意把 ++j 移到这里</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>为什么会无线输出”x”？</p>
<p>如果把++j移回for()里</p>
<p>久会输出</p>
<p>x<br>A<br>A<br>A<br>y<br>x</p>
<p>然后停止。</p>
<p>不能认为是，先获取锁，进入了同步块，然后如果num&#x3D;1，就执行while，若num!&#x3D;1，就离开while</p>
<p>实际上，synchronized 只是起修饰的作用。这个代码的意思是，while语句</p>
<p>注意把 ++j 移到同步块中，否则只执行一次AAABBC。这是因为？？？？</p>
<p>因为可能别的线程先运行了？</p>
<p>包括1.2的this.notifyAll()也是在同步块中，因为？？</p>
<p>从共享变量修改的角度，while可以改成if，因为只有同步块才可能修改num</p>
<p>采用互斥，需要认为地控制线程运行的顺序。无法像wait notify那样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		</span><br><span class="line">		int num = 1;//当前正在执行线程的标记。初值为1，让线程 A 先执行</span><br><span class="line">		ABCPrint print = new ABCPrint(num); // print对象作为不同线程的共享变量，不同线程获取print对象的锁从而实现同步。主要包括：互斥地修改共享变量 print.num，互斥地打印</span><br><span class="line">		</span><br><span class="line">		Thread threadA = new Thread(new RunnableA(print));</span><br><span class="line">		Thread threadB = new Thread(new RunnableB(print));</span><br><span class="line">		Thread threadC = new Thread(new RunnableC(print));</span><br><span class="line">		threadA.start();</span><br><span class="line">		Thread.sleep(500); // 保证初始线程按照ABC的启动顺序</span><br><span class="line">		threadB.start();</span><br><span class="line">		Thread.sleep(500);</span><br><span class="line">		threadC.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class RunnableA implements Runnable&#123;</span><br><span class="line">	private ABCPrint print;</span><br><span class="line">	public RunnableA(ABCPrint print) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.print = print;	</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;		</span><br><span class="line">		print.PrintA();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class RunnableB implements Runnable&#123;</span><br><span class="line">	private ABCPrint print;</span><br><span class="line">	public RunnableB(ABCPrint print) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.print = print;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;		</span><br><span class="line">		print.PrintB();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class RunnableC implements Runnable&#123;</span><br><span class="line">	private ABCPrint print;</span><br><span class="line">	public RunnableC(ABCPrint print) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.print = print;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;		</span><br><span class="line">		print.PrintC();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ABCPrint &#123;</span><br><span class="line">	private int num;//当前正在执行线程的标记</span><br><span class="line">	public ABCPrint(int num) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void PrintA()&#123;</span><br><span class="line">        // 循环打印2轮</span><br><span class="line">		for (int j = 0; j &lt; 2; )&#123;</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">                while(num == 1)&#123;</span><br><span class="line">                    </span><br><span class="line">                //打印3次</span><br><span class="line">                for (int i = 0; i &lt; 3; i++) &#123; </span><br><span class="line">                    System.out.println(&quot;A&quot;);  </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //打印A线程执行完，设置num=2，则</span><br><span class="line">                num = 2;  </span><br><span class="line">                ++j; // 注意把 ++j 移到这里</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void PrintB()&#123;</span><br><span class="line">		for (int j = 0; j &lt; 2; )&#123;</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">                while(num == 2)&#123;</span><br><span class="line">                    </span><br><span class="line">                for (int i = 0; i &lt; 2; i++) &#123; </span><br><span class="line">                    System.out.println(&quot;B&quot;);  </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                num = 3;  </span><br><span class="line">                ++j; </span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void PrintC()&#123;</span><br><span class="line">		for (int j = 0; j &lt; 2; )&#123;</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">                while(num == 3)&#123;</span><br><span class="line">                </span><br><span class="line">                System.out.println(&quot;C&quot;);  </span><br><span class="line"></span><br><span class="line">                num = 1;  </span><br><span class="line">                ++j; </span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h3 id="1-2-使用-wait-和-notify"><a href="#1-2-使用-wait-和-notify" class="headerlink" title="1.2 使用 wait() 和 notify()"></a>1.2 使用 wait() 和 notify()</h3><p>不使用 wait() 和 notify()，而仅仅使用锁进行互斥，是可以实现功能的。但是由于阻塞线程无法马上被唤醒，并不是一个实际推荐的写法。</p>
<p>使用 while，保证被唤醒后满足继续运行的条件，否则就继续等待</p>
<p>：例如线程 A 不能保证是被线程 B 唤醒。在下面的实现中，使用 notifyAll()，则线程 A 会唤醒 B 和 C</p>
<p>：while 和 notifyAll() 是互相配合的，如果只使用 notify()，在这种多个等待线程的情况下，可能会死锁</p>
<p>使用 wait() 和 notify() 注意：</p>
<ul>
<li><p><strong>调用 wait() 和 notify() 的对象是什么</strong></p>
</li>
<li><p><strong>线程被唤醒后会尝试重新获得锁</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public synchronized String getTask() &#123;</span><br><span class="line">    while (queue.isEmpty()) &#123;</span><br><span class="line">    	// 当一个线程执行到getTask()方法内部的while循环时，它必定已经获取到了this锁</span><br><span class="line">        // 释放this锁，与 synchronized 加锁的对象一致</span><br><span class="line">        this.wait();</span><br><span class="line">        // 重新获取this锁</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意到 while 语句中的条件变为：!&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前正在执行线程的标记。初值为1，让线程 A 先执行</span></span><br><span class="line">		<span class="type">ABCPrint</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ABCPrint</span>(num); <span class="comment">// print对象作为不同线程的共享变量，不同线程获取print对象的锁从而实现同步。主要包括：互斥地修改共享变量 print.num，互斥地打印</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableA</span>(print));</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableB</span>(print));</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableC</span>(print));</span><br><span class="line">		threadA.start();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>); <span class="comment">// 保证初始线程按照ABC的启动顺序</span></span><br><span class="line">		threadB.start();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		threadC.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ABCPrint print;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RunnableA</span><span class="params">(ABCPrint print)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.print = print;	</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;		</span><br><span class="line">		print.PrintA();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ABCPrint print;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RunnableB</span><span class="params">(ABCPrint print)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.print = print;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;		</span><br><span class="line">		print.PrintB();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableC</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ABCPrint print;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RunnableC</span><span class="params">(ABCPrint print)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.print = print;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;		</span><br><span class="line">		print.PrintC();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABCPrint</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//当前正在执行线程的标记</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ABCPrint</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 循环打印2轮</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(num != <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//打印3次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; </span><br><span class="line">                    System.out.println(<span class="string">&quot;A&quot;</span>);  </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印A线程执行完，唤醒其他所有线程</span></span><br><span class="line">                num = <span class="number">2</span>;  </span><br><span class="line">                <span class="built_in">this</span>.notifyAll();  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintB</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(num != <span class="number">2</span>)&#123; <span class="comment">// 检查被唤醒后是否满足条件</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                num = <span class="number">3</span>;  </span><br><span class="line">                <span class="built_in">this</span>.notifyAll();  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintC</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)<span class="comment">//表示 循环打印2轮</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(num != <span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">                num = <span class="number">1</span>;  </span><br><span class="line">                <span class="built_in">this</span>.notifyAll();  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2 ReentrantLock"></a>2 ReentrantLock</h2><p>Condition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的，并且其行为也是一样的：</p>
<ul>
<li>await() 会释放当前锁，进入等待状态；</li>
<li>signal() 会唤醒某个等待线程；</li>
<li>signalAll() 会唤醒所有等待线程；</li>
<li><strong>线程被唤醒后会尝试重新获得锁</strong>。</li>
</ul>
<p>此外，和 tryLock() 类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来：</p>
<h3 id="2-1-互斥"><a href="#2-1-互斥" class="headerlink" title="2.1 互斥"></a>2.1 互斥</h3><p>共享变量 print 中的 Lock 对象被多线程共享。用共享的 ReentrantLock 修改 Synchronized 块的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABCPrint</span> &#123;</span><br><span class="line">	<span class="comment">// 多线程共享同一个 Lock 对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//当前正在执行线程的标记</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ABCPrint</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintA</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>;) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">			    lock.lock();</span><br><span class="line">			    <span class="keyword">while</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;<span class="comment">//打印3次</span></span><br><span class="line">					    System.out.println(<span class="string">&quot;A&quot;</span>);  </span><br><span class="line">			        &#125;</span><br><span class="line">			    	<span class="comment">//打印A线程执行完 ，通知打印B线程</span></span><br><span class="line">	                num = <span class="number">2</span>;  </span><br><span class="line">	                j++; <span class="comment">// 注意把 ++j 移到这里</span></span><br><span class="line">			    &#125;</span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			    lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintB</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>;)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">	            lock.lock();</span><br><span class="line">			    <span class="keyword">while</span>(num == <span class="number">2</span>)&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;B&quot;</span>);  </span><br><span class="line">					&#125;</span><br><span class="line">			        <span class="comment">//打印B线程执行完 ，通知打印C线程</span></span><br><span class="line">                    num = <span class="number">3</span>;  </span><br><span class="line">                    j++;	    </span><br><span class="line">		        &#125;</span><br><span class="line">	        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	        	lock.unlock();</span><br><span class="line">	        &#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintC</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>;) &#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">			    lock.lock();</span><br><span class="line">			    <span class="keyword">while</span>(num == <span class="number">3</span>)&#123;</span><br><span class="line">			       System.out.println(<span class="string">&quot;C&quot;</span>); </span><br><span class="line">			       <span class="comment">//打印C线程执行完 ，通知打印A线程</span></span><br><span class="line">	               num = <span class="number">1</span>;  </span><br><span class="line">	               j++;</span><br><span class="line">	            &#125;  </span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			    lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h3 id="2-2-使用-Condition"><a href="#2-2-使用-Condition" class="headerlink" title="2.2 使用 Condition"></a>2.2 使用 Condition</h3><p>不需要使用 while 检查被唤醒后是否满足条件，是因为 Condition 能够唤醒指定的线程。与 wait() notify() 不一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">class ABCPrint &#123;</span><br><span class="line">	// 共享变量包括：lock、condition</span><br><span class="line">	private static final Lock lock = new ReentrantLock();</span><br><span class="line">	private Condition condition1 = lock.newCondition();</span><br><span class="line">	private Condition condition2 = lock.newCondition();</span><br><span class="line">	private Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">	private int num;//当前正在执行线程的标记</span><br><span class="line">	public ABCPrint(int num) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void PrintA()&#123;</span><br><span class="line">        // 循环打印2轮</span><br><span class="line">		for (int j = 0; j &lt; 2; j++)&#123;</span><br><span class="line">            </span><br><span class="line">			lock.lock();</span><br><span class="line">			</span><br><span class="line">			try &#123;</span><br><span class="line">				//1.判断</span><br><span class="line">				if(num != 1)&#123;</span><br><span class="line">					condition1.await();</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				//2.打印</span><br><span class="line">				for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">					System.out.println(&quot;A&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				//唤醒，包括两个步骤：设置num、唤醒指定的线程B</span><br><span class="line">				num = 2;</span><br><span class="line">				condition2.signal(); </span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				// TODO: handle exception</span><br><span class="line">			&#125;finally&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void PrintB()&#123;</span><br><span class="line">		for (int j = 0; j &lt; 2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			</span><br><span class="line">			try &#123;</span><br><span class="line">				if(num != 2)&#123;</span><br><span class="line">					condition2.await();</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">					System.out.println(&quot;B&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				num = 3;</span><br><span class="line">				condition3.signal();</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				// TODO: handle exception</span><br><span class="line">			&#125;finally&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void PrintC()&#123;</span><br><span class="line">		for (int j = 0; j &lt; 2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			</span><br><span class="line">			try &#123;</span><br><span class="line">				if(num != 3)&#123;</span><br><span class="line">					condition3.await();</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				for (int i = 0; i &lt; 1; i++) &#123;</span><br><span class="line">					System.out.println(&quot;C&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(&quot;---------------------------&quot;);// 两轮的分隔符</span><br><span class="line"></span><br><span class="line">				num = 1;</span><br><span class="line">				condition1.signal();</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				// TODO: handle exception</span><br><span class="line">			&#125;finally&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="3-AtomicInteger"><a href="#3-AtomicInteger" class="headerlink" title="3 AtomicInteger"></a>3 AtomicInteger</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	 </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new ABCPrint(&quot;A&quot;,3).start();//A打印3次</span><br><span class="line">		new ABCPrint(&quot;B&quot;,2).start();</span><br><span class="line">		new ABCPrint(&quot;C&quot;,1).start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class ABCPrint extends Thread &#123;</span><br><span class="line">	//打印次数，不是共享变量</span><br><span class="line">	private int count;</span><br><span class="line"> </span><br><span class="line">	private final String str[] = &#123; &quot;A&quot;, &quot;B&quot;, &quot;C&quot; &#125;;</span><br><span class="line">	</span><br><span class="line">	private final static AtomicInteger  atomCount= new AtomicInteger();// 共享变量</span><br><span class="line"> </span><br><span class="line">	public ABCPrint(String name,int count) &#123;</span><br><span class="line">		// name：线程的名字</span><br><span class="line">		this.setName(name);</span><br><span class="line">		this.count = count;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			// 循环满2轮退出打印</span><br><span class="line">			if (atomCount.get() / 3 == 2) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			synchronized (atomCount) &#123;</span><br><span class="line">				// 顺序打印A、B、C</span><br><span class="line">				// getName()实际上是this.getName()，得到当前线程的名字</span><br><span class="line">				if (str[atomCount.get() % 3].equals(getName())) &#123; </span><br><span class="line">					atomCount.getAndIncrement();//自增</span><br><span class="line">					</span><br><span class="line">					//打印次数</span><br><span class="line">					for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">						System.out.println(getName());</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					//表示一轮打印结束 方便观察打印下分隔符</span><br><span class="line">					if (&quot;C&quot;.equals(getName())) &#123;</span><br><span class="line">						System.out.println(&quot;================================&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					// 当前线程打印打印完成后唤醒其它线程</span><br><span class="line">					atomCount.notifyAll();</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					// 非顺序线程wait()</span><br><span class="line">					try &#123;</span><br><span class="line">						atomCount.wait();</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-Semaphore"><a href="#4-Semaphore" class="headerlink" title="4 Semaphore"></a>4 Semaphore</h2><p>信号量（Semaphore）线程同步机制，当调用acquire()时，内部计数器数值增加；调用release()时，内部计数器递减；计数器值不能小于0，如果等于0，acquire()方法被阻塞，需要等待其他线程调用release()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	</span><br><span class="line">	 public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">	        new ThreadA(3).start();</span><br><span class="line">	        new ThreadB(2).start();</span><br><span class="line">	        new ThreadC(1).start();</span><br><span class="line">	   &#125;</span><br><span class="line">	 </span><br><span class="line">	//以A开始的信号量,初始信号量数量为1</span><br><span class="line">    private static Semaphore A = new Semaphore(1);</span><br><span class="line">    //B、C信号量,A完成后开始,初始信号数量为0</span><br><span class="line">    private static Semaphore B = new Semaphore(0);</span><br><span class="line">    private static Semaphore C = new Semaphore(0);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    static class ThreadA extends Thread &#123;</span><br><span class="line">    	private int count;</span><br><span class="line">        public ThreadA(int count) &#123;</span><br><span class="line">			super();</span><br><span class="line">			this.count = count;</span><br><span class="line">		&#125;</span><br><span class="line">		@Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                    A.acquire();// A获取信号执行,A信号量减1,当A为0时将无法继续获得该信号量</span><br><span class="line">                    for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">                    	   System.out.print(&quot;A&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">                 </span><br><span class="line">                    B.release();// B释放信号，B信号量加1（初始为0），此时可以获取B信号量</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    static class ThreadB extends Thread &#123;</span><br><span class="line">    	private int count;</span><br><span class="line">        public ThreadB(int count) &#123;</span><br><span class="line">			super();</span><br><span class="line">			this.count = count;</span><br><span class="line">		&#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                    B.acquire();</span><br><span class="line">                    for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">                    	System.out.print(&quot;B&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">                    C.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    static class ThreadC extends Thread &#123;</span><br><span class="line">    	private int count;</span><br><span class="line">        public ThreadC(int count) &#123;</span><br><span class="line">			super();</span><br><span class="line">			this.count = count;</span><br><span class="line">		&#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                    C.acquire();</span><br><span class="line">                    for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">                    	System.out.println(&quot;C&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">                    A.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/DesignMode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/DesignMode/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-05 15:23:07" itemprop="dateCreated datePublished" datetime="2022-04-05T15:23:07+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-08 16:40:49" itemprop="dateModified" datetime="2022-04-08T16:40:49+08:00">2022-04-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>设计模式</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/04/05/DesignMode/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/04/Java-basis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Cyl">
      <meta itemprop="description" content="顽童大了别那么笨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘溪行">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/Java-basis/" class="post-title-link" itemprop="url">Java basis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-04 14:15:06" itemprop="dateCreated datePublished" datetime="2022-04-04T14:15:06+08:00">2022-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-08 16:41:00" itemprop="dateModified" datetime="2022-04-08T16:41:00+08:00">2022-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<p>基本类型    大小    取值范围    装箱基本类型<br>int    4个字节    -2^31 ~ 2^31-1    Integer<br>char    2个字节         Character<br>byte    1个字节    -2^7 ~ 2^7-1    Byte<br>short    2个字节    -2^15 ~ 2^15-1    Short<br>long    8个字节    -2^63 ~ 2^63-1    Long<br>float    4个字节         Float<br>double    8个字节         Double<br>boolean    1或者4个字节    true ~ false    Boolean</p>
<p>引用&#x2F;地址：根据系统位数决定</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cyl"
      src="/images/icon1.jpg">
  <p class="site-author-name" itemprop="name">Cyl</p>
  <div class="site-description" itemprop="description">顽童大了别那么笨</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cyl</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
